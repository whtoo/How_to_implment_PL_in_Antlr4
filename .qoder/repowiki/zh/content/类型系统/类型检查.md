# 类型检查

<cite>
**本文档中引用的文件**  
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java)
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java)
- [Type.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\Type.java)
- [TypeTable.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeTable.java)
- [VariableSymbol.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\symbol\VariableSymbol.java)
</cite>

## 目录
1. [简介](#简介)
2. [类型检查架构](#类型检查架构)
3. [核心组件分析](#核心组件分析)
4. [类型兼容性判断机制](#类型兼容性判断机制)
5. [表达式类型推断](#表达式类型推断)
6. [语句类型验证](#语句类型验证)
7. [函数调用匹配](#函数调用匹配)
8. [错误报告与恢复策略](#错误报告与恢复策略)
9. [类型检查流程解析](#类型检查流程解析)
10. [高级类型推导机制](#高级类型推导机制)

## 简介
本文档详细介绍了基于ANTLR4实现的静态类型检查器的内部机制。重点阐述了类型检查器如何遍历抽象语法树（AST）执行类型验证，包括表达式类型推断、语句类型验证和函数调用匹配等核心功能。文档还深入解析了类型兼容性判断算法、错误报告机制以及为初学者和高级用户提供的不同类型检查流程。

## 类型检查架构

```mermaid
graph TD
A[AST] --> B[TypeCheckVisitor]
B --> C[TypeChecker]
C --> D[TypeTable]
C --> E[Scope]
B --> F[CompilerLogger]
G[SymbolTable] --> B
H[ParseTreeProperty] --> B
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L1-L50)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L1-L50)

## 核心组件分析

### TypeCheckVisitor 组件分析

```mermaid
classDiagram
class TypeCheckVisitor {
+ScopeUtil scopeUtil
+ParseTreeProperty<Type> types
+visitVarDecl(VarDeclContext) Type
+visitStatAssign(StatAssignContext) Type
+visitExprBinary(ExprBinaryContext) Type
+visitExprFuncCall(ExprFuncCallContext) Type
+visitStatReturn(StatReturnContext) Type
}
class CymbolASTVisitor {
<<abstract>>
}
TypeCheckVisitor --|> CymbolASTVisitor : 继承
TypeCheckVisitor --> TypeChecker : 使用
TypeCheckVisitor --> ScopeUtil : 使用
TypeCheckVisitor --> ParseTreeProperty : 使用
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L20-L40)

**本节来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L1-L100)

### TypeChecker 组件分析

```mermaid
classDiagram
class TypeChecker {
+resolveToActualType(Type) Type
+checkAssignmentCompatibility(Type, Type, ParserRuleContext) boolean
+checkBinaryOperationCompatibility(Type, Type, String, ParserRuleContext) Type
+checkUnaryOperationCompatibility(Type, String, ParserRuleContext) Type
+checkFunctionCallCompatibility(Type[], Type[], ParserRuleContext) boolean
+checkStructFieldAccess(Type, String, ParserRuleContext) Type
+checkStructMethodCall(Type, String, Type[], ParserRuleContext) Type
}
class Type {
<<interface>>
+getName() String
+isPrimitive() boolean
}
TypeChecker --> Type : 使用
TypeChecker --> TypeTable : 使用
TypeChecker --> CompilerLogger : 使用
```

**图示来源**  
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L15-L30)

**本节来源**  
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L1-L100)

## 类型兼容性判断机制

### 类型兼容性检查流程

```mermaid
flowchart TD
Start([开始类型兼容性检查]) --> ResolveType["解析实际类型<br/>resolveToActualType()"]
ResolveType --> CheckNull["检查null赋值"]
CheckNull --> |是| CheckNonPrimitive["目标类型是否为非基本类型?"]
CheckNull --> |否| CheckSameType["类型是否相同?"]
CheckNonPrimitive --> |是| ReturnTrue["返回true"]
CheckNonPrimitive --> |否| ReturnFalse["返回false"]
CheckSameType --> |是| ReturnTrue
CheckSameType --> |否| CheckNumeric["检查数值类型转换<br/>(int -> float)"]
CheckNumeric --> |是| ReturnTrue
CheckNumeric --> |否| CheckSubtype["检查子类型关系"]
CheckSubtype --> |是| ReturnTrue
CheckSubtype --> |否| ReturnFalse
ReturnTrue --> End([类型兼容])
ReturnFalse --> End
```

**图示来源**  
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L50-L100)

**本节来源**  
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L50-L150)

## 表达式类型推断

### 二元表达式类型推断

```mermaid
sequenceDiagram
participant Visitor as TypeCheckVisitor
participant Checker as TypeChecker
participant Logger as CompilerLogger
Visitor->>Visitor : visitExprBinary()
Visitor->>Visitor : 获取左操作数类型
Visitor->>Visitor : 获取右操作数类型
Visitor->>Visitor : 获取操作符
Visitor->>Checker : checkBinaryOperationCompatibility()
alt 类型兼容
Checker-->>Visitor : 返回结果类型
Visitor->>Visitor : 存储类型信息
Visitor-->>Visitor : 返回结果类型
else 类型不兼容
Checker->>Logger : 记录错误信息
Checker-->>Visitor : 返回null
Visitor->>Visitor : 返回VOID类型
end
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L100-L130)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L150-L200)

**本节来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L100-L150)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L150-L250)

### 一元表达式类型推断

```mermaid
flowchart TD
Start([一元表达式类型推断]) --> GetOperand["获取操作数类型"]
GetOperand --> CheckOperator["检查操作符类型"]
CheckOperator --> |负号(-)| CheckNumeric["是否为数值类型?"]
CheckOperator --> |逻辑非(!)| CheckBoolean["是否为布尔类型?"]
CheckNumeric --> |是| ReturnSame["返回相同类型"]
CheckNumeric --> |否| LogError["记录错误: 不支持负号操作"]
CheckBoolean --> |是| ReturnBoolean["返回布尔类型"]
CheckBoolean --> |否| LogError["记录错误: 不支持逻辑非操作"]
LogError --> ReturnVoid["返回VOID类型"]
ReturnSame --> End([成功])
ReturnBoolean --> End
ReturnVoid --> End
```

**图示来源**  
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L250-L300)

## 语句类型验证

### 赋值语句验证流程

```mermaid
sequenceDiagram
participant Visitor as TypeCheckVisitor
participant Checker as TypeChecker
participant Logger as CompilerLogger
Visitor->>Visitor : visitStatAssign()
Visitor->>Visitor : 访问左表达式
Visitor->>Visitor : 访问右表达式
alt 类型不为空
Visitor->>Checker : checkAssignmentCompatibility()
Checker->>Checker : resolveToActualType()
Checker->>Checker : areTypesCompatible()
alt 类型兼容
Checker-->>Visitor : 返回true
else 类型不兼容
Checker->>Logger : 记录类型不兼容错误
Checker-->>Visitor : 返回false
end
else 类型为空
Logger->>Logger : 记录类型未定义错误
end
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L70-L90)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L30-L70)

**本节来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L70-L100)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L30-L100)

### 返回语句验证流程

```mermaid
flowchart TD
Start([返回语句验证]) --> FindFunction["查找封闭函数"]
FindFunction --> |未找到| LogError1["记录错误: return不在函数内"]
FindFunction --> |找到| GetReturnType["获取函数返回类型"]
GetReturnType --> HasExpr["是否有返回表达式?"]
HasExpr --> |无| CheckVoid["返回类型是否为VOID?"]
HasExpr --> |有| VisitExpr["访问表达式获取类型"]
CheckVoid --> |否| LogError2["记录错误: 应返回值"]
CheckVoid --> |是| End([验证通过])
VisitExpr --> CheckCompatible["检查类型兼容性"]
CheckCompatible --> |兼容| End
CheckCompatible --> |不兼容| LogError3["记录类型不兼容错误"]
LogError1 --> End
LogError2 --> End
LogError3 --> End
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L450-L500)

## 函数调用匹配

### 函数调用类型检查

```mermaid
sequenceDiagram
participant Visitor as TypeCheckVisitor
participant Checker as TypeChecker
participant Scope as Scope
participant Logger as CompilerLogger
Visitor->>Visitor : visitExprFuncCall()
Visitor->>Scope : resolve(函数名)
alt 函数存在
Scope-->>Visitor : 返回MethodSymbol
Visitor->>Visitor : 收集参数类型
Visitor->>Checker : checkFunctionCallCompatibility()
Checker->>Checker : 参数数量检查
loop 每个参数
Checker->>Checker : checkAssignmentCompatibility()
end
alt 所有参数兼容
Checker-->>Visitor : 返回true
Visitor->>Visitor : 返回函数返回类型
else 存在不兼容参数
Checker->>Logger : 记录参数类型错误
Checker-->>Visitor : 返回false
Visitor->>Visitor : 返回VOID类型
end
else 函数不存在
Logger->>Logger : 记录函数未定义错误
Visitor->>Visitor : 返回VOID类型
end
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L200-L280)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L200-L250)

**本节来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L200-L300)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L200-L300)

## 错误报告与恢复策略

### 错误报告机制

```mermaid
classDiagram
class CompilerLogger {
+info(String)
+debug(String)
+error(ParserRuleContext, String)
+warning(ParserRuleContext, String)
}
class TypeCheckVisitor {
+visitVarDecl()
+visitStatAssign()
+visitExprBinary()
}
class TypeChecker {
+checkAssignmentCompatibility()
+checkBinaryOperationCompatibility()
}
TypeCheckVisitor --> CompilerLogger : 调用
TypeChecker --> CompilerLogger : 调用
CompilerLogger --> Console : 输出
CompilerLogger --> File : 记录
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L20-L30)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L20-L30)

**本节来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L50-L100)
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L20-L50)

### 错误恢复策略

```mermaid
flowchart TD
Start([类型检查错误]) --> LogError["记录错误信息"]
LogError --> Continue["继续类型检查"]
Continue --> CheckNext["检查下一个节点"]
CheckNext --> |成功| UpdateType["更新类型信息"]
CheckNext --> |失败| ReturnVoid["返回VOID类型"]
UpdateType --> End([继续编译])
ReturnVoid --> End
End --> ReportAll["报告所有错误"]
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java)

## 类型检查流程解析

### 初学者类型检查流程

```mermaid
flowchart LR
A[开始] --> B[访问AST节点]
B --> C{节点类型}
C --> |变量声明| D[检查类型声明]
C --> |赋值语句| E[检查左右类型兼容]
C --> |二元表达式| F[推断操作结果类型]
C --> |函数调用| G[验证参数匹配]
C --> |返回语句| H[检查返回类型]
D --> I[存储类型信息]
E --> I
F --> I
G --> I
H --> I
I --> J[继续下一个节点]
J --> K{遍历完成?}
K --> |否| B
K --> |是| L[结束]
```

**本节来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java)

## 高级类型推导机制

### 复杂表达式类型推导

```mermaid
sequenceDiagram
participant Visitor as TypeCheckVisitor
participant Checker as TypeChecker
participant ArrayType as ArrayType
participant StructType as StructSymbol
Visitor->>Visitor : visitExprArrayAccess()
Visitor->>Visitor : 获取数组表达式类型
alt 类型为数组
Visitor->>ArrayType : getElementType()
ArrayType-->>Visitor : 返回元素类型
Visitor->>Visitor : 检查索引类型
alt 索引为整数
Visitor->>Visitor : 存储元素类型
Visitor-->>Visitor : 返回元素类型
else 索引非整数
Visitor->>Visitor : 记录索引类型错误
Visitor-->>Visitor : 返回VOID类型
end
else 非数组类型
Visitor->>Visitor : 记录非数组类型错误
Visitor-->>Visitor : 返回VOID类型
end
```

**图示来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L350-L400)

**本节来源**  
- [TypeCheckVisitor.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\pass\TypeCheckVisitor.java#L350-L450)

### 多态操作符处理

```mermaid
flowchart TD
Start([多态操作符处理]) --> GetTypes["获取操作数类型"]
GetTypes --> CheckString["是否涉及字符串?"]
CheckString --> |是| CheckPlus["是否为+操作符?"]
CheckString --> |否| CheckNumeric["是否为数值类型?"]
CheckPlus --> |是| ReturnString["返回字符串类型"]
CheckPlus --> |否| HandleOther["处理其他操作符"]
CheckNumeric --> |是| HandleArithmetic["处理算术运算"]
CheckNumeric --> |否| CheckBoolean["是否为布尔类型?"]
CheckBoolean --> |是| HandleLogical["处理逻辑运算"]
CheckBoolean --> |否| LogError["记录不支持的操作"]
HandleArithmetic --> ReturnNumeric["返回数值类型"]
HandleLogical --> ReturnBoolean["返回布尔类型"]
ReturnString --> End([完成])
ReturnNumeric --> End
ReturnBoolean --> End
LogError --> End
```

**图示来源**  
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L150-L250)

**本节来源**  
- [TypeChecker.java](file://ep19\src\main\java\org\teachfx\antlr4\ep19\symtab\TypeChecker.java#L150-L300)