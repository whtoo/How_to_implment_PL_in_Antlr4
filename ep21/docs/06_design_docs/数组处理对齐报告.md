# EP21测试失败分析报告

## 概述

本报告分析EP21当前测试失败情况，总结根本原因和修复方向。

## 测试失败统计

### 整体情况
- **总测试数**: 727
- **通过**: 723
- **失败**: 6 (数组操作集成测试)
- **错误**: 4 (EP21EP18REndToEndTest)
- **跳过**: 12 (未实现的优化功能)

### 失败分类

#### 1. ArrayOperationIntegrationTest (6个失败)
- testArrayDeclaration
- testArrayAssignment
- testArrayLoop
- testArrayAccess
- testArrayInitialization
- testArrayBoundaries

#### 2. EP21EP18REndToEndTest (4个错误)
- testAdapterAllocation
- testAdapterMultipleAllocations
- testAdapterOverflow
- testAdapterReset

## 失败分析

### 1. ArrayOperationIntegrationTest 失败

#### 失败信息
```
Unsupported RHS type in ArrayAssign: OperandSlot
Unsupported index type in ArrayAccess: OperandSlot
```

#### 根本原因

**问题1**: IR生成时传递了`OperandSlot`类型，但代码生成器期望`FrameSlot`或`ConstVal`类型

**问题2**: 当前的IR生成策略与设计文档不完全一致

#### 代码流程分析

**当前实现**（有问题）：
```java
// ArrayAccessExprNode.visit
arrayAccessExprNode.getArray().accept(this);  // 推送OperandSlot到栈
arrayAccessExprNode.getIndex().accept(this);  // 推送OperandSlot到栈
VarSlot arraySlot = peekEvalOperand();        // 弹出OperandSlot
VarSlot indexSlot = peekEvalOperand();       // 弹出OperandSlot

// 创建ArrayAssign指令
addInstr(ArrayAssign.with(arrayAccess, rhs));
```

**设计文档期望**（正确）：
```java
// 数组赋值应该直接生成LIRArrayStore指令
FrameSlot baseSlot = ...;      // FrameSlot类型
Expr indexExpr = ...;         // ConstVal或FrameSlot类型
Expr valueExpr = ...;        // ConstVal或FrameSlot类型
addInstr(LIRArrayStore(baseSlot, indexExpr, valueExpr));
```

#### 类型不匹配问题

**设计文档中的IR节点层次**：
```
LIRNode (LIR指令基类)
├── LIRNewArray (数组分配)
├── LIRArrayLoad (数组读取) - 推荐用于RValue
├── LIRArrayStore (数组写入) - 推荐用于LValue
└── ArrayAccess (数组访问表达式) - 当前实现
```

**当前代码使用的IR节点**：
- `ArrayAccess` - 作为Expr的子类
- `ArrayAssign` - 作为Stmt的子类

**代码生成器期望的类型**：
```java
// StackVMGenerator.visit(ArrayAssign)
if (valueExpr instanceof FrameSlot valueSlot) {
    emitInstructionWithOperand("load", valueSlot.getSlotIdx());
} else if (valueExpr instanceof ConstVal) {
    emitConst((ConstVal<?>) valueExpr);
} else {
    errors.add("Unsupported RHS type in ArrayAssign: " + valueExpr.getClass().getSimpleName());
}
```

### 2. EP21EP18REndToEndTest 失败

#### 失败信息
```
IllegalArgument: EP18R register allocator cannot be null
```

#### 根本原因

**问题**: 测试代码传入了`null`给`EP18RRegisterAllocatorAdapter`构造函数

**测试代码**（问题）：
```java
IRegisterAllocator adapter = new EP18RRegisterAllocatorAdapter(null);
```

**适配器构造函数**（有null检查）：
```java
public EP18RRegisterAllocatorAdapter(IRegisterAllocator ep18rAllocator) {
    if (ep18rAllocator == null) {
        throw new IllegalArgumentException("EP18R register allocator cannot be null");
    }
    // ...
}
```

#### 分析

这是**测试代码的问题**，不是实现的问题。适配器的null检查是正确的。

**修复方案**: 修改测试代码，传入有效的`LinearScanAllocator`实例

## 设计文档与实现对照

### 1. 数组处理流程对照

#### 设计文档中的规范

**VarDeclNode处理**：
```java
// 处理数组声明
if (varDeclNode.hasArraySize()) {
    FrameSlot lhs = FrameSlot.get((VariableSymbol) varDeclNode.getIdExprNode().getRefSymbol());

    // 评估大小表达式（推送到栈）
    varDeclNode.getArraySizeExpr().accept(this);
    Expr sizeExpr = peekEvalOperand();
    popEvalOperand();

    // 创建LIRNewArray指令
    LIRNewArray newArrayInstr = new LIRNewArray(sizeExpr, lhs, elementTypeName);
    addInstr(newArrayInstr);
}
```

**ArrayAccessExprNode处理（RValue）**：
```java
// 数组读取 - arr[index] 作为RValue
FrameSlot baseSlot = FrameSlot.get(arraySymbol);
Expr indexExpr = ...;  // ConstVal或FrameSlot

// 创建LIRArrayLoad指令
VarSlot resultSlot = OperandSlot.genTemp();
LIRArrayLoad arrayLoadInstr = new LIRArrayLoad(baseSlot, indexExpr, resultSlot);
addInstr(arrayLoadInstr);
pushEvalOperand(resultSlot);
```

**ArrayAccessExprNode处理（LValue）**：
```java
// 数组写入 - arr[index] = value 作为LValue
FrameSlot baseSlot = FrameSlot.get(arraySymbol);
Expr indexExpr = ...;  // ConstVal或FrameSlot
Expr valueExpr = ...;  // ConstVal或FrameSlot

// 创建LIRArrayStore指令
LIRArrayStore arrayStoreInstr = new LIRArrayStore(baseSlot, indexExpr, valueExpr);
addInstr(arrayStoreInstr);
```

#### 当前实现的问题

**问题1**: 使用了`ArrayAccess`节点而不是`LIRArrayLoad/LIRArrayStore`

**问题2**: `ArrayAccess`节点的`array`和`index`字段是`Expr`类型，不是`FrameSlot`或`ConstVal`

**问题3**: 代码生成器无法处理`Expr`类型的array和index

**问题4**: `ArrayAssign`指令的设计与代码生成器不完全匹配

#### 类型系统差异

**设计文档期望**：
- `LIRArrayStore`参数：`FrameSlot baseSlot, Expr index, Expr value`
- `LIRArrayLoad`参数：`FrameSlot baseSlot, Expr index, VarSlot resultSlot`
- 代码生成器能处理：`FrameSlot`, `ConstVal`

**当前实现**：
- `ArrayAssign`参数：`ArrayAccess arrayAccess, Expr value`
- `ArrayAccess`字段：`Expr array, Expr index, FrameSlot baseSlot`
- 代码生成器无法处理：`Expr`类型的array和index

## 修复方案

### 方案A：对齐设计文档（推荐）

**目标**: 完全按照设计文档重构数组处理

#### 步骤1: 修改ArrayAccessExprNode.visit

```java
@Override
public VarSlot visit(ArrayAccessExprNode arrayAccessExprNode) {
    curNode = arrayAccessExprNode;

    // 处理数组表达式（数组变量本身）
    arrayAccessExprNode.getArray().accept(this);
    VarSlot arraySlot = (FrameSlot) peekEvalOperand();

    // 处理索引表达式
    arrayAccessExprNode.getIndex().accept(this);
    Expr indexExpr = peekEvalOperand();

    if (arrayAccessExpr.getArray() instanceof IDExprNode idExprNode) {
        VariableSymbol arraySymbol = (VariableSymbol) idExprNode.getRefSymbol();
        if (arraySymbol == null) {
            throw new IllegalStateException("数组变量符号未解析: " + idExprNode.getImage());
        }
        FrameSlot baseSlot = FrameSlot.get(arraySymbol);

        // 判断是RValue还是LValue
        if (!arrayAccessExprNode.isLValue()) {
            // RValue: 生成LIRArrayLoad指令
            VarSlot resultSlot = OperandSlot.genTemp();
            LIRArrayLoad arrayLoadInstr = new LIRArrayLoad(baseSlot, indexExpr, resultSlot);
            addInstr(arrayLoadInstr);
            pushEvalOperand(resultSlot);
        } else {
            // LValue: 不生成指令，只推送到栈
            // AssignStmtNode会生成LIRArrayStore指令
            ArrayAccess arrayAccess = ArrayAccess.with(baseSlot, indexExpr);
            pushEvalOperand(arrayAccess);
        }
        return null;
    } else {
        throw new UnsupportedOperationException("暂不支持复杂数组表达式: " + arrayAccessExprNode.getArray());
    }
}
```

#### 步骤2: 修改AssignStmtNode.visit

```java
@Override
public Void visit(AssignStmtNode assignStmtNode) {
    curNode = assignStmtNode;
    logger.debug("visit AssignStmtNode: LHS={}, RHS={}",
        assignStmtNode.getLhs(), assignStmtNode.getRhs());

    // 处理RHS
    assignStmtNode.getRhs().accept(this);
    Expr rhsExpr = peekEvalOperand();

    // 检查LHS类型
    if (assignStmtNode.getLhs() instanceof ArrayAccessExprNode arrayAccessExpr) {
        logger.debug("Processing array access as LHS: arr[index] = value");

        // 从栈中弹出ArrayAccess（包含baseSlot和indexExpr）
        ArrayAccess arrayAccess = (ArrayAccess) popEvalOperand();

        // 创建LIRArrayStore指令
        FrameSlot baseSlot = arrayAccess.getBaseSlot();
        Expr indexExpr = arrayAccess.getIndex();

        LIRArrayStore arrayStoreInstr = new LIRArrayStore(baseSlot, indexExpr, rhsExpr);
        addInstr(arrayStoreInstr);
        logger.debug("Created LIRArrayStore instruction");

        // 不需要弹出rhsExpr，因为ArrayAccess包含了所有信息
        return null;
    } else if (assignStmtNode.getLhs() instanceof IDExprNode idExprNode) {
        // 处理普通变量赋值
        var lhs = FrameSlot.get((VariableSymbol) idExprNode.getRefSymbol());
        logger.debug("Created FrameSlot for LHS: {}", idExprNode.getImage());

        addInstr(Assign.with(lhs, rhsExpr));
        popEvalOperand();
        logger.debug("Created Assign instruction: {} = {}", lhs, rhsExpr);

        return null;
    } else {
        throw new UnsupportedOperationException("暂不支持复杂类型的赋值: " + assignStmtNode.getLhs());
    }
}
```

#### 步骤3: 更新代码生成器

修改StackVMGenerator.visit(ArrayAssign)以支持LIRArrayStore：
```java
@Override
public Void visit(ArrayAssign arrayAssign) {
    ArrayAccess arrayAccess = arrayAssign.getArrayAccess();

    Expr valueExpr = arrayAssign.getValue();
    FrameSlot baseSlot = arrayAccess.getBaseSlot();
    Expr indexExpr = arrayAccess.getIndex();

    // 加载数组引用
    if (baseSlot instanceof FrameSlot baseSlotTyped) {
        emitInstructionWithOperand("load", baseSlotTyped.getSlotIdx());
    }

    // 加载索引
    if (indexExpr instanceof FrameSlot indexSlotTyped) {
        emitInstructionWithOperand("load", indexSlotTyped.getSlotIdx());
    } else if (indexExpr instanceof ConstVal constVal) {
        emitConst(constVal);
    }

    // 加载值
    if (valueExpr instanceof FrameSlot valueSlotTyped) {
        emitInstructionWithOperand("load", valueSlotTyped.getSlotIdx());
    } else if (valueExpr instanceof ConstVal constVal) {
        emitConst(constVal);
    }

    emitInstruction("iastore");

    return null;
}
```

### 方案B: 简化修复（临时）

**目标**: 快速修复现有问题，不完全对齐设计文档

#### 修改

保持当前的ArrayAssign和ArrayAccess节点架构，但修复类型转换问题。

## 推荐实施路径

### 短期（1-2小时）
1. 修复EP21EP18REndToEndTest的测试代码
2. 验证非数组测试通过

### 中期（3-5小时）
1. 实施方案B（简化修复）
2. 验证数组操作集成测试通过
3. 对照设计文档验证关键场景

### 长期（5-8小时）
1. 实施方案A（完全对齐设计文档）
2. 完善所有数组处理场景
3. 添加完整的单元测试和集成测试
4. 更新设计文档反映实际实现

## 设计文档更新需求

### 需要补充的内容

1. **类型系统规范**
   - 明确Expr子类与代码生成器的类型期望
   - 说明OperandSlot与FrameSlot的区别和使用场景

2. **代码生成流程图**
   - 补充完整的IR节点到指令的转换流程
   - 添加每种LIR节点的代码生成示例

3. **测试用例规范**
   - 补充数组操作的端到端测试用例
   - 添加边界条件和错误情况测试

## 结论

EP21的测试失败主要集中在数组处理部分，根因在于：
1. IR节点类型系统与代码生成器期望不匹配
2. 实现策略与设计文档不一致

建议按照推荐实施路径，先进行简化修复解决当前问题，然后逐步对齐设计文档，实现完整的数组处理功能。

---

**报告日期**: 2026-01-21
**分析人**: Sisyphus (AI Agent)
**状态**: 待修复实施
