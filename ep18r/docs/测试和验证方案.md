# 测试和验证方案

## 概述

本文档详细描述Cymbol虚拟机测试和验证方案，包括单元测试、集成测试、性能测试、压力测试等内容。

## 测试架构设计

### 测试层次结构

```
测试金字塔
    ├── 单元测试 (70%)
    │   ├── 虚拟机核心
    │   ├── 字节码解释器
    │   ├── 栈帧管理
    │   └── 垃圾回收
    ├── 集成测试 (20%)
    │   ├── 完整执行流程
    │   ├── 组件交互
    │   └── 异常处理
    └── 端到端测试 (10%)
        ├── 实际程序执行
        ├── 性能基准
        └── 兼容性测试
```

### 测试框架设计

#### 基础测试框架
```java
public abstract class VMTestBase {
    // 测试配置
    protected VMConfig testConfig;
    protected CymbolStackVM vm;
    protected VMExecutor executor;

    // 测试数据
    protected TestDataGenerator dataGenerator;
    protected BytecodeCompiler compiler;

    // 断言工具
    protected VMAssertions assertions;
    protected PerformanceChecker performanceChecker;

    @BeforeEach
    void setUpVMTest() {
        // 初始化测试配置
        testConfig = createTestConfig();

        // 创建虚拟机实例
        vm = new CymbolStackVM(testConfig);
        executor = vm.getExecutor();

        // 初始化测试工具
        dataGenerator = new TestDataGenerator();
        compiler = new BytecodeCompiler();
        assertions = new VMAssertions();
        performanceChecker = new PerformanceChecker();
    }

    protected VMConfig createTestConfig() {
        return new VMConfig.Builder()
            .setHeapSize(1024 * 1024) // 1MB for tests
            .setStackSize(1024)
            .setDebugMode(true)
            .setVerboseErrors(true)
            .build();
    }
}
```

#### 性能测试框架
```java
public class PerformanceBenchmark {
    // 基准测试
    public interface Benchmark {
        String getName();
        void setup(VMExecutor executor);
        void execute(VMExecutor executor);
        void cleanup(VMExecutor executor);
    }

    // 执行基准测试
    public BenchmarkResult runBenchmark(Benchmark benchmark, int iterations) {
        List<Long> executionTimes = new ArrayList<>();
        List<Long> memoryUsage = new ArrayList<>();

        for (int i = 0; i < iterations; i++) {
            // 清理内存
            System.gc();
            Thread.sleep(100);

            // 执行前内存使用
            long memoryBefore = getUsedMemory();

            // 计时执行
            benchmark.setup(executor);
            long startTime = System.nanoTime();
            benchmark.execute(executor);
            long endTime = System.nanoTime();
            benchmark.cleanup(executor);

            // 执行后内存使用
            long memoryAfter = getUsedMemory();

            executionTimes.add(endTime - startTime);
            memoryUsage.add(memoryAfter - memoryBefore);
        }

        return new BenchmarkResult(
            benchmark.getName(),
            calculateStats(executionTimes),
            calculateStats(memoryUsage),
            iterations
        );
    }

    private Statistics calculateStats(List<Long> values) {
        long sum = values.stream().mapToLong(Long::longValue).sum();
        double mean = (double) sum / values.size();

        double variance = values.stream()
            .mapToLong(v -> (long) Math.pow(v - mean, 2))
            .sum() / values.size();

        return new Statistics(mean, Math.sqrt(variance),
            Collections.min(values), Collections.max(values));
    }
}
```

## 单元测试设计

### 虚拟机核心测试

#### CymbolStackVM测试
```java
public class CymbolStackVMTest extends VMTestBase {

    @Test
    @DisplayName("应该正确创建虚拟机实例")
    void testVMCreation() {
        assertThat(vm).isNotNull();
        assertThat(vm.getExecutor()).isNotNull();
        assertThat(vm.getMemoryManager()).isNotNull();
        assertThat(vm.getGarbageCollector()).isNotNull();
    }

    @Test
    @DisplayName("应该正确执行简单程序")
    void testSimpleProgramExecution() {
        // 编译简单程序：1 + 2
        byte[] bytecode = compiler.compile("1 + 2");

        // 执行程序
        int result = vm.execute(bytecode);

        // 验证结果
        assertThat(result).isEqualTo(3);
    }

    @Test
    @DisplayName("应该正确处理函数调用")
    void testFunctionCall() {
        String program = """
            int add(int a, int b) {
                return a + b;
            }
            int main() {
                return add(5, 3);
            }
            """;

        byte[] bytecode = compiler.compile(program);
        int result = vm.execute(bytecode);

        assertThat(result).isEqualTo(8);
    }

    @Test
    @DisplayName("应该正确处理栈溢出")
    void testStackOverflow() {
        // 创建会导致栈溢出的程序
        String program = createRecursiveProgram(10000); // 深度递归
        byte[] bytecode = compiler.compile(program);

        assertThatThrownBy(() -> vm.execute(bytecode))
            .isInstanceOf(VMStackOverflowException.class);
    }

    @Test
    @DisplayName("应该正确处理除零错误")
    void testDivisionByZero() {
        String program = "10 / 0";
        byte[] bytecode = compiler.compile(program);

        assertThatThrownBy(() -> vm.execute(bytecode))
            .isInstanceOf(VMDivisionByZeroException.class);
    }

    @Test
    @DisplayName("应该正确执行复杂表达式")
    void testComplexExpression() {
        String program = "(10 + 5) * 2 - 8 / 4"; // 结果：30 - 2 = 28
        byte[] bytecode = compiler.compile(program);
        int result = vm.execute(bytecode);

        assertThat(result).isEqualTo(28);
    }
}
```

#### 字节码解释器测试
```java
public class OptimizedVMInterpreterTest extends VMTestBase {

    @Test
    @DisplayName("应该正确执行算术指令")
    void testArithmeticInstructions() {
        // 测试所有算术指令
        Map<Integer, ExpectedResult> testCases = Map.of(
            BytecodeDefinition.IADD, new ExpectedResult(8, new int[]{5, 3}),
            BytecodeDefinition.ISUB, new ExpectedResult(2, new int[]{5, 3}),
            BytecodeDefinition.IMUL, new ExpectedResult(15, new int[]{5, 3}),
            BytecodeDefinition.IDIV, new ExpectedResult(1, new int[]{5, 3}),
            BytecodeDefinition.IXOR, new ExpectedResult(6, new int[]{5, 3}) // 5 ^ 3 = 6
        );

        for (Map.Entry<Integer, ExpectedResult> entry : testCases.entrySet()) {
            int opcode = entry.getKey();
            ExpectedResult expected = entry.getValue();

            // 创建测试字节码
            byte[] bytecode = createArithmeticBytecode(opcode, expected.operands);

            // 执行
            int result = executor.execute(bytecode);

            // 验证
            assertThat(result)
                .as("指令 " + opcode + " 执行结果")
                .isEqualTo(expected.expectedResult);
        }
    }

    @Test
    @DisplayName("应该正确处理比较指令")
    void testComparisonInstructions() {
        // 测试比较指令：5 > 3 应该返回 1
        byte[] bytecode = createComparisonBytecode(
            BytecodeDefinition.IGT,
            new int[]{5, 3}
        );

        int result = executor.execute(bytecode);
        assertThat(result).isEqualTo(1);

        // 测试：3 > 5 应该返回 0
        bytecode = createComparisonBytecode(
            BytecodeDefinition.IGT,
            new int[]{3, 5}
        );

        result = executor.execute(bytecode);
        assertThat(result).isEqualTo(0);
    }

    @Test
    @DisplayName("应该正确执行控制流指令")
    void testControlFlowInstructions() {
        // 测试分支指令
        String program = """
            int main() {
                int x = 5;
                if (x > 3) {
                    return 1;
                } else {
                    return 0;
                }
            }
            """;

        byte[] bytecode = compiler.compile(program);
        int result = vm.execute(bytecode);

        assertThat(result).isEqualTo(1);
    }

    @Test
    @DisplayName("应该正确执行函数调用")
    void testFunctionCallInstructions() {
        String program = """
            int factorial(int n) {
                if (n <= 1) {
                    return 1;
                }
                return n * factorial(n - 1);
            }
            int main() {
                return factorial(5);
            }
            """;

        byte[] bytecode = compiler.compile(program);
        int result = vm.execute(bytecode);

        assertThat(result).isEqualTo(120); // 5! = 120
    }

    @Test
    @DisplayName("应该正确处理无效指令")
    void testInvalidInstruction() {
        byte[] bytecode = createBytecode(new int[]{999}); // 无效指令

        assertThatThrownBy(() -> executor.execute(bytecode))
            .isInstanceOf(VMInvalidInstructionException.class);
    }

    @Test
    @DisplayName("应该正确执行数组操作")
    void testArrayOperations() {
        String program = """
            int main() {
                int arr[5];
                arr[0] = 10;
                arr[1] = 20;
                return arr[0] + arr[1];
            }
            """;

        byte[] bytecode = compiler.compile(program);
        int result = vm.execute(bytecode);

        assertThat(result).isEqualTo(30);
    }

    // 测试数据类
    private static class ExpectedResult {
        final int expectedResult;
        final int[] operands;

        ExpectedResult(int expectedResult, int[] operands) {
            this.expectedResult = expectedResult;
            this.operands = operands;
        }
    }
}
```

#### 栈帧管理测试
```java
public class StackFrameManagerTest extends VMTestBase {

    @Test
    @DisplayName("应该正确创建和销毁栈帧")
    void testFrameLifecycle() {
        FunctionSymbol function = createFunction("testFunc", 3);

        // 创建栈帧
        EnhancedStackFrame frame = stackFrameManager.pushFrame(function, 3);

        assertThat(stackFrameManager.getStackDepth()).isEqualTo(1);
        assertThat(frame).isNotNull();
        assertThat(frame.getFunctionName()).isEqualTo("testFunc");

        // 销毁栈帧
        EnhancedStackFrame poppedFrame = stackFrameManager.popFrame();

        assertThat(stackFrameManager.getStackDepth()).isEqualTo(0);
        assertThat(poppedFrame).isEqualTo(frame);
    }

    @Test
    @DisplayName("应该正确分配变量槽位")
    void testVariableSlotAllocation() {
        EnhancedStackFrame frame = stackFrameManager.pushFrame(
            createFunction("testFunc", 2), 2);

        // 分配变量
        int slot1 = frame.allocateVariableSlot("var1", Type.INT);
        int slot2 = frame.allocateVariableSlot("var2", Type.FLOAT);

        assertThat(slot1).isGreaterThanOrEqualTo(0);
        assertThat(slot2).isGreaterThanOrEqualTo(0);
        assertThat(slot1).isNotEqualTo(slot2);

        // 设置和获取值
        frame.setLocal(slot1, 42);
        frame.setLocal(slot2, 3);

        assertThat(frame.getLocal(slot1)).isEqualTo(42);
        assertThat(frame.getLocal(slot2)).isEqualTo(3);
    }

    @Test
    @DisplayName("应该正确处理栈溢出")
    void testStackOverflow() {
        FunctionSymbol function = createFunction("overflowFunc", 1);

        // 设置小的最大深度进行测试
        StackFrameManager smallManager = new StackFrameManager(2, 100);
        smallManager.pushFrame(function, 1);
        smallManager.pushFrame(function, 1);

        // 第三次应该失败
        assertThatThrownBy(() -> smallManager.pushFrame(function, 1))
            .isInstanceOf(VMStackOverflowException.class);
    }

    @Test
    @DisplayName("应该正确跟踪变量访问")
    void testVariableAccessTracking() {
        EnhancedStackFrame frame = stackFrameManager.pushFrame(
            createFunction("trackFunc", 1), 1);

        int slot = frame.allocateVariableSlot("trackedVar", Type.INT);

        // 记录访问
        frame.recordVariableAccess("trackedVar", VariableAccess.AccessType.WRITE);
        frame.setLocal(slot, 10);
        frame.recordVariableAccess("trackedVar", VariableAccess.AccessType.READ);

        // 验证访问历史
        List<VariableAccess> accesses = frame.getAccessHistory("trackedVar");
        assertThat(accesses).hasSize(2);
        assertThat(accesses.get(0).getAccessType())
            .isEqualTo(VariableAccess.AccessType.WRITE);
        assertThat(accesses.get(1).getAccessType())
            .isEqualTo(VariableAccess.AccessType.READ);
    }

    @Test
    @DisplayName("应该正确进行内存池管理")
    void testMemoryPool() {
        StackFrameMemoryPool pool = new StackFrameMemoryPool(10);
        FunctionSymbol function = createFunction("poolFunc", 2);

        // 获取栈帧
        EnhancedStackFrame frame1 = pool.acquireFrame(function, 2, null);
        EnhancedStackFrame frame2 = pool.acquireFrame(function, 2, null);

        assertThat(frame1).isNotNull();
        assertThat(frame2).isNotNull();

        // 释放栈帧
        pool.releaseFrame(frame1);
        pool.releaseFrame(frame2);

        // 验证重用
        MemoryPoolStatistics stats = pool.getStatistics();
        assertThat(stats.getCreatedFrames()).isGreaterThanOrEqualTo(2);
    }
}
```

#### 垃圾回收测试
```java
public class GarbageCollectorTest extends VMTestBase {

    @Test
    @DisplayName("应该正确分配和回收对象")
    void testObjectLifecycle() {
        ReferenceCountingGC gc = new ReferenceCountingGC(1024 * 1024);

        // 分配对象
        int objectId = gc.allocate(100);
        assertThat(objectId).isGreaterThan(0);

        // 检查引用计数
        GCObjectHeader header = gc.getObjectHeader(objectId);
        assertThat(header.getRefCount()).isEqualTo(1);

        // 增加引用
        gc.incrementRef(objectId);
        assertThat(header.getRefCount()).isEqualTo(2);

        // 减少引用
        gc.decrementRef(objectId);
        assertThat(header.getRefCount()).isEqualTo(1);

        // 再次减少引用（对象应该被标记为可回收）
        gc.decrementRef(objectId);
        // 具体行为取决于实现
    }

    @Test
    @DisplayName("应该正确检测循环引用")
    void testCycleDetection() {
        ReferenceCountingGC gc = new ReferenceCountingGC(1024 * 1024);

        // 创建两个相互引用的对象
        int object1 = gc.allocate(100);
        int object2 = gc.allocate(100);

        // 建立循环引用
        createObjectReference(object1, object2);
        createObjectReference(object2, object1);

        // 减少根引用
        gc.decrementRef(object1);
        gc.decrementRef(object2);

        // 验证循环引用检测
        assertThat(gc.hasCycleReference(object1)).isTrue();
        assertThat(gc.hasCycleReference(object2)).isTrue();
    }

    @Test
    @DisplayName("应该正确处理内存耗尽")
    void testOutOfMemory() {
        ReferenceCountingGC gc = new ReferenceCountingGC(1024); // 很小的堆

        List<Integer> objects = new ArrayList<>();

        // 尝试分配直到耗尽内存
        assertThatThrownBy(() -> {
            while (true) {
                objects.add(gc.allocate(1024)); // 1KB对象
            }
        }).isInstanceOf(VMOutOfMemoryException.class);

        assertThat(objects.size()).isGreaterThan(0);
    }

    @Test
    @DisplayName("标记-清除GC应该正确工作")
    void testMarkSweepGC() {
        MarkSweepGC gc = new MarkSweepGC(1024 * 1024);

        // 分配多个对象
        List<Integer> objects = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            objects.add(gc.allocate(1024));
        }

        // 标记一半对象为存活
        for (int i = 0; i < 50; i++) {
            markObjectAsAlive(objects.get(i));
        }

        // 执行GC
        gc.collect();

        // 验证存活对象仍然可用
        for (int i = 0; i < 50; i++) {
            assertThat(gc.isObjectAlive(objects.get(i))).isTrue();
        }

        // 验证死亡对象被回收
        for (int i = 50; i < 100; i++) {
            assertThat(gc.isObjectAlive(objects.get(i))).isFalse();
        }
    }

    @Test
    @DisplayName("分代GC应该正确晋升对象")
    void testGenerationalGC() {
        GenerationalGC gc = new GenerationalGC(1024 * 1024);

        // 分配年轻代对象
        List<Integer> youngObjects = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            youngObjects.add(gc.allocate(100));
        }

        // 多次GC后，对象应该晋升到年老代
        for (int gcCount = 0; gcCount < 15; gcCount++) {
            gc.collect(GCTypes.CollectionType.YOUNG_GEN);
        }

        // 检查晋升统计
        GCStatistics stats = gc.getStatistics();
        assertThat(stats.getPromotionCount()).isGreaterThanOrEqualTo(5);
    }
}
```

### 集成测试设计

#### 完整执行流程测试
```java
public class FullExecutionIntegrationTest extends VMTestBase {

    @Test
    @DisplayName("应该完整执行阶乘程序")
    void testFactorialProgram() {
        String program = """
            int factorial(int n) {
                if (n <= 1) {
                    return 1;
                }
                return n * factorial(n - 1);
            }

            int main() {
                int result = factorial(6);
                print(result);
                return result;
            }
            """;

        // 编译和执行
        CompilationResult compilation = compiler.compile(program);
        assertThat(compilation.isSuccessful()).isTrue();

        // 执行程序
        ExecutionResult execution = vm.execute(compilation.getBytecode());

        assertThat(execution.isSuccess()).isTrue();
        assertThat(execution.getReturnValue()).isEqualTo(720); // 6! = 720
        assertThat(execution.getOutput()).contains("720");
    }

    @Test
    @DisplayName("应该完整执行数组操作程序")
    void testArrayOperationsProgram() {
        String program = """
            int main() {
                int numbers[5];
                int sum = 0;

                // 初始化数组
                numbers[0] = 10;
                numbers[1] = 20;
                numbers[2] = 30;
                numbers[3] = 40;
                numbers[4] = 50;

                // 计算总和
                int i = 0;
                while (i < 5) {
                    sum = sum + numbers[i];
                    i = i + 1;
                }

                return sum;
            }
            """;

        CompilationResult compilation = compiler.compile(program);
        assertThat(compilation.isSuccessful()).isTrue();

        ExecutionResult execution = vm.execute(compilation.getBytecode());

        assertThat(execution.isSuccess()).isTrue();
        assertThat(execution.getReturnValue()).isEqualTo(150); // 10+20+30+40+50 = 150
    }

    @Test
    @DisplayName("应该处理复杂的控制流")
    void testComplexControlFlow() {
        String program = """
            int fibonacci(int n) {
                if (n <= 1) {
                    return n;
                }
                return fibonacci(n - 1) + fibonacci(n - 2);
            }

            int main() {
                int result = fibonacci(10);
                return result;
            }
            """;

        CompilationResult compilation = compiler.compile(program);
        assertThat(compilation.isSuccessful()).isTrue();

        // 记录执行时间
        long startTime = System.nanoTime();
        ExecutionResult execution = vm.execute(compilation.getBytecode());
        long endTime = System.nanoTime();

        assertThat(execution.isSuccess()).isTrue();
        assertThat(execution.getReturnValue()).isEqualTo(55); // fibonacci(10) = 55

        // 性能检查
        long executionTime = endTime - startTime;
        assertThat(executionTime).isLessThan(5_000_000_000L); // 5秒内完成
    }

    @Test
    @DisplayName("应该处理错误情况")
    void testErrorHandling() {
        // 测试未定义函数
        String program = "return undefinedFunction();";
        CompilationResult compilation = compiler.compile(program);

        assertThat(compilation.isSuccessful()).isTrue();

        assertThatThrownBy(() -> vm.execute(compilation.getBytecode()))
            .isInstanceOf(VMFunctionNotFoundException.class);
    }
}
```

#### 组件交互测试
```java
public class ComponentInteractionTest extends VMTestBase {

    @Test
    @DisplayName("VM和GC应该正确交互")
    void testVMGCInteraction() {
        String program = """
            int createObjects() {
                int obj1 = allocate(100);
                int obj2 = allocate(200);
                int obj3 = allocate(300);

                // 模拟对象使用
                useObject(obj1);
                useObject(obj2);
                useObject(obj3);

                return 0;
            }
            """;

        CompilationResult compilation = compiler.compile(program);
        ExecutionResult execution = vm.execute(compilation.getBytecode());

        assertThat(execution.isSuccess()).isTrue();

        // 验证GC统计
        GCStatistics gcStats = vm.getGarbageCollector().getStatistics();
        assertThat(gcStats.getCollectionCount()).isGreaterThan(0);
    }

    @Test
    @DisplayName("栈帧和内存管理应该正确交互")
    void testStackFrameMemoryInteraction() {
        String program = """
            int allocateInFunction() {
                int local1 = allocate(1000);
                int local2 = allocate(2000);
                int local3 = allocate(3000);

                // 使用局部变量
                useMemory(local1);
                useMemory(local2);
                useMemory(local3);

                return 0;
            }

            int main() {
                return allocateInFunction();
            }
            """;

        CompilationResult compilation = compiler.compile(program);
        ExecutionResult execution = vm.execute(compilation.getBytecode());

        assertThat(execution.isSuccess()).isTrue();

        // 验证内存使用
        VMStats stats = vm.getExecutionStats();
        assertThat(stats.getPeakMemoryUsage()).isGreaterThan(0);
    }
}
```

### 性能测试设计

#### 基准性能测试
```java
public class VMPerformanceBenchmark {

    @Test
    @DisplayName("算术运算性能基准")
    void testArithmeticPerformance() {
        PerformanceBenchmark benchmark = new PerformanceBenchmark();

        Benchmark addBenchmark = new Benchmark() {
            @Override
            public String getName() {
                return "Integer Addition";
            }

            @Override
            public void setup(VMExecutor executor) {}

            @Override
            public void execute(VMExecutor executor) {
                // 执行10000次加法
                byte[] bytecode = createLoopBytecode(BytecodeDefinition.IADD, 10000);
                executor.execute(bytecode);
            }

            @Override
            public void cleanup(VMExecutor executor) {}
        };

        BenchmarkResult result = benchmark.runBenchmark(addBenchmark, 10);

        assertThat(result.getAverageExecutionTime()).isLessThan(1_000_000); // 1ms
        assertThat(result.getMaxExecutionTime()).isLessThan(2_000_000); // 2ms
    }

    @Test
    @DisplayName("函数调用性能基准")
    void testFunctionCallPerformance() {
        String program = """
            int recursiveFunc(int n) {
                if (n <= 0) {
                    return 0;
                }
                return n + recursiveFunc(n - 1);
            }

            int main() {
                return recursiveFunc(1000);
            }
            """;

        BytecodeCompiler compiler = new BytecodeCompiler();
        CompilationResult compilation = compiler.compile(program);

        CymbolStackVM vm = new CymbolStackVM(createTestConfig());

        long startTime = System.nanoTime();
        ExecutionResult execution = vm.execute(compilation.getBytecode());
        long endTime = System.nanoTime();

        assertThat(execution.isSuccess()).isTrue();

        long executionTime = endTime - startTime;
        assertThat(executionTime).isLessThan(10_000_000_000L); // 10秒
    }

    @Test
    @DisplayName("内存分配性能基准")
    void testMemoryAllocationPerformance() {
        ReferenceCountingGC gc = new ReferenceCountingGC(1024 * 1024);

        long startTime = System.nanoTime();

        // 分配10000个小对象
        for (int i = 0; i < 10000; i++) {
            gc.allocate(100);
        }

        long allocationTime = System.nanoTime() - startTime;
        double nsPerAllocation = allocationTime / 10000.0;

        assertThat(nsPerAllocation).isLessThan(1000); // 1μs per allocation
    }

    @Test
    @DisplayName("垃圾回收性能基准")
    void testGCPerformance() {
        ReferenceCountingGC gc = new ReferenceCountingGC(1024 * 1024);

        // 创建大量对象
        List<Integer> objects = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            objects.add(gc.allocate(1024));
        }

        // 删除一半对象
        for (int i = 0; i < 500; i++) {
            gc.decrementRef(objects.get(i));
        }

        // 测量GC时间
        long startTime = System.nanoTime();
        gc.collect(GCTypes.CollectionType.EAGER);
        long gcTime = System.nanoTime() - startTime;

        assertThat(gcTime).isLessThan(10_000_000); // 10ms
    }
}
```

#### 压力测试
```java
public class VMStressTest extends VMTestBase {

    @Test
    @DisplayName("应该处理大量函数调用")
    void testHighFunctionCallVolume() {
        String program = createHighCallVolumeProgram(10000);

        CompilationResult compilation = compiler.compile(program);

        assertThat(compilation.isSuccessful()).isTrue();

        // 在合理时间内执行
        assertThatCode(() -> vm.execute(compilation.getBytecode()))
            .doesNotThrowAnyException()
            .as("程序应该在合理时间内完成")
            .extracting(execution -> {
                try {
                    return vm.execute(compilation.getBytecode());
                } catch (Exception e) {
                    return null;
                }
            })
            .isNotNull();
    }

    @Test
    @DisplayName("应该处理深度递归")
    void testDeepRecursion() {
        String program = createDeepRecursiveProgram(5000);

        CompilationResult compilation = compiler.compile(program);

        assertThat(compilation.isSuccessful()).isTrue();

        // 深度递归可能会导致栈溢出，但应该在预期范围内
        assertThatThrownBy(() -> vm.execute(compilation.getBytecode()))
            .isInstanceOf(VMStackOverflowException.class);
    }

    @Test
    @DisplayName("应该处理大量内存分配")
    void testHighMemoryAllocation() {
        String program = createHighMemoryProgram(100);

        CompilationResult compilation = compiler.compile(program);

        assertThat(compilation.isSuccessful()).isTrue();

        // 大内存分配可能会导致内存不足
        assertThatCode(() -> vm.execute(compilation.getBytecode()))
            .doesNotThrowAnyException()
            .as("大内存分配应该在虚拟机限制内完成");
    }

    @Test
    @DisplayName("应该处理并发执行")
    void testConcurrentExecution() throws InterruptedException {
        String program = "return 42;";

        CompilationResult compilation = compiler.compile(program);
        assertThat(compilation.isSuccessful()).isTrue();

        // 并发执行多个程序
        List<Future<ExecutionResult>> futures = new ArrayList<>();
        ExecutorService executor = Executors.newFixedThreadPool(10);

        for (int i = 0; i < 10; i++) {
            futures.add(executor.submit(() -> {
                try {
                    return vm.execute(compilation.getBytecode());
                } catch (Exception e) {
                    return ExecutionResult.failure(e);
                }
            }));
        }

        // 等待所有任务完成
        for (Future<ExecutionResult> future : futures) {
            ExecutionResult result = future.get(5, TimeUnit.SECONDS);
            assertThat(result.isSuccess()).isTrue();
            assertThat(result.getReturnValue()).isEqualTo(42);
        }

        executor.shutdown();
    }
}
```

### 测试工具和辅助类

#### 测试数据生成器
```java
public class TestDataGenerator {
    // 生成随机字节码
    public byte[] generateRandomBytecode(int length) {
        Random random = new Random(42); // 固定种子确保可重复
        byte[] bytecode = new byte[length];

        // 只生成有效的指令
        List<Integer> validOpcodes = getValidOpcodes();
        for (int i = 0; i < length; i++) {
            int opcode = validOpcodes.get(random.nextInt(validOpcodes.size()));
            bytecode[i] = (byte) opcode;
        }

        return bytecode;
    }

    // 生成复杂表达式
    public String generateComplexExpression(int depth) {
        if (depth == 0) {
            return String.valueOf(RandomUtils.nextInt(1, 100));
        }

        String[] operators = {"+", "-", "*", "/"};
        String operator = operators[RandomUtils.nextInt(0, operators.length)];

        String left = generateComplexExpression(depth - 1);
        String right = generateComplexExpression(depth - 1);

        return "(" + left + " " + operator + " " + right + ")";
    }

    // 生成测试函数
    public String generateTestFunction(String name, int paramCount) {
        StringBuilder params = new StringBuilder();
        for (int i = 0; i < paramCount; i++) {
            if (i > 0) params.append(", ");
            params.append("int param").append(i);
        }

        return String.format("""
            int %s(%s) {
                int result = 0;
                %s
                return result;
            }
            """, name, params.toString(), generateFunctionBody(paramCount));
    }
}
```

#### 断言工具
```java
public class VMAssertions {
    // 断言执行结果
    public void assertExecutionSuccess(ExecutionResult result) {
        assertThat(result.isSuccess())
            .as("执行应该成功")
            .isTrue();

        if (result.getError() != null) {
            fail("执行失败: " + result.getError());
        }
    }

    // 断言返回值
    public void assertReturnValue(ExecutionResult result, int expected) {
        assertExecutionSuccess(result);
        assertThat(result.getReturnValue())
            .as("返回值应该等于 " + expected)
            .isEqualTo(expected);
    }

    // 断言内存使用
    public void assertMemoryUsage(VMStats stats, long maxExpected) {
        assertThat(stats.getPeakMemoryUsage())
            .as("峰值内存使用应该小于 " + maxExpected)
            .isLessThanOrEqualTo(maxExpected);
    }

    // 断言执行时间
    public void assertExecutionTime(long startTime, long maxExpectedMs) {
        long executionTime = System.nanoTime() - startTime;
        double executionTimeMs = executionTime / 1_000_000.0;

        assertThat(executionTimeMs)
            .as("执行时间应该小于 " + maxExpectedMs + "ms")
            .isLessThan(maxExpectedMs);
    }
}
```

## 测试执行策略

### 持续集成测试
```yaml
# .github/workflows/vm-test.yml
name: VM Tests

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up JDK 21
        uses: actions/setup-java@v2
        with:
          java-version: '21'
      - name: Run unit tests
        run: mvn test -Dtest=*VMTest -DfailIfNoTests=false
      - name: Generate coverage report
        run: mvn jacoco:report
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v2

  integration-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up JDK 21
        uses: actions/setup-java@v2
        with:
          java-version: '21'
      - name: Run integration tests
        run: mvn test -Dtest=*IntegrationTest -DfailIfNoTests=false

  performance-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up JDK 21
        uses: actions/setup-java@v2
        with:
          java-version: '21'
      - name: Run performance tests
        run: mvn test -Dtest=*PerformanceTest -DfailIfNoTests=false
      - name: Upload performance results
        uses: actions/upload-artifact@v2
        with:
          name: performance-results
          path: target/performance-reports/
```

### 测试报告生成
```java
public class TestReportGenerator {
    public void generateTestReport(TestResults results, String outputPath) {
        try (PrintWriter writer = new PrintWriter(outputPath)) {
            writer.println("# VM测试报告");
            writer.println();
            writer.println("## 测试摘要");
            writer.println("- 总测试数: " + results.getTotalTests());
            writer.println("- 通过测试: " + results.getPassedTests());
            writer.println("- 失败测试: " + results.getFailedTests());
            writer.println("- 成功率: " + String.format("%.2f%%", results.getSuccessRate()));
            writer.println();

            writer.println("## 性能基准");
            for (BenchmarkResult benchmark : results.getBenchmarkResults()) {
                writer.println("### " + benchmark.getName());
                writer.println("- 平均执行时间: " + benchmark.getAverageTime() + "ns");
                writer.println("- 最大执行时间: " + benchmark.getMaxTime() + "ns");
                writer.println("- 标准差: " + benchmark.getStdDev() + "ns");
                writer.println();
            }

            writer.println("## 详细结果");
            for (TestResult test : results.getAllTests()) {
                writer.println("### " + test.getName());
                writer.println("- 状态: " + (test.isPassed() ? "通过" : "失败"));
                writer.println("- 执行时间: " + test.getExecutionTime() + "ms");
                if (test.getError() != null) {
                    writer.println("- 错误: " + test.getError());
                }
                writer.println();
            }
        }
    }
}
```

## 实施计划

### 第1周：基础测试框架
- [ ] 实现VMTestBase基类
- [ ] 创建测试工具类
- [ ] 编写虚拟机核心测试
- [ ] 设置持续集成

### 第2周：单元测试完善
- [ ] 字节码解释器测试
- [ ] 栈帧管理测试
- [ ] 垃圾回收测试
- [ ] 性能基准测试

### 第3周：集成测试
- [ ] 完整执行流程测试
- [ ] 组件交互测试
- [ ] 错误处理测试
- [ ] 压力测试

### 第4周：测试优化
- [ ] 测试数据生成器完善
- [ ] 测试报告生成
- [ ] 性能调优
- [ ] 文档完善

## 成功标准

### 测试覆盖率
- [ ] 单元测试覆盖率≥95%
- [ ] 集成测试覆盖所有关键路径
- [ ] 性能测试覆盖所有基准场景
- [ ] 压力测试验证极限情况

### 质量标准
- [ ] 所有测试通过率≥99%
- [ ] 性能基准全部达标
- [ ] 内存泄漏检测通过
- [ ] 并发测试稳定

### 维护性
- [ ] 测试代码可读性强
- [ ] 测试数据生成可重复
- [ ] 测试执行速度快
- [ ] 错误诊断信息清晰

---

*本方案制定时间：2025年12月7日*
*预计实施时间：4周*
*负责人：Claude Code*