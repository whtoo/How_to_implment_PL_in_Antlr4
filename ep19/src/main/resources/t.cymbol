// ep19/src/main/resources/t.cymbol

// --- Native JVM binding (print) ---
print("Starting ep19 tests...");

// --- Basic struct support as record type & struct field type checking ---
struct Point {
    int x;
    float y;
}

Point p1;
p1.x = 10;
p1.y = 20.5;
print("p1.x (10):");
print(p1.x); 
print("p1.y (20.5):");
print(p1.y);

// Type error: float to int (uncomment to test error reporting)
// p1.x = 10.5; 
// Error: field z does not exist (uncomment to test error reporting)
// p1.z = 100;  

// --- Type checking: Basic type compatibility (assignment, operations) ---
int i;
float f;
bool b;
String s; // Assuming String is a predefined type, handled by TypeTable

i = 5;
f = 10.5;
b = true;
s = "hello_cymbol";

print("i (5):");
print(i); 
print("f (10.5):");
print(f); 
print("b (true, prints as 1):");
print(b); 
print("s (hello_cymbol):");
print(s); 

f = i; // OK: int to float
print("f after f=i (5.0):");
print(f); 
// Type error: float to int (uncomment to test error reporting)
// i = f; 

int i2;
i2 = i + 5; // OK: int + int
print("i2 (10):");
print(i2);

float f2;
f2 = i + f; // OK: int + float -> float
print("f2 (i+f = 5.0+5.0=10.0):"); // p1.y was 20.5, f was 5.0 from f=i
print(f2); // Expected: 10.0 (since i=5, f=5.0)

f2 = f2 / 2.0; // OK: float / float (10.0 / 2.0)
print("f2 (f2/2.0 = 5.0):");
print(f2); 
// Type error: float / int -> float, cannot assign to int (uncomment to test)
// i2 = f2 / i; 

b = (i < 10); // OK
print("b (i < 10 is true):");
print(b); 
b = (f >= 10.0); // OK, f is 5.0, so false
print("b (f >= 10.0 is false):");
print(b); 
b = (i == i2); // OK, i=5, i2=10, so false
print("b (i == i2 is false):");
print(b); 
b = !b; // OK, b is false, !b is true
print("b (!b is true):");
print(b); 

// Error: if condition must be bool (uncomment to test)
// if (i) { print("error"); } 
// Error: while condition must be bool (uncomment to test)
// while (0) { print("error_loop"); } 

// --- Typedef support ---
typedef int MyInt;
typedef float MyFloat;
typedef Point MyPoint; // Typedef for a struct

MyInt mi;
mi = 100;
print("mi (100):");
print(mi); 

MyFloat mf;
mf = mi; // OK: MyInt (int) to MyFloat (float)
print("mf after mf=mi (100.0):");
print(mf); 

MyPoint mp1;
mp1.x = 1;
mp1.y = 2.0;
print("mp1.x (1):");
print(mp1.x);

// --- Function parameter type checking & return type checking ---
int add(int a, int b) {
    print("Inside add, a:");
    print(a);
    print("Inside add, b:");
    print(b);
    return a + b;
}

MyInt sum_res;
sum_res = add(mi, 200); // OK
print("sum_res (300):");
print(sum_res); 

// Error: float for int parameter (uncomment to test)
// add(mi, mf); 

void no_return_func() {
    print("Inside void function no_return_func");
    // Error: void function should not return a value (uncomment to test)
    // return 1; 
}

no_return_func();

int requires_return_func() {
    int val;
    val = 10;
    if (val > 5) {
      print("requires_return_func returning 10");
      return val;
    }
    // Error: non-void function must return a value of its type. 
    // If all paths are not covered, this can be an issue.
    // For now, assuming basic check on explicit return.
    print("requires_return_func returning 0 (default path)");
    return 0; 
}
print("Result of requires_return_func (10):");
print(requires_return_func()); 


// --- Struct with methods ---
struct Rectangle {
    int width;
    int height;
    MyPoint topLeft; // Using a typedef'd struct

    int getArea() { // Renamed from area to getArea for clarity
        return width * height;
    }

    void setDimensions(int w, int h) {
        width = w;
        height = h;
    }
    
    MyPoint getTopLeft() {
        return topLeft;
    }

    void setTopLeftPoint(MyPoint p) { // Renamed from setTopLeft
        topLeft.x = p.x;
        topLeft.y = p.y; // Assuming direct assignment is fine for struct fields
                         // If structs are reference types, this copies fields.
                         // If value types, it's a copy. Interpreter handles this.
    }
}

Rectangle r1;
r1.setDimensions(10, 5); // Using method to set dimensions

MyPoint newTopLeft;
newTopLeft.x = 0;
newTopLeft.y = 0.0;
r1.setTopLeftPoint(newTopLeft);

print("r1 area (50):");
print(r1.getArea()); 

MyPoint r1TopLeft;
r1TopLeft = r1.getTopLeft();
print("r1TopLeft.x (0):");
print(r1TopLeft.x); 
print("r1TopLeft.y (0.0):");
print(r1TopLeft.y);

// Error: too many arguments for method getArea (uncomment to test)
// r1.getArea(5); 
// Error: wrong argument type for setDimensions (uncomment to test)
// r1.setDimensions(10, 5.5); 


// --- Test type alias with structs more ---
typedef Rectangle MyRect;
MyRect r2;
r2.setDimensions(3,4);
print("r2 area (12):");
print(r2.getArea()); 

print("Finished ep19 tests.");

print("hello, cymbol!");