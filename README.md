# How to implement PL in ANTLR4

[![Java](https://img.shields.io/badge/java-21+-blue)](https://www.oracle.com/java/technologies/downloads/)
[![ANTLR4](https://img.shields.io/badge/ANTLR4-4.13.2-orange)](https://www.antlr.org/)
[![Maven](https://img.shields.io/badge/maven-3.6+-brightgreen)](https://maven.apache.org/)
[![Build Status](https://img.shields.io/badge/build-passing-brightgreen)](.github/workflows/maven.yml)

## 项目简介

**How to implement PL in ANTLR4** 是一个系统性的编译原理教学项目，通过21个渐进式章节（EP1-EP21），完整展示了如何从零开始构建一个现代编译器。项目基于**ANTLR 4.13.2**和**Java 21+**开发，为编译原理学习者提供了从理论到实践的完整学习路径。项目实现了完整的 **Cymbol 语言编译器**，包含前端、中端、后端和虚拟机执行引擎。

### 项目价值

本项目专门为以下四类用户设计：

- **📚 编译原理学习者**：提供清晰的演进路径和详细说明
- **👥 项目贡献者**：提供完整的架构设计和测试标准  
- **🎓 课程教学**：提供分阶段的教学大纲
- **🔍 代码审查**：提供明确的测试和质量标准

## 学习路径概览

```
第一阶段：基础构建 (EP1-EP10)
├── EP1-EP5：词法语法分析基础
├── EP6-EP10：解释器和AST构建

第二阶段：编译器核心 (EP11-EP20)  
├── EP11-EP15：类型系统和语义分析
├── EP16-EP18：中间表示和虚拟机
└── EP19-EP20：完整编译流程

第三阶段：高级优化 (EP21)
└── EP21：数据流分析和SSA形式
```

## 项目结构

```
How_to_implment_PL_in_Antlr4/
├── ep1-ep10/              # 基础阶段：词法语法分析、AST构建、解释器
├── ep11-ep17/             # 编译器阶段：类型系统、语义分析、符号表、调用图分析
├── ep18/                  # 虚拟机实现：栈式虚拟机、垃圾回收、结构体统一实现
├── ep19/                  # 编译器前端：完整的前端架构（93个测试100%通过）
├── ep20/                  # 编译器完整版：IR、CFG、代码生成
├── ep21/                  # 高级优化：数据流分析、SSA形式
├── docs/                  # 项目整体文档和设计规范（232+文档文件）
├── scripts/               # 构建脚本和开发工具（支持多平台）
└── pom.xml                # Maven多模块配置
```

## 核心特性

### 📚 渐进式学习设计
- **EP1-EP5**：基础词法语法分析，ANTLR4入门
- **EP6-EP10**：AST构建、访问者模式、基础解释器
- **EP11-EP15**：类型系统、符号表、语义分析
- **EP16-EP17**：中间表示、控制流图、调用图分析（最新升级）
- **EP18**：栈式虚拟机、垃圾回收、结构体统一实现（重大升级）
- **EP19-EP20**：完整编译管道和代码生成（100%测试通过）
- **EP21**：高级优化技术：数据流分析、SSA形式

### ✨ 最新技术亮点 (2025年12月)
- **🎯 虚拟机系统升级** - EP18实现50+指令完整支持，引用计数GC，结构体统一实现
- **🧪 GC集成测试套件** - 完整TDD测试先行，包含集成测试和性能基准测试
- **🔧 ANTLR4 4.13.2** - 所有模块升级至最新版本，增强Java兼容性
- **📊 调用图分析** - EP17新增静态分析能力，DOT格式输出
- **✅ 测试稳定性** - EP19达到93个测试100%通过率，GC测试覆盖率≥95%
- **🐛 重大Bug修复** - 解决虚拟机比较操作顺序和循环执行问题
- **⚡ 性能监控** - 集成执行统计和基准测试系统，GC性能基准测试

### 🏗️ 完整编译器架构
- **前端**：词法分析、语法分析、AST构建
- **中端**：符号表、类型检查、语义分析
- **优化**：中间表示生成、控制流分析、数据流分析
- **后端**：代码生成、虚拟机执行

### 🧪 严格测试标准
- **单元测试**：每个模块的详细测试
- **集成测试**：模块间协作验证
- **端到端测试**：完整编译流程验证
- **性能测试**：编译效率和执行性能

### 📊 可视化支持
- **AST可视化**：语法树结构展示
- **控制流图**：CFG图形化输出
- **数据流分析**：活跃变量等分析结果
- **编译过程追踪**：详细的执行日志

## 演进阶段详解

### EP1-EP10：基础构建阶段

#### EP1 - 词法分析器（Lexer）
**目标**：将源代码转换为词法单元流
- 构建基于ANTLR4的词法分析器
- 识别关键字、标识符、字面量、运算符
- 处理注释和空白字符
- **核心实现**：`Hello.g4`

#### EP2 - 语法分析器（Parser）
**目标**：将词法单元流转换为解析树
- 定义语法规则（数组初始化语法）
- 处理语法优先级和结合性
- 错误恢复机制
- **核心实现**：`ArrayInit.g4`

#### EP3 - AST构建（Abstract Syntax Tree）
**目标**：将解析树转换为抽象语法树
- 构建访问者模式实现
- 表达式求值器
- 基本数学运算支持
- **核心实现**：`LibExpr.g4`, `ExprJoyRide.java`

#### EP4 - 访问者模式（Visitor Pattern）
**目标**：实现AST的遍历和处理
- 定义访问者接口
- 实现AST节点的accept方法
- 支持双分派机制
- **核心实现**：所有ASTNode的子类

#### EP5 - 工具构建（Tool Building）
**目标**：实现Java接口提取工具
- Java语法分析器
- 接口提取算法
- 代码重构工具
- **核心实现**：`Java.g4`, `ExtractInterfaceTool.java`

#### EP6 - CSV处理器（CSV Processor）
**目标**：构建CSV文件解析器
- CSV语法定义
- 数据读取和验证
- 格式化输出
- **核心实现**：`CSV.g4`, `CSVReader.java`

#### EP7 - JSON处理器（JSON Processor）
**目标**：构建JSON解析器
- JSON语法标准
- 嵌套数据结构处理
- 验证和格式化
- **核心实现**：`JSON.g4`

#### EP8 - AST节点设计（AST Node Design）
**目标**：设计完整的AST节点体系
- 表达式节点层次结构
- 算术操作节点
- 访问者模式实现
- **核心实现**：`VecMath.g4`系列节点类

### EP11-EP15：编译器核心阶段

#### EP11-EP14：类型系统和符号表
**目标**：实现静态类型检查和作用域管理
- 类型系统设计（int, float, string, bool）
- 符号表数据结构
- 作用域链管理
- 类型兼容性检查

#### EP15 - 错误处理（Error Handling）
**目标**：构建统一的错误报告机制
- 语法错误恢复
- 语义错误报告
- 错误位置和上下文信息
- 错误处理器和异常类

### EP16-EP18：中间表示和虚拟机

#### EP16-EP17：中间表示设计与调用图分析
**EP16 目标**：设计三地址代码中间表示
- IR指令设计（算术、逻辑、控制流）
- 虚拟寄存器分配
- IR指令格式和语义

**EP17 🎉 最新更新**：调用图分析与ANTLR4升级
- **ANTLR4升级**：4.11.0 → 4.13.2，更新所有生成代码
- **调用图分析**：实现CallGraphVisitor，生成DOT格式调用图
- **Java兼容性**：适配新版Java编译要求，添加this-escape警告抑制
- **代码质量提升**：改进导入语句顺序，增强代码可读性

#### EP18 🎉 重大更新：虚拟机系统全面升级
**目标**：实现功能完整的栈式虚拟机和垃圾回收系统

**🏗️ 架构设计**：
```
+---------------------------+
|      虚拟机运行时系统       |
|---------------------------|
|  字节码解释器 (VMInterpreter) |
|  栈帧管理 (StackFrame)    |
|  内存分配 (MemorySpace)    |
|  垃圾回收 (ReferenceCountingGC) |
+---------------------------+
|     统一结构体系统         |
|---------------------------|
|  StructValue (新)         |
|  StructType & StructSymbol|
|  类型安全增强             |
+---------------------------+
|     字节码格式和指令集      |
|  50+ 指令完整支持         |
+---------------------------+
```

**✨ 2025年12月重大更新**：
1. **统一结构体实现** - 引入StructValue替代原有实现，增强类型安全
2. **引用计数垃圾回收** - 实现完整GC系统，包括GCObjectHeader、GCStats
3. **全局变量支持** - 新增.global指令和GLOAD/GSTORE操作
4. **重大Bug修复** - 修复比较操作数顺序，解决循环执行问题
5. **ANTLR4升级** - 升级到4.13.2，更新VMAssembler生成代码
6. **性能监控** - 集成执行统计和性能基准测试

**核心组件**：
- **CymbolStackVM** - 虚拟机主引擎（27KB+，5000+行代码）
- **VMInterpreter** - 字节码解释器（18KB+）
- **ReferenceCountingGC** - 引用计数垃圾回收器
- **StructValue** - 统一结构体运行时表示
- **ByteCodeAssembler** - 字节码汇编器

**GC集成测试套件**：
- **CymbolStackVMGCIntegrationTest** - 完整GC集成测试（15+测试用例）
- **GC性能基准测试** - JMH基准测试测量GC开销和暂停时间
- **内存泄漏检测测试** - 验证GC的内存管理能力
- **TDD测试先行** - 所有功能先有测试，保障实现质量

**完整指令集**：
- **算术指令**：`IADD`, `ISUB`, `IMUL`, `IDIV`, `FADD`, `FSUB`, `FMUL`, `FDIV`
- **比较指令**：`ILT`, `IGT`, `ILE`, `IGE`, `FLT`, `FGT`, `FLE`, `FGE`, `IEQ`, `INEQ`
- **逻辑指令**：`IAND`, `IOR`, `IXOR`, `I2F`, `F2I`
- **控制流**：`IFEQ`, `IFNEQ`, `IFLT`, `GOTO`, `CALL`, `RET`, `HALT`
- **栈操作**：`ICONST`, `FCONST`, `ILOAD`, `FLOAD`, `ISTORE`, `FSTORE`, `POP`, `DUP`
- **数组结构体**：`IALOAD`, `IASTORE`, `NEWARRAY`, `NEWSTRUCT`, `STRUCTGET`, `STRUCTSET`
- **全局变量**：`.global`, `GLOAD`, `GSTORE`
- **异常处理**：除零检查、溢出检测、栈溢出保护

### EP19-EP20：完整编译流程

#### EP19 - 编译器前端（Full Frontend）
**目标**：实现完整的前端编译器
- **Cymbol语言完整支持** - 函数、结构体、数组、布尔字面量
- **类型系统和作用域管理** - 静态类型检查，完整作用域链
- **语义分析和错误处理** - 统一的错误报告机制
- **🎉 测试成就**：93个测试用例100%通过率
  - IntegrationTest: 12/12 ✅
  - FunctionAndMethodTest: 5/5 ✅
  - ErrorRecoveryTest: 8/8 ✅
  - TypeSystemTest: 21/21 ✅
  - StructAndTypedefTest: 22/22 ✅
  - ComprehensiveTest: 19/19 ✅

#### EP20 - 完整编译器（Full Compiler）
**目标**：整合所有组件，构建完整编译流程

**编译流程架构**：
```
╔════════════════════════════════════════════════════════════╗
║                  编译器前端（Frontend）                      ║
╠════════════════════════════════════════════════════════════╣
║  1. 词法分析 → 2. 语法分析 → 3. AST构建 → 4. 语义分析        ║
║     (Lexer)       (Parser)      (AST)      (TypeChecker)   ║
╚════════════════════════════════════════════════════════════╝
                              ↓
╔════════════════════════════════════════════════════════════╗
║                  编译器中端（Middle）                       ║
╠════════════════════════════════════════════════════════════╣
║  5. IR生成 → 6. CFG构建 → 7. 优化（跳转+死代码）              ║
║    (IRBuilder)  (CFGBuilder)   (Optimizer)                 ║
╚════════════════════════════════════════════════════════════╝
                              ↓
╔════════════════════════════════════════════════════════════╗
║                  编译器后端（Backend）                       ║
╠════════════════════════════════════════════════════════════╣
║  8. 代码生成 → 9. 虚拟机执行                                 ║
║   (Assembler)   (StackVM)                                   ║
╚════════════════════════════════════════════════════════════╝
```

**核心模块**：
- **Compiler.java**：主驱动程序
- **CymbolASTBuilder**：AST构建器
- **CymbolIRBuilder**：IR生成器
- **ControlFlowAnalysis**：控制流分析
- **CymbolAssembler**：代码生成器

### EP21 - 高级优化（Advanced Optimization）
**目标**：实现现代编译器优化技术
**架构设计**：
```
+-----------------------+
|   编译器前端（共享）    |
|-----------------------|
|   AST构建 + 符号表     |
|   类型检查 + IR生成    |
+-----------------------+
|   优化框架（共享）     |
|-----------------------|
|   运行时编译器          |
|   • 字节码生成         |
|   • 模板编译           |
|   • 元编程支持         |
+-----------------------+
|   运行时执行引擎       |
|   • 动态加载           |
|   • 性能监控           |
|   • 优化决策           |
+-----------------------+
```

**技术特性**：
- **分层IR架构**：MIR/LIR分层中间表示体系
- **数据流分析框架**：活跃变量分析、前向/后向分析
- **SSA形式**：Φ函数自动生成和SSA图构建
- **增强可视化**：Mermaid和DOT格式的CFG可视化

## 四大使用场景详解

### 1. 📚 编译原理学习者
**学习目标**：理解编译器的完整工作原理

**学习路径**：
```
阶段1：基础认知（第1-4周）
├── EP1-EP2：理解词法和语法分析概念
├── EP3-EP4：掌握AST构建和访问者模式
└── EP5-EP8：实践简单的语言处理器

阶段2：核心理解（第5-10周）
├── EP11-EP14：学习类型系统和符号表
├── EP15：掌握错误处理机制
├── EP16-EP18：理解中间表示和虚拟机
└── EP19-EP20：整合完整的编译流程

阶段3：高级应用（第11-16周）
└── EP21：掌握现代优化技术
```

**学习成果**：
- 掌握ANTLR4的使用和语法定义
- 理解编译器的各个阶段及其作用
- 具备独立实现简单语言的能力
- 理解现代编译器优化技术

### 2. 👥 项目贡献者
**贡献目标**：为项目贡献高质量代码

**贡献流程**：
```
1. Fork项目 → 2. 创建分支 → 3. 编写测试 → 4. 实现功能 → 5. 提交PR
```

**代码质量标准**：

**编码规范（100%强制）**：
- 遵循Google Java Style Guide
- 使用CheckStyle进行代码格式检查
- SpotBugs静态代码分析无严重问题
- 完整的Javadoc注释

**测试要求（必须）**：
- 每个新功能必须包含对应的测试用例
- 测试命名遵循规范：`test[功能]_[场景]_[预期]`
- 单元测试覆盖率保持≥80%
- 关键算法测试覆盖率≥95%

**架构一致性**：
- 遵循项目的模块化设计
- 不破坏现有的公共接口
- 新增模块要与现有架构兼容

### 3. 🎓 课程教学
**教学目标**：为编译原理课程提供完整的实践平台

**分阶段教学大纲**：

**第1-4周：编译基础**
```
周1：ANTLR4入门和词法分析
├── 理论：编译原理概述，词法分析概念
├── 实践：EP1词法分析器实现
├── 作业：自定义一个简单语言的词法分析器

周2：语法分析和AST构建
├── 理论：LL(k)文法，自顶向下分析
├── 实践：EP2语法分析器和EP3 AST构建
├── 作业：实现一个小型计算器的语法分析

周3：访问者模式和解释器
├── 理论：访问者设计模式，解释器模式
├── 实践：EP4访问者模式实现
├── 作业：基于AST构建一个简单解释器

周4：工具构建和实际应用
├── 理论：代码分析工具的设计
├── 实践：EP5-EP8工具类实现
├── 作业：设计一个配置解析器
```

**第5-8周：编译器核心**
```
周5-6：类型系统和符号表
├── 理论：类型系统设计，作用域管理
├── 实践：EP11-EP14类型系统实现
├── 作业：为自定义语言添加类型检查

周7：错误处理和语义分析
├── 理论：语义分析，错误恢复策略
├── 实践：EP15错误处理机制
├── 作业：设计错误报告和恢复机制

周8：中间表示和虚拟机基础
├── 理论：三地址码，虚拟机设计
├── 实践：EP16-EP18 IR和虚拟机
├── 作业：实现一个简单虚拟机的指令集
```

**第9-12周：完整编译流程**
```
周9-10：控制流图和优化
├── 理论：控制流分析，基本块划分
├── 实践：EP19控制流分析实现
├── 作业：实现一个简单的数据流分析

周11-12：代码生成和集成
├── 理论：代码生成，寄存器分配
├── 实践：EP20完整编译器集成
├── 作业：优化一个实际的编译流程
```

**第13-16周：高级优化**
```
周13-14：现代优化技术
├── 理论：数据流分析，SSA形式
├── 实践：EP21高级优化实现
├── 作业：实现一个优化Pass

周15-16：项目实践和展示
├── 项目：实现一个完整的语言编译器
├── 展示：编译器架构和优化技术分享
└── 评估：功能正确性和性能对比
```

### 4. 🔍 代码审查
**审查目标**：确保代码质量和项目一致性

**审查流程**：
```
1. 提交代码 → 2. 自动检查 → 3. 人工审查 → 4. 反馈修改 → 5. 最终合并
```

**审查标准**：

**功能正确性（权重：30%）**
- [ ] 实现符合需求规格
- [ ] 边界条件处理正确
- [ ] 错误处理机制完善
- [ ] 性能影响可接受

**代码质量（权重：25%）**
- [ ] 代码风格符合规范
- [ ] 函数和类的复杂度适中
- [ ] 命名清晰有意义
- [ ] 注释充分且准确

**测试覆盖（权重：25%）**
- [ ] 单元测试完整性≥80%
- [ ] 关键路径100%覆盖
- [ ] 集成测试验证通过
- [ ] 性能测试达标

**文档维护（权重：20%）**
- [ ] Javadoc注释完整
- [ ] 设计文档及时更新
- [ ] 示例代码正确
- [ ] README保持最新

**审查清单**：

**代码质量检查**：
```bash
# 代码格式检查
mvn checkstyle:check

# 静态代码分析
mvn spotbugs:check

# 测试覆盖率
mvn jacoco:report
```

**架构一致性检查**：
- 新增代码是否遵循现有架构模式
- 是否引入了不必要的依赖
- 是否破坏了向后兼容性
- 模块间耦合度是否合理

## 快速开始

### 环境要求
- **Java 21** 或更高版本
- **Maven 3.6** 或更高版本
- **Git**

### 基础学习路径

**推荐顺序**：
1. **初学者**：从EP1开始，逐步学习每个阶段
2. **有经验者**：从EP12开始，重点学习编译器核心
3. **高级用户**：直接跳到EP20-EP21，学习高级特性

**基础示例**：
```bash
# 1. 克隆项目
git clone https://github.com/your-org/How_to_implement_PL_in_Antlr4.git
cd How_to_implement_PL_in_Antlr4

# 2. 编译整个项目
mvn clean compile

# 3. 运行测试（验证安装）
mvn test

# 4. 从EP1开始学习
cd ep1
mvn exec:java -Dexec.mainClass="org.teachfx.antlr4.Hello"
```

### 第一个程序示例

创建一个简单的Cymbol程序：
```cymbol
// 简单计算程序
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(5, 3);
    print("5 + 3 = ");
    print(result);
    return result;
}
```

编译和运行：
```bash
# 进入学习阶段（推荐EP20）
cd ep20
mvn compile

# 编译程序
mvn exec:java -Dexec.mainClass="org.teachfx.antlr4.ep20.Compiler" -Dexec.args="program.cymbol"

# 运行生成的字节码
mvn exec:java -Dexec.mainClass="org.teachfx.antlr4.ep18.VMRunner" -Dexec.args="program.vm"
```

## 开发指南

### 项目构建命令

```bash
# 清理项目
mvn clean

# 编译项目（包含ANTLR代码生成）
mvn compile

# 运行测试
mvn test

# 生成测试覆盖率报告
mvn jacoco:report

# 代码质量检查
mvn checkstyle:check spotbugs:check

# 打包特定模块
mvn package -pl ep20 -am
```

### 调试技巧

**启用详细日志**：
```bash
# 使用log4j2配置
mvn exec:java -Dlog4j.configurationFile=src/main/resources/log4j2.xml

# 调试特定阶段
mvn exec:java -Dexec.args="--debug-ast program.cymbol"
```

**可视化输出**：
```bash
# AST可视化
mvn exec:java -Dexec.args="--visualize-ast program.cymbol"

# CFG可视化
mvn exec:java -Dexec.args="--visualize-cfg program.cymbol"

# 生成Mermaid图表
mvn exec:java -Dexec.args="--mermaid-output program.cymbol"
```

## 测试标准

### 测试架构

```
         集成测试
            ^
            |
      编译器管道测试
            ^
            |
       组件测试
            ^
            |
        单元测试  (基础)
```

### 测试覆盖率要求

- **整体覆盖率**：≥ 85%
- **核心模块**（IR、CFG、优化器）：≥ 90%
- **新功能模块**：100%

### 测试执行

```bash
# 运行所有测试
mvn test

# 运行特定模块测试
mvn test -pl ep21

# 生成覆盖率报告
mvn jacoco:report
open target/site/jacoco/index.html
```

## 文档资源

### 项目级文档
- [项目总体介绍](docs/README.md)
- [测试策略和最佳实践](docs/测试策略.md)
- [设计要素和架构](docs/设计要素.md)
- [与传统编译过程对比](docs/与传统编译过程的对比.md)

### 各阶段文档
- **EP20**：[完整编译器实现](ep20/)
- **EP21**：[高级优化技术](ep21/docs/)

## 发展路线图

### 🚀 实现深度提升计划与最新进展

本项目已实现重大突破，正在从教育性实现向**接近工业级编译器**的目标迈进。

#### 🎉 2025年12月重大进展

**已完成的重大改进**：

1. **EP17 - ANTLR4升级与调用图分析** ✅
   - 成功升级至 ANTLR 4.13.2
   - 实现调用图分析和 DOT 格式输出
   - 增强 Java 兼容性

2. **EP18 - 虚拟机系统全面升级** ✅
   - **统一结构体实现** - StructValue 类型安全增强
   - **引用计数垃圾回收** - 完整 GC 系统（GCObjectHeader、GCStats）
   - **全局变量支持** - .global 指令和 GLOAD/GSTORE
   - **重大Bug修复** - 比较操作顺序，循环执行问题
   - **50+ 指令完整支持** - 算术、比较、逻辑、控制流、异常处理
   - **性能监控** - 集成执行统计和基准测试

3. **EP19 - 编译器前端稳定化** ✅
   - **93个测试100%通过** - 完整测试覆盖
   - **函数调用系统修复** - 解决空指针和作用域问题
   - **结构体方法调用** - 完整语法和实现
   - **类型系统完善** - 布尔字面量、逻辑运算符支持

#### 核心规划文档

1. **[实现深度提升计划](docs/实现深度提升计划.md)**
   - 详细的三年发展规划
   - 技术路线图和里程碑
   - 风险评估与应对策略
   - 成功标准和验收条件

2. **[季度实施计划](docs/季度实施计划.md)**
   - 分解为12个月的具体任务
   - 每个季度的明确目标和交付物
   - 团队资源分配和协作策略
   - 详细的风险管理和进度监控

3. **[技术实现细节](docs/技术实现细节.md)**
   - 虚拟机、SSA优化、指针支持的代码实现方案
   - JIT编译器和调试器的详细设计
   - 语法扩展和类型系统的具体实现
   - 性能监控和工具链构建的技术方案

#### 📊 当前状态分析

**✅ 已完成的核心功能**
- **完整前端实现** - 词法、语法、AST、符号表、类型检查（EP19: 100%测试通过）
- **虚拟机系统** - 栈式VM、垃圾回收、结构体支持、异常处理（EP18全面升级）
- **调用图分析** - DOT格式输出，静态分析基础（EP17新增）
- **ANTLR4 4.13.2** - 最新版本升级和代码生成
- **完整测试体系** - 单元测试、集成测试、性能基准

**🎯 2026年提升目标**

1. **JIT编译器实现**（Q1重点）
   - 基于虚拟机的即时编译
   - 热代码优化
   - 性能提升目标：>100%

2. **高级优化框架**（Q1-Q2重点）
   - 常量传播和死代码消除
   - 完善SSA形式和基于SSA的优化
   - 数据流分析框架完整实现

3. **语言特性扩展**（Q2-Q3重点）
   - 指针和引用支持
   - 泛型类型系统
   - 并发编程特性

4. **工具链完善**（Q3-Q4重点）
   - 源代码级调试器
   - 性能分析器
   - IDE集成支持

**📈 预期成果**
- 性能提升**100%以上**（JIT编译器）
- 测试覆盖率保持**85%+**
- 实现**工业级编译器**的功能深度
- 建立**活跃的开源社区生态**

### 发展时间线

```
2025年Q4：重大升级完成 ✅
├── EP17: ANTLR4升级 + 调用图分析
├── EP18: 虚拟机系统全面升级（GC、结构体、指令集）
└── EP19: 编译器前端稳定化（100%测试通过）

2026年Q1：JIT编译器期
├── 实现基于虚拟机的JIT编译器
├── 完善SSA优化框架
└── 性能提升目标：>100%

2026年Q2：高级优化期
├── 实现常量传播和死代码消除
├── 完善数据流分析框架
└── 添加指针和引用支持

2026年Q3：特性扩展期
├── 实现泛型类型系统
├── 开发源代码级调试器
└── 添加性能分析器

2026年Q4：生态系统期
├── 实现并发编程特性
├── 构建完整工具链
└── IDE集成支持
```

### 参与发展计划

如果您对编译技术充满热情，欢迎参与本项目的发展：

- **技术贡献**：参与虚拟机、优化器等核心模块开发
- **工具开发**：帮助构建调试器、性能分析器等工具
- **文档完善**：改进技术文档和教程材料
- **测试支持**：增加测试用例和性能基准

查看[贡献指南](#贡献指南)了解如何参与项目发展。

## 贡献指南

我们欢迎各种形式的贡献！

### 贡献类型
- 🐛 **Bug修复**：修复现有功能的问题
- ✨ **新功能**：添加新的语言特性或优化
- 📚 **文档**：改进文档和教程
- 🧪 **测试**：增加测试用例或改进测试质量

### 贡献流程
1. Fork项目
2. 创建特性分支 (`git checkout -b feature/AmazingFeature`)
3. 编写测试用例（TDD要求）
4. 实现功能代码
5. 确保所有测试通过 (`mvn test`)
6. 更新相关文档
7. 提交Pull Request

### 贡献要求
- 遵循项目的编码规范
- 新功能必须包含完整的测试用例
- 保持或提高代码覆盖率
- 更新相关文档和示例
- 确保通过所有CI检查

## 许可证

本项目采用BSD 3-Clause许可证，详见[LICENSE](LICENSE)文件。

## 联系方式

如有问题或建议：
- 提交GitHub Issue
- 查看[项目Wiki](https://github.com/whtoo/How_to_implment_PL_in_Antlr4/wiki)
- 参与[讨论](https://github.com/whtoo/How_to_implment_PL_in_Antlr4/discussions)

## 致谢

感谢所有为这个项目做出贡献的开发者和研究人员：
- ANTLR4团队提供的强大解析工具
- 编译原理领域的先驱研究者们
- 所有参与测试和反馈的用户
- 开源社区的支持和建议

---

**最后更新**：2025-12-13
**项目状态**：活跃开发中
**当前版本**：v1.1 (EP1-EP21完整版)
**最新更新**：
- ✅ EP17: ANTLR 4.13.2 升级 + 调用图分析
- ✅ EP18: 虚拟机系统全面升级（GC、结构体、全局变量、50+指令）
- ✅ EP19: 编译器前端稳定化（93测试100%通过）
- 🎯 下一版本：v1.2 (JIT编译器 + 高级优化)