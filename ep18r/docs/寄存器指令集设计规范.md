# 寄存器指令集设计规范

## 概述
本文档详细定义了 ep18r 寄存器虚拟机的指令集规范，包括指令编码格式、操作语义、指令格式分类和指令集特性。ep18r 采用 32 位固定长度指令，支持 R、I、J 三种格式，是专为寄存器架构设计的独立虚拟机。

## 设计目标
1. **指令集完备性**：支持 Cymbol 语言的所有运算和控制流
2. **编码规范性**：统一、规范的指令编码格式
3. **扩展性**：预留操作码空间，支持未来指令扩展
4. **可解码性**：指令格式简单，易于解码和执行
5. **寄存器优化**：充分利用寄存器架构，减少内存访问

## 寄存器架构
### 寄存器定义
ep18r 使用 16 个通用寄存器 (r0-r15)：

| 寄存器 | 名称 | 用途 | 备注 |
|--------|------|------|------|
| r0 | 零寄存器 | 恒为 0 | 读取始终返回 0，写入无效 |
| r1-r12 | 通用寄存器 | 通用目的 | 用于计算、临时值、局部变量 |
| r13 | SP (栈指针) | 指向栈顶 | 用于栈操作和函数调用 |
| r14 | FP (帧指针) | 指向当前栈帧 | 用于局部变量访问 |
| r15 | LR (链接寄存器) | 存储返回地址 | 用于函数调用返回 |

### 寄存器文件特性
- **位宽**：32 位整数/浮点统一寄存器
- **数量**：16 个物理寄存器
- **寻址**：5 位寄存器编号（0-15）
- **特殊寄存器**：r0 硬连线到 0，r13-r15 有特殊用途

## 指令格式
所有指令均为 32 位固定长度，支持三种格式：

### 1. R 类型（寄存器-寄存器运算）
```
 31        26 25     21 20     16 15     11 10         0
┌────────────┬─────────┬─────────┬─────────┬─────────────┐
│   opcode   │    rd   │   rs1   │   rs2   │   unused    │
│    (6)     │   (5)   │   (5)   │   (5)   │    (11)     │
└────────────┴─────────┴─────────┴─────────┴─────────────┘
```
- **用途**：算术运算、逻辑运算、比较运算
- **示例**：`add r3, r1, r2` (r3 = r1 + r2)
- **操作数**：三个寄存器操作数 (rd, rs1, rs2)

### 2. I 类型（立即数/内存访问）
```
 31        26 25     21 20     16 15                    0
┌────────────┬─────────┬─────────┬───────────────────────┐
│   opcode   │    rd   │   rs1   │      immediate        │
│    (6)     │   (5)   │   (5)   │         (16)          │
└────────────┴─────────┴─────────┴───────────────────────┘
```
- **用途**：立即数加载、内存访问、条件跳转
- **示例**：`li r1, 100` (r1 = 100), `lw r2, r14, 8` (r2 = memory[FP+8])
- **操作数**：两个寄存器 + 16 位有符号立即数

### 3. J 类型（跳转指令）
```
 31        26 25                                         0
┌────────────┬───────────────────────────────────────────┐
│   opcode   │               address                     │
│    (6)     │                  (26)                     │
└────────────┴───────────────────────────────────────────┘
```
- **用途**：无条件跳转、函数返回
- **示例**：`j 0x1000` (跳转到地址 0x1000), `ret` (从 LR 返回)
- **操作数**：26 位有符号地址偏移（相对于 PC）

## 指令集详细定义
### 操作码分配表
| 操作码 | 指令 | 格式 | 操作数类型 | 语义描述 |
|--------|------|------|------------|----------|
| 1 | add | R | rd, rs1, rs2 | 整数加法：rd = rs1 + rs2 |
| 2 | sub | R | rd, rs1, rs2 | 整数减法：rd = rs1 - rs2 |
| 3 | mul | R | rd, rs1, rs2 | 整数乘法：rd = rs1 * rs2 |
| 4 | div | R | rd, rs1, rs2 | 整数除法：rd = rs1 / rs2 |
| 5 | slt | R | rd, rs1, rs2 | 小于设置：rd = (rs1 < rs2) ? 1 : 0 |
| 6 | sle | R | rd, rs1, rs2 | 小于等于设置：rd = (rs1 ≤ rs2) ? 1 : 0 |
| 7 | sgt | R | rd, rs1, rs2 | 大于设置：rd = (rs1 > rs2) ? 1 : 0 |
| 8 | sge | R | rd, rs1, rs2 | 大于等于设置：rd = (rs1 ≥ rs2) ? 1 : 0 |
| 9 | seq | R | rd, rs1, rs2 | 等于设置：rd = (rs1 == rs2) ? 1 : 0 |
| 10 | sne | R | rd, rs1, rs2 | 不等于设置：rd = (rs1 != rs2) ? 1 : 0 |
| 11 | neg | R | rd, rs1 | 整数取负：rd = -rs1 |
| 12 | not | R | rd, rs1 | 按位取反：rd = ~rs1 |
| 13 | and | R | rd, rs1, rs2 | 按位与：rd = rs1 & rs2 |
| 14 | or | R | rd, rs1, rs2 | 按位或：rd = rs1 \| rs2 |
| 15 | xor | R | rd, rs1, rs2 | 按位异或：rd = rs1 ^ rs2 |
| 16 | fadd | R | rd, rs1, rs2 | 浮点加法：rd = rs1 + rs2 |
| 17 | fsub | R | rd, rs1, rs2 | 浮点减法：rd = rs1 - rs2 |
| 18 | fmul | R | rd, rs1, rs2 | 浮点乘法：rd = rs1 * rs2 |
| 19 | fdiv | R | rd, rs1, rs2 | 浮点除法：rd = rs1 / rs2 |
| 20 | flt | R | rd, rs1, rs2 | 浮点小于：rd = (rs1 < rs2) ? 1 : 0 |
| 21 | feq | R | rd, rs1, rs2 | 浮点等于：rd = (rs1 == rs2) ? 1 : 0 |
| 22 | itof | R | rd, rs1 | 整数转浮点：rd = (float)rs1 |
| 23 | call | I | rd, immediate | 函数调用：LR = PC+4; PC = target |
| 24 | ret | J | - | 函数返回：PC = LR |
| 25 | j | J | immediate | 无条件跳转：PC = target |
| 26 | jt | I | rs1, immediate | 条件为真跳转：if (rs1 != 0) PC = target |
| 27 | jf | I | rs1, immediate | 条件为假跳转：if (rs1 == 0) PC = target |
| 28 | li | I | rd, immediate | 加载整数立即数：rd = immediate |
| 29 | lc | I | rd, immediate | 加载字符立即数：rd = immediate |
| 30 | lf | I | rd, pool_index | 加载浮点常量：rd = pool[pool_index] |
| 31 | ls | I | rd, pool_index | 加载字符串常量：rd = pool[pool_index] |
| 32 | lw | I | rd, base, offset | 加载字：rd = memory[base + offset] |
| 33 | sw | I | rs, base, offset | 存储字：memory[base + offset] = rs |
| 34 | lw_g | I | rd, offset | 全局加载：rd = memory[GBASE + offset] |
| 35 | sw_g | I | rs, offset | 全局存储：memory[GBASE + offset] = rs |
| 36 | lw_f | I | rd, offset | 字段加载：rd = memory[obj_ptr + offset] |
| 37 | sw_f | I | rs, offset | 字段存储：memory[obj_ptr + offset] = rs |
| 38 | print | I | rs | 打印寄存器值：print(rs) |
| 39 | struct | I | rd, size | 分配结构体：rd = allocate_struct(size) |
| 40 | null | I | rd | 加载空指针：rd = NULL |
| 41 | mov | R | rd, rs1 | 寄存器移动：rd = rs1 |
| 42 | halt | J | - | 停止执行 |

### 指令编码示例
#### R 类型示例：add r3, r1, r2
```
操作码 = 1 (add)
rd = 3 (r3)
rs1 = 1 (r1)
rs2 = 2 (r2)

二进制编码：
000001 | 00011 | 00001 | 00010 | 00000000000
十六进制：0x01820800
```

#### I 类型示例：li r1, 100
```
操作码 = 28 (li)
rd = 1 (r1)
rs1 = 0 (未使用)
immediate = 100 (0x0064)

二进制编码：
011100 | 00001 | 00000 | 0000000001100100
十六进制：0x7040064
```

#### J 类型示例：j 0x1000
```
操作码 = 25 (j)
address = 0x1000 (4096)

二进制编码：
011001 | 0000000000000000010000000000
十六进制：0x64004000
```

## 指令流水线设计
### 四阶段流水线
1. **取指 (Fetch)**：从指令内存读取 32 位指令
2. **解码 (Decode)**：解析操作码和操作数，读取寄存器文件
3. **执行 (Execute)**：执行运算或内存访问
4. **写回 (Writeback)**：将结果写回寄存器文件

### 流水线冒险处理
- **数据冒险**：通过寄存器转发（forwarding）解决
- **控制冒险**：通过分支预测（总是预测不跳转）解决
- **结构冒险**：分离指令内存和数据内存

## 指令集特性分析
### 正交性
- 所有算术指令支持相同的寄存器寻址模式
- 内存访问指令统一的基址+偏移量模式
- 控制流指令统一的立即数目标地址

### 完备性
- 支持 Cymbol 语言的所有数据类型（int, float, char, string, struct）
- 支持所有控制结构（顺序、分支、循环、函数调用）
- 支持内存操作（局部、全局、字段访问）

### 编码效率
- 32 位固定长度，解码简单
- 操作码 6 位，支持最多 64 条指令（当前 42 条）
- 寄存器编号 5 位，支持最多 32 个寄存器（当前 16 个）

## 与栈式指令的映射
### 映射原则
1. 栈式指令的隐式操作数（栈顶）转换为显式寄存器操作数
2. 栈式指令的操作数栈操作转换为寄存器移动指令
3. 保持相同的执行语义和顺序

### 示例映射
| 栈式指令 | 寄存器指令序列 | 说明 |
|----------|----------------|------|
| `iconst 10` | `li r1, 10` | 加载立即数到寄存器 |
| `iadd` | `add r3, r1, r2` | 弹出 r1, r2，结果存入 r3 |
| `load 8` | `lw r1, r14, 8` | 从 FP+8 加载到 r1 |
| `call foo` | `call foo` | 调用函数，返回地址存入 LR |

## 扩展性设计
### 预留操作码空间
- 操作码 43-63：保留给未来扩展
- 可用于向量指令、原子操作、协程支持等

### 指令格式扩展
- 当前格式支持最多 3 个操作数
- 未来可扩展 M 类型（多寄存器操作）或 S 类型（向量操作）

## 实现注意事项
### 指令解码
- 操作码在 bits[31:26]
- 寄存器编号在 bits[25:21], bits[20:16], bits[15:11]
- 立即数符号扩展：16 位立即数符号扩展到 32 位

### 特殊指令处理
- `halt` 指令停止执行循环
- `call` 指令需要保存返回地址到 LR
- `ret` 指令从 LR 恢复 PC
- `struct` 指令需要调用内存分配器

### 错误检测
- 无效操作码检测
- 寄存器编号越界检测
- 内存访问越界检测
- 除零检测

## 测试验证
### 指令编码测试
- 验证每条指令的编码和解码
- 验证立即数符号扩展
- 验证寄存器编号映射

### 语义测试
- 每条指令的单独功能测试
- 指令序列的集成测试
- 与栈式虚拟机的等价性测试

## 附录
### A. 操作码数值表
见 RegisterBytecodeDefinition.java 中的常量定义。

### B. 指令格式常量
- FORMAT_R = 0
- FORMAT_I = 1
- FORMAT_J = 2

### C. 相关文件
- `RegisterBytecodeDefinition.java`：指令定义实现
- `RegisterVMInterpreter.java`：指令执行实现
- `VM_Design.md`：高层设计文档