# Cymbol编译器技术实现细节

## 概述

本文档详细描述Cymbol编译器实现深度提升的具体技术方案，包括代码修改、算法实现和架构调整。

## 1. 虚拟机实现方案

### 1.1 CymbolStackVM核心实现

#### 类结构设计
```java
// 位置：ep18/src/main/java/org/teachfx/antlr4/ep18/stackvm/CymbolStackVM.java
public class CymbolStackVM {
    // 执行状态
    private int pc;                    // 程序计数器
    private int[] code;                // 字节码数组
    private int[] globals;             // 全局变量
    private StackFrame currentFrame;   // 当前栈帧
    private Stack<StackFrame> callStack; // 调用栈

    // 内存管理
    private MemoryManager memoryManager;
    private GarbageCollector gc;

    // 执行引擎
    public int execute(int[] bytecode) {
        this.code = bytecode;
        this.pc = 0;

        while (pc < code.length) {
            int opcode = code[pc++];
            switch (opcode) {
                case BytecodeDefinition.IADD:
                    executeIAdd();
                    break;
                case BytecodeDefinition.ISUB:
                    executeISub();
                    break;
                // ... 其他指令
                case BytecodeDefinition.HALT:
                    return pop();
                default:
                    throw new VMError("Unknown opcode: " + opcode);
            }
        }
        return 0;
    }

    private void executeIAdd() {
        int b = pop();
        int a = pop();
        push(a + b);
    }

    // 栈操作
    private void push(int value) {
        currentFrame.operandStack.push(value);
    }

    private int pop() {
        return currentFrame.operandStack.pop();
    }
}
```

#### 栈帧管理实现
```java
// 位置：ep18/src/main/java/org/teachfx/antlr4/ep18/stackvm/StackFrame.java
public class StackFrame {
    // 操作数栈
    private Stack<Integer> operandStack;

    // 局部变量
    private int[] locals;

    // 返回信息
    private int returnAddress;
    private int returnValue;

    // 结构体内存
    private StructSpace structSpace;

    public StackFrame(int localCount, int maxStack) {
        this.locals = new int[localCount];
        this.operandStack = new Stack<>();
        this.structSpace = new StructSpace();
    }

    public int getLocal(int index) {
        if (index < 0 || index >= locals.length) {
            throw new VMError("Local variable index out of bounds: " + index);
        }
        return locals[index];
    }

    public void setLocal(int index, int value) {
        if (index < 0 || index >= locals.length) {
            throw new VMError("Local variable index out of bounds: " + index);
        }
        locals[index] = value;
    }
}
```

### 1.2 垃圾回收实现

#### 引用计数GC
```java
// 位置：ep18/src/main/java/org/teachfx/antlr4/ep18/stackvm/ReferenceCountingGC.java
public class ReferenceCountingGC implements GarbageCollector {
    private Map<Integer, RefCountedObject> objects;
    private int nextObjectId;

    private static class RefCountedObject {
        int refCount;
        Object data;
        List<Integer> references;
    }

    public int allocate(Object data) {
        int id = nextObjectId++;
        RefCountedObject obj = new RefCountedObject();
        obj.data = data;
        obj.refCount = 1;
        obj.references = new ArrayList<>();
        objects.put(id, obj);
        return id;
    }

    public void incrementRef(int objectId) {
        RefCountedObject obj = objects.get(objectId);
        if (obj != null) {
            obj.refCount++;
        }
    }

    public void decrementRef(int objectId) {
        RefCountedObject obj = objects.get(objectId);
        if (obj != null) {
            obj.refCount--;
            if (obj.refCount == 0) {
                // 递归释放引用对象
                for (int refId : obj.references) {
                    decrementRef(refId);
                }
                objects.remove(objectId);
            }
        }
    }
}
```

## 2. 优化器实现方案

### 2.1 常量传播算法

#### 数据流分析框架
```java
// 位置：ep21/src/main/java/org/teachfx/antlr4/ep21/analysis/dataflow/ConstantPropagation.java
public class ConstantPropagation extends DataFlowAnalysis<Map<String, ConstantValue>> {

    @Override
    protected Map<String, ConstantValue> transfer(
        BasicBlock block,
        Map<String, ConstantValue> inState
    ) {
        Map<String, ConstantValue> outState = new HashMap<>(inState);

        for (Instruction instr : block.getInstructions()) {
            if (instr instanceof AssignInstruction assign) {
                String var = assign.getTarget();
                ConstantValue value = evaluateConstant(assign.getExpression(), outState);
                outState.put(var, value);
            } else if (instr instanceof CallInstruction call) {
                // 函数调用可能修改变量
                for (String modifiedVar : getModifiedVars(call)) {
                    outState.remove(modifiedVar);
                }
            }
        }

        return outState;
    }

    private ConstantValue evaluateConstant(Expression expr, Map<String, ConstantValue> state) {
        if (expr instanceof LiteralExpression literal) {
            return new ConstantValue(literal.getValue());
        } else if (expr instanceof VariableExpression varExpr) {
            return state.get(varExpr.getName());
        } else if (expr instanceof BinaryExpression binary) {
            ConstantValue left = evaluateConstant(binary.getLeft(), state);
            ConstantValue right = evaluateConstant(binary.getRight(), state);
            if (left != null && right != null) {
                return computeBinaryOp(left, right, binary.getOperator());
            }
        }
        return null; // 非常量
    }
}
```

#### 常量折叠优化
```java
// 位置：ep21/src/main/java/org/teachfx/antlr4/ep21/pass/optimization/ConstantFolding.java
public class ConstantFolding implements OptimizationPass {

    @Override
    public void optimize(ControlFlowGraph cfg) {
        for (BasicBlock block : cfg.getBlocks()) {
            List<Instruction> newInstructions = new ArrayList<>();

            for (Instruction instr : block.getInstructions()) {
                Instruction optimized = foldConstants(instr);
                newInstructions.add(optimized);
            }

            block.setInstructions(newInstructions);
        }
    }

    private Instruction foldConstants(Instruction instr) {
        if (instr instanceof AssignInstruction assign) {
            Expression folded = foldExpression(assign.getExpression());
            if (folded instanceof LiteralExpression) {
                // 如果表达式折叠为字面量，替换为常量赋值
                return new ConstantAssignInstruction(
                    assign.getTarget(),
                    ((LiteralExpression) folded).getValue()
                );
            }
            return new AssignInstruction(assign.getTarget(), folded);
        }
        return instr;
    }

    private Expression foldExpression(Expression expr) {
        if (expr instanceof BinaryExpression binary) {
            Expression left = foldExpression(binary.getLeft());
            Expression right = foldExpression(binary.getRight());

            if (left instanceof LiteralExpression && right instanceof LiteralExpression) {
                Object leftVal = ((LiteralExpression) left).getValue();
                Object rightVal = ((LiteralExpression) right).getValue();
                Object result = computeBinaryOperation(leftVal, rightVal, binary.getOperator());
                return new LiteralExpression(result);
            }
            return new BinaryExpression(left, right, binary.getOperator());
        }
        return expr;
    }
}
```

### 2.2 SSA形式实现

#### Φ函数插入算法
```java
// 位置：ep21/src/main/java/org/teachfx/antlr4/ep21/analysis/ssa/PhiInsertion.java
public class PhiInsertion {

    public void insertPhiFunctions(ControlFlowGraph cfg) {
        // 计算支配边界
        Map<BasicBlock, Set<BasicBlock>> domFrontiers = computeDominanceFrontiers(cfg);

        // 收集所有变量定义
        Map<String, Set<BasicBlock>> defSites = collectDefSites(cfg);

        // 为每个变量插入Φ函数
        for (String var : defSites.keySet()) {
            Set<BasicBlock> hasAlready = new HashSet<>();
            Stack<BasicBlock> worklist = new Stack<>();

            // 初始化工作列表
            worklist.addAll(defSites.get(var));

            while (!worklist.isEmpty()) {
                BasicBlock block = worklist.pop();
                for (BasicBlock frontier : domFrontiers.get(block)) {
                    if (!hasAlready.contains(frontier)) {
                        // 在支配边界插入Φ函数
                        insertPhiFunction(frontier, var);
                        hasAlready.add(frontier);
                        if (!defSites.get(var).contains(frontier)) {
                            worklist.push(frontier);
                        }
                    }
                }
            }
        }
    }

    private void insertPhiFunction(BasicBlock block, String var) {
        PhiInstruction phi = new PhiInstruction(var);

        // 为每个前驱添加参数
        for (BasicBlock pred : block.getPredecessors()) {
            String incomingVar = getVariableAtEnd(pred, var);
            phi.addArgument(pred, incomingVar);
        }

        // 在块开头插入Φ函数
        block.prependInstruction(phi);
    }
}
```

#### 变量重命名
```java
// 位置：ep21/src/main/java/org/teachfx/antlr4/ep21/analysis/ssa/VariableRenaming.java
public class VariableRenaming {

    private Map<String, Stack<String>> varStacks;
    private Map<String, Integer> varCounters;

    public void renameVariables(ControlFlowGraph cfg) {
        varStacks = new HashMap<>();
        varCounters = new HashMap<>();

        // 初始化计数器和栈
        for (String var : collectAllVariables(cfg)) {
            varCounters.put(var, 0);
            varStacks.put(var, new Stack<>());
            varStacks.get(var).push(var + "_0"); // 初始版本
        }

        // 深度优先遍历支配树
        renameInBlock(cfg.getEntryBlock());
    }

    private void renameInBlock(BasicBlock block) {
        // 重命名Φ函数的目标
        for (PhiInstruction phi : block.getPhiFunctions()) {
            String newName = newVariableName(phi.getVariable());
            phi.setRenamedVariable(newName);
            varStacks.get(phi.getOriginalVariable()).push(newName);
        }

        // 重命名普通指令
        for (Instruction instr : block.getInstructions()) {
            if (instr instanceof AssignInstruction assign) {
                // 重命名使用的变量
                renameUses(assign.getExpression());

                // 重命名定义
                String newName = newVariableName(assign.getTarget());
                assign.setTarget(newName);
                varStacks.get(assign.getOriginalTarget()).push(newName);
            } else {
                renameUses(instr);
            }
        }

        // 递归处理后继
        for (BasicBlock succ : block.getSuccessors()) {
            for (PhiInstruction phi : succ.getPhiFunctions()) {
                String currentName = varStacks.get(phi.getOriginalVariable()).peek();
                phi.setArgument(block, currentName);
            }
        }

        // 递归处理支配的子节点
        for (BasicBlock child : getDomChildren(block)) {
            renameInBlock(child);
        }

        // 恢复栈状态
        for (PhiInstruction phi : block.getPhiFunctions()) {
            varStacks.get(phi.getOriginalVariable()).pop();
        }
        for (Instruction instr : block.getInstructions()) {
            if (instr instanceof AssignInstruction assign) {
                varStacks.get(assign.getOriginalTarget()).pop();
            }
        }
    }

    private String newVariableName(String baseName) {
        int count = varCounters.get(baseName);
        varCounters.put(baseName, count + 1);
        return baseName + "_" + count;
    }
}
```

## 3. 类型系统扩展

### 3.1 指针类型实现

#### 指针类型定义
```java
// 位置：ep20/src/main/java/org/teachfx/antlr4/ep20/symtab/type/PointerType.java
public class PointerType implements Type {
    private Type baseType;
    private int pointerLevel;

    public PointerType(Type baseType) {
        this.baseType = baseType;
        this.pointerLevel = 1;
    }

    public PointerType(Type baseType, int pointerLevel) {
        this.baseType = baseType;
        this.pointerLevel = pointerLevel;
    }

    @Override
    public String getName() {
        if (pointerLevel == 1) {
            return baseType.getName() + "*";
        } else {
            return baseType.getName() + "*".repeat(pointerLevel);
        }
    }

    public Type getDereferencedType() {
        if (pointerLevel == 1) {
            return baseType;
        } else {
            return new PointerType(baseType, pointerLevel - 1);
        }
    }

    public Type getBaseType() {
        return baseType;
    }

    public int getPointerLevel() {
        return pointerLevel;
    }

    @Override
    public boolean isAssignableFrom(Type other) {
        if (other instanceof PointerType otherPtr) {
            // 相同基类型，或void*可以指向任何类型
            if (this.baseType.isVoid() || otherPtr.baseType.isVoid()) {
                return true;
            }
            return this.baseType.isAssignableFrom(otherPtr.baseType) &&
                   this.pointerLevel == otherPtr.pointerLevel;
        }
        return false;
    }
}
```

#### 指针操作语义
```java
// 位置：ep20/src/main/java/org/teachfx/antlr4/ep20/pass/sematic/PointerTypeChecker.java
public class PointerTypeChecker extends TypeChecker {

    @Override
    public Type visit(PointerDereferenceExprNode node) {
        Type pointerType = visit(node.getPointerExpr());

        if (!(pointerType instanceof PointerType)) {
            addError(node.getCtx(), "Cannot dereference non-pointer type: " + pointerType);
            return TypeTable.ERROR;
        }

        PointerType ptrType = (PointerType) pointerType;
        return ptrType.getDereferencedType();
    }

    @Override
    public Type visit(AddressOfExprNode node) {
        Type exprType = visit(node.getExpr());

        // 不能取地址的表达式
        if (!canTakeAddress(node.getExpr())) {
            addError(node.getCtx(), "Cannot take address of expression");
            return TypeTable.ERROR;
        }

        return new PointerType(exprType);
    }

    @Override
    public Type visit(PointerArithmeticExprNode node) {
        Type pointerType = visit(node.getPointerExpr());
        Type offsetType = visit(node.getOffsetExpr());

        if (!(pointerType instanceof PointerType)) {
            addError(node.getCtx(), "Pointer arithmetic requires pointer type");
            return TypeTable.ERROR;
        }

        if (!offsetType.isIntegerType()) {
            addError(node.getCtx(), "Pointer offset must be integer");
            return TypeTable.ERROR;
        }

        return pointerType; // 指针算术结果还是指针类型
    }
}
```

### 3.2 泛型类型系统

#### 泛型类型定义
```java
// 位置：扩展模块，新建文件
public class GenericType implements Type {
    private String name;
    private List<TypeParameter> typeParameters;
    private Type baseType;
    private Map<TypeParameter, Type> typeArguments;

    public static class TypeParameter {
        private String name;
        private Type bound; // 类型上界

        public TypeParameter(String name) {
            this(name, TypeTable.OBJECT);
        }

        public TypeParameter(String name, Type bound) {
            this.name = name;
            this.bound = bound;
        }
    }

    public GenericType(String name, List<TypeParameter> typeParameters, Type baseType) {
        this.name = name;
        this.typeParameters = typeParameters;
        this.baseType = baseType;
        this.typeArguments = new HashMap<>();
    }

    public GenericType instantiate(Map<TypeParameter, Type> arguments) {
        GenericType instantiated = new GenericType(this.name, this.typeParameters, this.baseType);
        instantiated.typeArguments.putAll(arguments);
        return instantiated;
    }

    public Type getErasedType() {
        // 类型擦除：泛型类型擦除为原始类型
        return eraseType(this.baseType);
    }

    private Type eraseType(Type type) {
        if (type instanceof GenericType) {
            return ((GenericType) type).getErasedType();
        } else if (type instanceof ArrayType arrayType) {
            return new ArrayType(eraseType(arrayType.getElementType()));
        } else {
            return type;
        }
    }
}
```

## 4. JIT编译器实现

### 4.1 热点检测

#### 执行计数器
```java
// 位置：新建模块ep22
public class ExecutionCounter {
    private Map<Integer, CounterInfo> counters; // key: 字节码位置
    private int threshold;

    private static class CounterInfo {
        int count;
        long lastReset;
        boolean isHot;
    }

    public ExecutionCounter(int threshold) {
        this.counters = new ConcurrentHashMap<>();
        this.threshold = threshold;
    }

    public void recordExecution(int bytecodePosition) {
        CounterInfo info = counters.computeIfAbsent(bytecodePosition,
            k -> new CounterInfo());

        info.count++;

        // 定期衰减
        long now = System.currentTimeMillis();
        if (now - info.lastReset > 1000) { // 1秒衰减
            info.count = Math.max(0, info.count - threshold / 2);
            info.lastReset = now;
        }

        if (info.count >= threshold && !info.isHot) {
            info.isHot = true;
            notifyHotSpotDetected(bytecodePosition);
        }
    }

    public boolean isHot(int bytecodePosition) {
        CounterInfo info = counters.get(bytecodePosition);
        return info != null && info.isHot;
    }
}
```

### 4.2 JIT编译管道

#### 即时编译器
```java
// 位置：ep22/src/main/java/org/teachfx/antlr4/ep22/jit/JITCompiler.java
public class JITCompiler {
    private final CodeCache codeCache;
    private final OptimizationPipeline optimizationPipeline;
    private final CodeGenerator codeGenerator;

    public JITCompiler() {
        this.codeCache = new CodeCache();
        this.optimizationPipeline = new OptimizationPipeline();
        this.codeGenerator = new CodeGenerator();
    }

    public CompiledFunction compileHotSpot(int bytecodePosition, byte[] bytecode) {
        // 1. 反编译字节码为IR
        IRFunction irFunction = decompile(bytecode, bytecodePosition);

        // 2. 应用优化
        optimizationPipeline.optimize(irFunction);

        // 3. 生成机器码
        MachineCode machineCode = codeGenerator.generate(irFunction);

        // 4. 缓存结果
        CompiledFunction compiled = new CompiledFunction(machineCode);
        codeCache.put(bytecodePosition, compiled);

        return compiled;
    }

    public Object executeCompiled(int bytecodePosition, Object[] args) {
        CompiledFunction compiled = codeCache.get(bytecodePosition);
        if (compiled == null) {
            return null; // 回退到解释执行
        }

        try {
            return compiled.execute(args);
        } catch (DeoptimizationException e) {
            // 去优化：回退到解释执行
            codeCache.invalidate(bytecodePosition);
            return null;
        }
    }
}
```

## 5. 调试器实现

### 5.1 断点管理

#### 断点管理器
```java
// 位置：新建tools/debugger/
public class BreakpointManager {
    private Set<Breakpoint> breakpoints;
    private DebuggerSession session;

    public static class Breakpoint {
        String sourceFile;
        int lineNumber;
        boolean enabled;
        int hitCount;
        String condition; // 条件断点
    }

    public BreakpointManager(DebuggerSession session) {
        this.breakpoints = new HashSet<>();
        this.session = session;
    }

    public void addBreakpoint(String sourceFile, int lineNumber) {
        Breakpoint bp = new Breakpoint();
        bp.sourceFile = sourceFile;
        bp.lineNumber = lineNumber;
        bp.enabled = true;
        breakpoints.add(bp);

        // 将断点映射到字节码位置
        int bytecodePos = session.getBytecodePosition(sourceFile, lineNumber);
        if (bytecodePos >= 0) {
            session.setBreakpoint(bytecodePos);
        }
    }

    public void removeBreakpoint(String sourceFile, int lineNumber) {
        breakpoints.removeIf(bp ->
            bp.sourceFile.equals(sourceFile) && bp.lineNumber == lineNumber);
    }

    public boolean shouldBreak(int bytecodePosition, ExecutionContext context) {
        for (Breakpoint bp : breakpoints) {
            if (bp.enabled && matchesBreakpoint(bp, bytecodePosition)) {
                if (bp.condition != null) {
                    // 评估条件
                    if (!evaluateCondition(bp.condition, context)) {
                        continue;
                    }
                }
                bp.hitCount++;
                return true;
            }
        }
        return false;
    }
}
```

### 5.2 变量查看器

#### 变量提取
```java
// 位置：tools/debugger/VariableInspector.java
public class VariableInspector {
    private DebuggerSession session;

    public List<VariableInfo> getLocalVariables(StackFrame frame) {
        List<VariableInfo> variables = new ArrayList<>();

        // 从符号表获取变量信息
        SymbolTable symtab = session.getSymbolTableForFrame(frame);
        if (symtab != null) {
            for (Symbol symbol : symtab.getAllSymbols()) {
                if (symbol instanceof VariableSymbol varSym) {
                    VariableInfo info = new VariableInfo();
                    info.name = varSym.getName();
                    info.type = varSym.getType().getName();
                    info.value = getVariableValue(frame, varSym);
                    info.address = getVariableAddress(frame, varSym);
                    variables.add(info);
                }
            }
        }

        return variables;
    }

    private Object getVariableValue(StackFrame frame, VariableSymbol varSym) {
        int slot = varSym.getSlot();
        if (slot >= 0) {
            return frame.getLocal(slot);
        } else {
            // 全局变量或结构体字段
            return session.getGlobalValue(varSym);
        }
    }

    public Object evaluateExpression(String expr, ExecutionContext context) {
        // 解析表达式
        ExpressionAST exprAST = parseExpression(expr);

        // 在当前上下文中求值
        return evaluateInContext(exprAST, context);
    }
}
```

## 6. 语法扩展

### 6.1 指针语法扩展

#### ANTLR4语法规则
```antlr4
// 修改Cymbol.g4，添加指针相关规则
type
    : primitiveType
    | structType
    | pointerType
    ;

pointerType
    : type '*'+
    ;

expression
    : '*' expression                  #dereferenceExpr
    | '&' expression                  #addressOfExpr
    | expression ('+' | '-') expression  #pointerArithmeticExpr
    ;

assignmentExpression
    : unaryExpression '=' expression
    | pointerDereference '=' expression  // 指针解引用赋值
    ;

pointerDereference
    : '*' expression
    ;
```

### 6.2 泛型语法扩展

#### 泛型语法规则
```antlr4
// 添加泛型支持
typeParameterList
    : '<' typeParameter (',' typeParameter)* '>'
    ;

typeParameter
    : IDENTIFIER ('extends' type)?
    ;

genericType
    : IDENTIFIER typeArgumentList?
    ;

typeArgumentList
    : '<' type (',' type)* '>'
    ;

// 泛型函数声明
functionDecl
    : typeParameterList? type IDENTIFIER '(' parameterList? ')' block
    ;

// 泛型结构体
structDecl
    : 'struct' IDENTIFIER typeParameterList? '{' structMember+ '}'
    ;
```

## 7. 性能监控

### 7.1 性能分析器

#### 执行时间分析
```java
// 位置：tools/profiler/ExecutionProfiler.java
public class ExecutionProfiler {
    private Map<String, MethodProfile> methodProfiles;
    private Stack<MethodCall> callStack;

    private static class MethodProfile {
        String name;
        long totalTime;
        long callCount;
        long selfTime;
        Map<String, Long> calleeTimes;
    }

    private static class MethodCall {
        String methodName;
        long startTime;
    }

    public ExecutionProfiler() {
        this.methodProfiles = new HashMap<>();
        this.callStack = new Stack<>();
    }

    public void methodEnter(String methodName) {
        MethodCall call = new MethodCall();
        call.methodName = methodName;
        call.startTime = System.nanoTime();
        callStack.push(call);
    }

    public void methodExit() {
        if (callStack.isEmpty()) return;

        MethodCall call = callStack.pop();
        long duration = System.nanoTime() - call.startTime;

        MethodProfile profile = methodProfiles.computeIfAbsent(call.methodName,
            k -> new MethodProfile());
        profile.name = call.methodName;
        profile.totalTime += duration;
        profile.callCount++;

        // 计算self time（减去被调用方法的时间）
        long childTime = 0;
        for (MethodCall child : callStack) {
            // 统计当前调用期间子调用的时间
            // 简化实现，实际需要更精确的跟踪
        }
        profile.selfTime += duration - childTime;

        // 记录调用关系
        if (!callStack.isEmpty()) {
            MethodCall parent = callStack.peek();
            MethodProfile parentProfile = methodProfiles.get(parent.methodName);
            if (parentProfile != null) {
                parentProfile.calleeTimes.merge(call.methodName, duration, Long::sum);
            }
        }
    }

    public void generateReport() {
        System.out.println("=== Execution Profile Report ===");
        System.out.println("Method\tCalls\tTotal Time\tSelf Time\tAvg Time");

        methodProfiles.values().stream()
            .sorted((a, b) -> Long.compare(b.selfTime, a.selfTime))
            .forEach(profile -> {
                double totalMs = profile.totalTime / 1_000_000.0;
                double selfMs = profile.selfTime / 1_000_000.0;
                double avgMs = totalMs / profile.callCount;

                System.out.printf("%s\t%d\t%.2fms\t%.2fms\t%.2fms%n",
                    profile.name, profile.callCount, totalMs, selfMs, avgMs);
            });
    }
}
```

## 8. 构建系统扩展

### 8.1 增量编译

#### 依赖分析
```java
// 位置：新建tools/build/DependencyAnalyzer.java
public class DependencyAnalyzer {
    private Map<String, Set<String>> dependencies;
    private Map<String, Long> fileTimestamps;

    public DependencyAnalyzer() {
        this.dependencies = new HashMap<>();
        this.fileTimestamps = new HashMap<>();
    }

    public void analyzeFile(String filePath, AST ast) {
        Set<String> deps = new HashSet<>();

        // 分析导入声明
        for (ImportDecl importDecl : ast.getImports()) {
            deps.add(resolveImport(importDecl.getPath()));
        }

        // 分析类型依赖
        for (TypeDecl typeDecl : ast.getTypeDeclarations()) {
            deps.addAll(analyzeTypeDependencies(typeDecl));
        }

        dependencies.put(filePath, deps);
        fileTimestamps.put(filePath, getFileTimestamp(filePath));
    }

    public Set<String> getFilesToRecompile(String changedFile) {
        Set<String> toRecompile = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        queue.add(changedFile);

        while (!queue.isEmpty()) {
            String file = queue.poll();
            toRecompile.add(file);

            // 查找依赖此文件的所有文件
            for (Map.Entry<String, Set<String>> entry : dependencies.entrySet()) {
                if (entry.getValue().contains(file) && !toRecompile.contains(entry.getKey())) {
                    queue.add(entry.getKey());
                }
            }
        }

        return toRecompile;
    }

    public boolean needsRecompile(String filePath) {
        Long oldTimestamp = fileTimestamps.get(filePath);
        if (oldTimestamp == null) return true;

        long newTimestamp = getFileTimestamp(filePath);
        return newTimestamp > oldTimestamp;
    }
}
```

## 总结

本文档提供了Cymbol编译器实现深度提升的具体技术方案，包括：

1. **虚拟机实现**：完整的栈式虚拟机，包含垃圾回收
2. **优化器实现**：常量传播、SSA形式、数据流分析
3. **类型系统扩展**：指针、泛型支持
4. **JIT编译器**：热点检测、即时编译
5. **调试器工具**：断点管理、变量查看
6. **语法扩展**：指针和泛型语法
7. **性能监控**：执行时间分析
8. **构建系统**：增量编译支持

每个部分都提供了具体的代码实现方案，可以直接用于开发实施。建议按照季度实施计划的顺序逐步实现这些功能。