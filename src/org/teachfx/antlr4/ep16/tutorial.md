[TOC]

# 如何实现一个可自定义算术函数的简单编程语言(Cymbol)

## 目标语言的简单定义
### 词法单元
### 语法定义--EBNF

### 如何求值？
这个问题曾经困扰了我数年之久，抱歉我确实很迟钝也不爱直接接受书本上的理论。
因此，我回到了二进制加法计算的底层实现化简。即通过两个半加器的全加器。
### 作用域与求值
为什么需要作用域？
### 作用域是什么？

#### 词法作用域
module作用域 > 文件作用域 > 类或闭包作用域 > 函数作用域 > 基础块作用域
作用域嵌套情况下，内层作用域中的变量总能够访问父级作用域中可见的任意变量。
##### 静态作用域
Cymbol是一个以文件作为module基础单位的静态作用域的强类型语言。
每一个文件是一个独立的文件作用域。
## 实现思路

## 代码分解

### 实现分词

### 语法分析

### 语义分析
### function的语义是什么？

#### 类型检查

##### 1. 符号类型与值匹配

##### 2. 操作符合法性检查

##### 3. 函数类型检查


### Expr的求值

### Function的求值

#### 1. Function和Expr有什么不同？
Function拥有独立的作用域的一组Expr求值的过程描述。比如，
```
int add(int x, int y) {
    return x + y;
}
```
Function实际上由一组给定的形参(`int x, int y`)构成独立作用域，这组形参也被我们成为定义这个函数的参数列表。
我们实际上只是在Expr求值的基础上增加了一个独立作用域来隔离和保存计算过程与结果。同时，需要
注意的是，我们函数可以引用自其向上所有可见作用域的变量。
#### 2. Function和Block有什么不同？
实际上，根据上面的回答我们可以直到，函数就是参数列表加上block形成的一个计算过程。
#### 3. Function的求值环境（作用域）
求值环境就是从当前函数向上搜索可见作用域加上参数列表。
需要注意的是，我们有两个环境需要注意，一个是定义，一个是调用。
```
int z = 10;
int addOffset(int x, int y) {
    return x + y * z;
}

int c = 1;
int b = 2;
int q = addOffset(c,b);

```
#### 4. Function的执行
