# 栈帧管理系统设计

## 概述

本文档详细描述Cymbol虚拟机栈帧管理系统的设计，包括栈帧结构、变量槽位管理、调用栈管理、内存优化等内容。

## 当前状态分析

### 现有实现
- **位置**：`StackFrame.java`（13行代码）
- **功能**：基础的栈帧数据结构
- **特点**：非常简单的实现，缺少管理逻辑

### 当前问题
1. **功能不完整**：只有基本的数据结构，缺少管理逻辑
2. **变量管理简单**：没有槽位分配和优化
3. **内存管理不足**：缺少动态扩展和压缩
4. **调试支持有限**：没有变量跟踪和状态检查

## 改进设计

### 核心类设计

#### 增强的StackFrame类
```java
public class EnhancedStackFrame implements StackFrame {
    // 栈帧标识
    private final int frameId;
    private final String functionName;
    private final FunctionSymbol functionSymbol;

    // 内存管理
    private final int[] localVariables;     // 局部变量槽
    private final Type[] variableTypes;     // 变量类型信息
    private final VMStack operandStack;     // 操作数栈

    // 调用信息
    private final int returnAddress;        // 返回地址
    private final EnhancedStackFrame callerFrame;  // 调用者栈帧
    private final Map<String, Integer> variableMap; // 变量名到槽位的映射

    // 调试信息
    private final List<VariableAccess> accessLog;    // 变量访问日志
    private final int lineNumber;                    // 当前行号
    private final int scopeLevel;                    // 作用域级别

    // 构造函数
    public EnhancedStackFrame(FunctionSymbol function, int argCount, EnhancedStackFrame caller) {
        this.frameId = generateFrameId();
        this.functionSymbol = function;
        this.functionName = function.getName();
        this.callerFrame = caller;
        this.returnAddress = -1;

        // 初始化局部变量
        int localCount = calculateLocalVariableCount(function, argCount);
        this.localVariables = new int[localCount];
        this.variableTypes = new Type[localCount];
        this.operandStack = new VMStack(DEFAULT_STACK_SIZE);

        // 初始化变量映射
        this.variableMap = new HashMap<>();
        this.accessLog = new ArrayList<>();
        this.lineNumber = -1;
        this.scopeLevel = 0;

        // 初始化变量槽位
        initializeVariableSlots(function, argCount);
    }
}
```

#### 栈帧管理器
```java
public class StackFrameManager {
    // 栈帧管理
    private final Deque<EnhancedStackFrame> callStack;
    private final Map<Integer, EnhancedStackFrame> frameRegistry;
    private final AtomicInteger frameCounter;

    // 内存管理
    private final int maxStackDepth;
    private final int maxFrameCount;
    private long totalMemoryUsed;

    // 统计信息
    private final StackFrameStatistics statistics;

    // 构造函数
    public StackFrameManager(int maxStackDepth, int maxFrameCount) {
        this.callStack = new ArrayDeque<>();
        this.frameRegistry = new HashMap<>();
        this.frameCounter = new AtomicInteger(0);
        this.maxStackDepth = maxStackDepth;
        this.maxFrameCount = maxFrameCount;
        this.totalMemoryUsed = 0;
        this.statistics = new StackFrameStatistics();
    }

    // 核心方法
    public EnhancedStackFrame pushFrame(FunctionSymbol function, int argCount) {
        checkStackOverflow();

        EnhancedStackFrame frame = new EnhancedStackFrame(function, argCount, getCurrentFrame());
        callStack.push(frame);
        frameRegistry.put(frame.getFrameId(), frame);

        updateStatistics(frame, true);
        return frame;
    }

    public EnhancedStackFrame popFrame() {
        if (callStack.isEmpty()) {
            throw new VMStackUnderflowException("No frame to pop");
        }

        EnhancedStackFrame frame = callStack.pop();
        updateStatistics(frame, false);
        return frame;
    }

    public EnhancedStackFrame getCurrentFrame() {
        return callStack.peek();
    }

    public int getStackDepth() {
        return callStack.size();
    }

    // 检查栈溢出
    private void checkStackOverflow() {
        if (callStack.size() >= maxStackDepth) {
            throw new VMStackOverflowException(
                "Maximum stack depth exceeded: " + maxStackDepth);
        }

        if (callStack.size() >= maxFrameCount) {
            throw new VMStackOverflowException(
                "Maximum frame count exceeded: " + maxFrameCount);
        }
    }

    // 变量槽位分配
    public int allocateVariableSlot(String varName, Type type) {
        EnhancedStackFrame frame = getCurrentFrame();
        return frame.allocateVariableSlot(varName, type);
    }

    // 变量访问跟踪
    public void recordVariableAccess(String varName, VariableAccess.AccessType accessType) {
        EnhancedStackFrame frame = getCurrentFrame();
        frame.recordVariableAccess(varName, accessType);
    }
}
```

### 变量槽位管理

#### 槽位分配策略
```java
public class VariableSlotManager {
    // 槽位分配
    private final int[] slots;
    private final Type[] slotTypes;
    private final boolean[] slotUsed;
    private final Map<String, Integer> variableToSlot;
    private final Map<Integer, String> slotToVariable;

    // 构造函数
    public VariableSlotManager(int slotCount) {
        this.slots = new int[slotCount];
        this.slotTypes = new Type[slotCount];
        this.slotUsed = new boolean[slotCount];
        this.variableToSlot = new HashMap<>();
        this.slotToVariable = new HashMap<>();
    }

    // 分配槽位
    public int allocateSlot(String variableName, Type type) {
        // 1. 检查是否已经分配
        if (variableToSlot.containsKey(variableName)) {
            return variableToSlot.get(variableName);
        }

        // 2. 寻找空闲槽位
        int slot = findFreeSlot(type);
        if (slot == -1) {
            throw new VMOutOfSlotsException("No available slots for variable: " + variableName);
        }

        // 3. 分配槽位
        slotUsed[slot] = true;
        slots[slot] = 0; // 初始化为0
        slotTypes[slot] = type;
        variableToSlot.put(variableName, slot);
        slotToVariable.put(slot, variableName);

        return slot;
    }

    // 释放槽位
    public void releaseSlot(String variableName) {
        Integer slot = variableToSlot.get(variableName);
        if (slot != null) {
            slotUsed[slot] = false;
            variableToSlot.remove(variableName);
            slotToVariable.remove(slot);
        }
    }

    // 查找空闲槽位
    private int findFreeSlot(Type type) {
        // 1. 首先尝试类型匹配的位置
        for (int i = 0; i < slots.length; i++) {
            if (!slotUsed[i] && isCompatibleType(slotTypes[i], type)) {
                return i;
            }
        }

        // 2. 寻找任意空闲位置
        for (int i = 0; i < slots.length; i++) {
            if (!slotUsed[i]) {
                return i;
            }
        }

        return -1; // 没有可用槽位
    }

    // 类型兼容性检查
    private boolean isCompatibleType(Type existingType, Type newType) {
        if (existingType == null) {
            return true; // 未使用的槽位可以用于任何类型
        }
        return existingType.equals(newType);
    }

    // 获取槽位值
    public int getSlotValue(int slot) {
        if (slot < 0 || slot >= slots.length || !slotUsed[slot]) {
            throw new VMInvalidSlotException("Invalid slot access: " + slot);
        }
        return slots[slot];
    }

    // 设置槽位值
    public void setSlotValue(int slot, int value) {
        if (slot < 0 || slot >= slots.length || !slotUsed[slot]) {
            throw new VMInvalidSlotException("Invalid slot access: " + slot);
        }
        slots[slot] = value;
    }

    // 优化槽位使用
    public void optimizeSlots() {
        // 压缩使用中的槽位，去除碎片
        List<Integer> usedSlots = new ArrayList<>();
        List<Type> usedTypes = new ArrayList<>();

        for (int i = 0; i < slots.length; i++) {
            if (slotUsed[i]) {
                usedSlots.add(slots[i]);
                usedTypes.add(slotTypes[i]);
            }
        }

        // 重新紧凑排列
        Arrays.fill(slotUsed, false);
        for (int i = 0; i < usedSlots.size(); i++) {
            slotUsed[i] = true;
            slots[i] = usedSlots.get(i);
            slotTypes[i] = usedTypes.get(i);
        }
    }
}
```

### 调用栈管理

#### 栈帧链管理
```java
public class CallStackManager {
    private final Deque<EnhancedStackFrame> stack;
    private final StackFrameValidator validator;
    private final CallStackAnalyzer analyzer;

    // 构造函数
    public CallStackManager(int maxDepth) {
        this.stack = new ArrayDeque<>(maxDepth);
        this.validator = new StackFrameValidator();
        this.analyzer = new CallStackAnalyzer();
    }

    // 调用函数
    public CallContext callFunction(FunctionSymbol function, int[] arguments) {
        // 1. 验证调用
        validator.validateCall(function, arguments.length);

        // 2. 创建栈帧
        EnhancedStackFrame frame = createStackFrame(function, arguments);

        // 3. 记录调用上下文
        CallContext context = new CallContext(function, frame, getCurrentTimestamp());

        // 4. 推入调用栈
        stack.push(frame);

        return context;
    }

    // 函数返回
    public ReturnContext returnFromFunction(int returnValue) {
        if (stack.isEmpty()) {
            throw new VMInvalidReturnException("Return from non-function context");
        }

        EnhancedStackFrame frame = stack.pop();
        ReturnContext context = new ReturnContext(frame, returnValue, getCurrentTimestamp());

        // 验证返回的合法性
        validator.validateReturn(frame, returnValue);

        return context;
    }

    // 获取调用链
    public List<CallStackFrame> getCallChain() {
        List<CallStackFrame> chain = new ArrayList<>();
        for (EnhancedStackFrame frame : stack) {
            chain.add(new CallStackFrame(frame));
        }
        return chain;
    }

    // 分析调用模式
    public CallStackAnalysis analyzeCallStack() {
        return analyzer.analyze(stack);
    }

    // 栈帧创建
    private EnhancedStackFrame createStackFrame(FunctionSymbol function, int[] arguments) {
        int argCount = arguments.length;
        EnhancedStackFrame callerFrame = stack.peek();

        EnhancedStackFrame frame = new EnhancedStackFrame(function, argCount, callerFrame);

        // 复制参数到局部变量
        for (int i = 0; i < argCount; i++) {
            String paramName = function.getParameterName(i);
            frame.setLocal(i, arguments[i]);
        }

        return frame;
    }

    // 获取时间戳
    private long getCurrentTimestamp() {
        return System.nanoTime();
    }
}
```

### 内存管理优化

#### 栈帧内存池
```java
public class StackFrameMemoryPool {
    private final Queue<EnhancedStackFrame> availableFrames;
    private final Map<Class<?>, Queue<?>> typedPools;
    private final int maxPoolSize;
    private final AtomicInteger createdFrames;
    private final AtomicInteger reusedFrames;

    // 构造函数
    public StackFrameMemoryPool(int poolSize) {
        this.availableFrames = new LinkedList<>();
        this.typedPools = new HashMap<>();
        this.maxPoolSize = poolSize;
        this.createdFrames = new AtomicInteger(0);
        this.reusedFrames = new AtomicInteger(0);
    }

    // 获取栈帧
    public EnhancedStackFrame acquireFrame(FunctionSymbol function, int argCount, EnhancedStackFrame caller) {
        EnhancedStackFrame frame = availableFrames.poll();

        if (frame != null) {
            reusedFrames.incrementAndGet();
            frame.reset(function, argCount, caller);
        } else {
            createdFrames.incrementAndGet();
            frame = new EnhancedStackFrame(function, argCount, caller);
        }

        return frame;
    }

    // 释放栈帧
    public void releaseFrame(EnhancedStackFrame frame) {
        if (availableFrames.size() < maxPoolSize) {
            frame.clear();
            availableFrames.offer(frame);
        }
        // 如果池已满，让GC回收
    }

    // 清理池
    public void clearPool() {
        availableFrames.clear();
        for (Queue<?> pool : typedPools.values()) {
            pool.clear();
        }
    }

    // 获取统计信息
    public MemoryPoolStatistics getStatistics() {
        return new MemoryPoolStatistics(
            createdFrames.get(),
            reusedFrames.get(),
            availableFrames.size(),
            maxPoolSize
        );
    }
}
```

### 调试支持

#### 变量访问跟踪
```java
public class VariableAccessTracker {
    private final Map<String, List<VariableAccess>> accessLog;
    private final Map<String, Integer> accessCount;
    private final Set<String> readOnlyVariables;
    private final Set<String> writtenVariables;

    // 构造函数
    public VariableAccessTracker() {
        this.accessLog = new HashMap<>();
        this.accessCount = new HashMap<>();
        this.readOnlyVariables = new HashSet<>();
        this.writtenVariables = new HashSet<>();
    }

    // 记录变量访问
    public void recordAccess(String variableName, VariableAccess.AccessType type, int pc, long timestamp) {
        VariableAccess access = new VariableAccess(variableName, type, pc, timestamp);

        accessLog.computeIfAbsent(variableName, k -> new ArrayList<>()).add(access);
        accessCount.merge(variableName, 1, Integer::sum);

        switch (type) {
            case READ:
                readOnlyVariables.add(variableName);
                break;
            case WRITE:
                writtenVariables.add(variableName);
                break;
            case READ_WRITE:
                readOnlyVariables.add(variableName);
                writtenVariables.add(variableName);
                break;
        }
    }

    // 获取变量访问历史
    public List<VariableAccess> getAccessHistory(String variableName) {
        return accessLog.getOrDefault(variableName, new ArrayList<>());
    }

    // 获取活跃变量
    public Set<String> getLiveVariables(int pc) {
        Set<String> liveVars = new HashSet<>();

        for (Map.Entry<String, List<VariableAccess>> entry : accessLog.entrySet()) {
            String varName = entry.getKey();
            List<VariableAccess> accesses = entry.getValue();

            // 检查在该PC点是否活跃
            for (VariableAccess access : accesses) {
                if (isVariableLiveAtPC(access, pc)) {
                    liveVars.add(varName);
                    break;
                }
            }
        }

        return liveVars;
    }

    // 检查变量在指定PC点是否活跃
    private boolean isVariableLiveAtPC(VariableAccess access, int pc) {
        // 简化的活跃性分析
        // 实际实现中需要更复杂的分析
        return access.getPC() <= pc;
    }

    // 生成变量访问报告
    public VariableAccessReport generateReport() {
        return new VariableAccessReport(
            accessLog,
            accessCount,
            readOnlyVariables,
            writtenVariables
        );
    }
}
```

### 性能监控

#### 栈帧统计
```java
public class StackFrameStatistics {
    // 计数统计
    private final AtomicInteger totalFramesCreated;
    private final AtomicInteger totalFramesDestroyed;
    private final AtomicInteger maxStackDepth;
    private final AtomicInteger currentStackDepth;

    // 时间统计
    private final AtomicLong totalFrameLifetime;
    private final List<Long> frameLifetimes;

    // 内存统计
    private final AtomicLong totalMemoryUsed;
    private final AtomicLong peakMemoryUsed;

    // 构造函数
    public StackFrameStatistics() {
        this.totalFramesCreated = new AtomicInteger(0);
        this.totalFramesDestroyed = new AtomicInteger(0);
        this.maxStackDepth = new AtomicInteger(0);
        this.currentStackDepth = new AtomicInteger(0);
        this.totalFrameLifetime = new AtomicLong(0);
        this.frameLifetimes = new CopyOnWriteArrayList<>();
        this.totalMemoryUsed = new AtomicLong(0);
        this.peakMemoryUsed = new AtomicLong(0);
    }

    // 记录栈帧创建
    public void recordFrameCreation(int frameSize) {
        totalFramesCreated.incrementAndGet();
        currentStackDepth.incrementAndGet();

        // 更新最大深度
        int currentDepth = currentStackDepth.get();
        maxStackDepth.updateAndGet(max -> Math.max(max, currentDepth));

        // 更新内存使用
        totalMemoryUsed.addAndGet(frameSize);
        peakMemoryUsed.updateAndGet(peak -> Math.max(peak, totalMemoryUsed.get()));
    }

    // 记录栈帧销毁
    public void recordFrameDestruction(long lifetime) {
        totalFramesDestroyed.incrementAndGet();
        currentStackDepth.decrementAndGet();
        totalFrameLifetime.addAndGet(lifetime);
        frameLifetimes.add(lifetime);
    }

    // 获取统计摘要
    public StackFrameStatisticsSummary getSummary() {
        int created = totalFramesCreated.get();
        int destroyed = totalFramesDestroyed.get();
        int maxDepth = maxStackDepth.get();
        int currentDepth = currentStackDepth.get();

        double avgLifetime = created > 0 ?
            (double) totalFrameLifetime.get() / created : 0.0;

        return new StackFrameStatisticsSummary(
            created,
            destroyed,
            maxDepth,
            currentDepth,
            avgLifetime,
            totalMemoryUsed.get(),
            peakMemoryUsed.get(),
            frameLifetimes.size()
        );
    }
}
```

### 验证和检查

#### 栈帧验证器
```java
public class StackFrameValidator {
    // 验证函数调用
    public void validateCall(FunctionSymbol function, int argCount) {
        if (function == null) {
            throw new VMValidationException("Function symbol is null");
        }

        int expectedArgs = function.getParameterCount();
        if (argCount != expectedArgs) {
            throw new VMValidationException(
                String.format("Argument count mismatch: expected %d, got %d",
                    expectedArgs, argCount));
        }
    }

    // 验证栈帧操作
    public void validateFrameOperation(EnhancedStackFrame frame, String operation) {
        if (frame == null) {
            throw new VMValidationException("Frame is null for operation: " + operation);
        }

        // 检查栈帧状态
        if (!frame.isValid()) {
            throw new VMValidationException("Invalid frame state for operation: " + operation);
        }
    }

    // 验证变量访问
    public void validateVariableAccess(EnhancedStackFrame frame, int slot, VariableAccess.AccessType accessType) {
        if (slot < 0 || slot >= frame.getSlotCount()) {
            throw new VMValidationException("Invalid slot index: " + slot);
        }

        if (!frame.isSlotUsed(slot)) {
            throw new VMValidationException("Accessing unused slot: " + slot);
        }

        // 检查只读变量的写访问
        if (accessType == VariableAccess.AccessType.WRITE &&
            frame.isSlotReadOnly(slot)) {
            throw new VMValidationException("Writing to read-only slot: " + slot);
        }
    }

    // 验证栈深度
    public void validateStackDepth(int currentDepth, int maxDepth) {
        if (currentDepth < 0) {
            throw new VMValidationException("Negative stack depth: " + currentDepth);
        }

        if (currentDepth > maxDepth) {
            throw new VMStackOverflowException(
                "Stack depth exceeds maximum: " + currentDepth + " > " + maxDepth);
        }
    }
}
```

## 测试策略

### 单元测试
```java
public class StackFrameTest {
    private StackFrameManager manager;
    private FunctionSymbol testFunction;

    @BeforeEach
    void setUp() {
        manager = new StackFrameManager(100, 1000);
        testFunction = createTestFunction("testFunc", 3);
    }

    @Test
    void testFrameCreationAndDestruction() {
        // 创建栈帧
        EnhancedStackFrame frame = manager.pushFrame(testFunction, 3);

        assertEquals(1, manager.getStackDepth());
        assertEquals(frame, manager.getCurrentFrame());

        // 销毁栈帧
        EnhancedStackFrame popped = manager.popFrame();

        assertEquals(0, manager.getStackDepth());
        assertEquals(frame, popped);
    }

    @Test
    void testVariableSlotAllocation() {
        EnhancedStackFrame frame = manager.pushFrame(testFunction, 3);

        // 分配变量槽位
        int slot1 = frame.allocateVariableSlot("var1", Type.INT);
        int slot2 = frame.allocateVariableSlot("var2", Type.FLOAT);

        assertTrue(slot1 >= 0);
        assertTrue(slot2 >= 0);
        assertNotEquals(slot1, slot2);

        // 设置和获取变量值
        frame.setLocal(slot1, 42);
        assertEquals(42, frame.getLocal(slot1));
    }

    @Test
    void testStackOverflow() {
        // 设置很小的最大深度
        StackFrameManager smallManager = new StackFrameManager(2, 10);

        // 第一次调用应该成功
        smallManager.pushFrame(testFunction, 3);
        smallManager.pushFrame(testFunction, 3);

        // 第二次调用应该失败
        assertThrows(VMStackOverflowException.class, () -> {
            smallManager.pushFrame(testFunction, 3);
        });
    }

    @Test
    void testVariableAccessTracking() {
        EnhancedStackFrame frame = manager.pushFrame(testFunction, 3);
        int slot = frame.allocateVariableSlot("testVar", Type.INT);

        // 记录访问
        frame.recordVariableAccess("testVar", VariableAccess.AccessType.WRITE);
        frame.setLocal(slot, 10);
        frame.recordVariableAccess("testVar", VariableAccess.AccessType.READ);

        // 验证跟踪
        List<VariableAccess> accesses = frame.getAccessHistory("testVar");
        assertEquals(2, accesses.size());
        assertEquals(VariableAccess.AccessType.WRITE, accesses.get(0).getAccessType());
        assertEquals(VariableAccess.AccessType.READ, accesses.get(1).getAccessType());
    }

    @Test
    void testMemoryPool() {
        StackFrameMemoryPool pool = new StackFrameMemoryPool(10);

        // 获取和释放栈帧
        EnhancedStackFrame frame1 = pool.acquireFrame(testFunction, 3, null);
        EnhancedStackFrame frame2 = pool.acquireFrame(testFunction, 3, null);

        pool.releaseFrame(frame1);
        pool.releaseFrame(frame2);

        // 验证重用
        MemoryPoolStatistics stats = pool.getStatistics();
        assertTrue(stats.getCreatedFrames() >= 2);
        assertTrue(stats.getReusedFrames() >= 0);
    }
}
```

### 性能测试
```java
public class StackFramePerformanceTest {
    @Test
    void testFrameCreationPerformance() {
        StackFrameManager manager = new StackFrameManager(1000, 10000);
        FunctionSymbol function = createTestFunction("perfFunc", 5);

        long startTime = System.nanoTime();

        // 创建1000个栈帧
        for (int i = 0; i < 1000; i++) {
            manager.pushFrame(function, 5);
        }

        long creationTime = System.nanoTime() - startTime;

        startTime = System.nanoTime();

        // 销毁所有栈帧
        for (int i = 0; i < 1000; i++) {
            manager.popFrame();
        }

        long destructionTime = System.nanoTime() - startTime;

        // 性能断言
        assertTrue(creationTime < 1_000_000, "Frame creation too slow: " + creationTime + "ns");
        assertTrue(destructionTime < 500_000, "Frame destruction too slow: " + destructionTime + "ns");
    }

    @Test
    void testMemoryPoolEffectiveness() {
        StackFrameMemoryPool pool = new StackFrameMemoryPool(100);
        FunctionSymbol function = createTestFunction("poolFunc", 3);

        // 创建大量栈帧
        List<EnhancedStackFrame> frames = new ArrayList<>();
        for (int i = 0; i < 200; i++) {
            frames.add(pool.acquireFrame(function, 3, null));
        }

        // 释放一半
        for (int i = 0; i < 100; i++) {
            pool.releaseFrame(frames.get(i));
        }

        // 重新获取（应该重用）
        long startTime = System.nanoTime();
        for (int i = 0; i < 50; i++) {
            pool.acquireFrame(function, 3, null);
        }
        long reuseTime = System.nanoTime() - startTime;

        MemoryPoolStatistics stats = pool.getStatistics();
        assertTrue(stats.getReusedFrames() > 0, "Memory pool should reuse frames");
    }
}
```

## 实施计划

### 第1周：核心栈帧实现
- [ ] 实现EnhancedStackFrame类
- [ ] 创建StackFrameManager
- [ ] 实现变量槽位管理
- [ ] 基础单元测试

### 第2周：调用栈管理
- [ ] 实现CallStackManager
- [ ] 添加栈帧验证
- [ ] 实现调用上下文跟踪
- [ ] 集成测试

### 第3周：内存优化
- [ ] 实现StackFrameMemoryPool
- [ ] 添加性能监控
- [ ] 实现槽位优化
- [ ] 性能基准测试

### 第4周：调试和验证
- [ ] 实现变量访问跟踪
- [ ] 完善调试支持
- [ ] 扩展测试覆盖
- [ ] 文档完善

## 成功标准

### 功能完整性
- [ ] 栈帧创建和销毁正确
- [ ] 变量槽位分配优化
- [ ] 调用栈管理完善
- [ ] 内存管理高效

### 性能标准
- [ ] 栈帧创建时间<1μs
- [ ] 内存池命中率>80%
- [ ] 槽位分配算法高效
- [ ] 内存使用优化

### 质量标准
- [ ] 测试覆盖率≥95%
- [ ] 内存泄漏检测通过
- [ ] 性能基准达标
- [ ] 代码质量检查通过

---

*本设计制定时间：2025年12月7日*
*预计实施时间：4周*
*负责人：Claude Code*