# EP18 堆栈式虚拟机核心设计文档

## 概述

EP18是基于堆栈架构的独立虚拟机模块，采用堆栈指令集和优化的执行模型，专注于堆栈架构的教育价值。它是EP18R寄存器虚拟机的堆栈版本实现，使用操作数栈、局部变量区和调用栈的经典堆栈虚拟机模型，支持42条堆栈指令。

## 设计原则和规范符合性

EP18 虚拟机遵循以下核心设计原则和规范：

### 教育优先原则
- **清晰性**: 代码和架构设计优先考虑学习价值
- **可理解性**: 避免过度优化导致的复杂性
- **渐进式**: 支持从简单到复杂的渐进式学习路径

### 生产质量标准
- **全面测试**: 遵循测试驱动开发（TDD）方法，目标测试覆盖率 ≥95%
- **代码质量**: 遵循 OpenSpecKit 规范中的代码风格和架构标准
- **性能基准**: 关键指令执行性能达到纳秒级目标

### 规范符合性
EP18 实现严格遵循以下规范文档：
1. **EP18 OpenSpecKit 规范** - 定义架构和实现标准
2. **EP18 ABI 设计文档** - 定义应用程序二进制接口和调用约定
3. **EP18 TDD 重构优化方案** - 指导测试驱动重构过程

### 兼容性保证
- **向后兼容**: 保持与现有 EP18 代码的完全兼容性
- **ABI 稳定性**: 栈帧布局和调用约定保持稳定
- **迁移路径**: 提供从当前实现到完全符合规范的渐进迁移路径

## 目录
1. [设计原则和规范符合性](#设计原则和规范符合性)
2. [虚拟机架构设计](#2-虚拟机架构设计)
3. [堆栈指令集规范](#3-堆栈指令集规范)
4. [执行引擎设计](#4-执行引擎设计)
5. [栈帧管理策略](#5-栈帧管理策略)
6. [汇编器与反汇编器](#6-汇编器与反汇编器)
7. [内存管理与垃圾回收](#7-内存管理与垃圾回收)
8. [Struct统一设计](#8-struct统一设计)
9. [性能优化](#9-性能优化)
10. [调试支持](#10-调试支持)
11. [测试策略](#11-测试策略)

---

## 2. 虚拟机架构设计

### 2.1 整体架构

EP18采用堆栈架构，核心组件包括：

```
CymbolStackVM (主控制器)
├── BytecodeDefinition (指令集定义)
│   ├── 42条堆栈指令 (操作码1-42)
│   └── 三种指令格式 (S/I/M类型)
├── ByteCodeAssembler (汇编器)
│   ├── 前向引用处理
│   └── 指令编码生成
├── DisAssembler (反汇编器)
├── StackFrame (栈帧管理)
│   └── 调用栈支持 (最多1024层嵌套)
├── OperandStack (操作数栈)
│   └── 表达式求值支持
└── LabelSymbol (标签符号表)
```

### 2.2 运行时数据区域

#### 操作数栈（Operand Stack）
- **用途**: 表达式求值、参数传递、临时结果存储
- **大小**: 可配置（默认1024个槽位）
- **槽位**: 每个槽位32位，可存储整数、浮点或引用
- **操作**: LIFO（后进先出）语义，支持push/pop/peek

#### 局部变量区（Local Variables）
- **用途**: 存储方法的局部变量和参数
- **组织**: 每个栈帧独立的局部变量数组
- **索引**: 从0开始的连续整数索引
- **访问**: 通过load/store指令访问

#### 调用栈（Call Stack）
- **用途**: 存储活动栈帧，支持嵌套调用
- **深度**: 可配置（默认1024层）
- **栈帧**: 每个栈帧包含局部变量、操作数栈、返回地址

#### 堆内存（Heap Memory）
- **用途**: 动态分配对象（结构体、数组）
- **管理**: 垃圾回收器管理
- **访问**: 通过引用（对象指针）访问

#### 常量池（Constant Pool）
- **用途**: 存储编译期常量（字符串、浮点数等）
- **组织**: 只读数组，运行时通过索引访问
- **类型**: 支持整数、浮点、字符串常量

### 2.3 指令格式

所有指令均为32位固定长度，支持三种格式：

#### S类型（栈操作指令）
```
 31        26 25                                         0
┌────────────┬───────────────────────────────────────────┐
│   opcode   │                  unused                   │
│    (6)     │                  (26)                     │
└────────────┴───────────────────────────────────────────┘
```
- **用途**: 无操作数栈操作指令
- **示例**: `iadd`, `isub`, `imul`, `idiv`, `fadd`, `fsub`

#### I类型（立即数/索引操作）
```
 31        26 25                                         0
┌────────────┬───────────────────────────────────────────┐
│   opcode   │                operand                    │
│    (6)     │                  (26)                     │
└────────────┴───────────────────────────────────────────┘
```
- **用途**: 带立即数或索引的操作
- **示例**: `iconst`, `load`, `store`, `br`, `brt`, `brf`

#### M类型（内存/方法操作）
```
 31        26 25       13 12                             0
┌────────────┬───────────┬───────────────────────────────┐
│   opcode   │   index1  │            index2             │
│    (6)     │   (13)    │             (13)              │
└────────────┴───────────┴───────────────────────────────┘
```
- **用途**: 带两个索引的操作（如结构体字段访问）
- **示例**: `call`, `struct`, `fload`, `fstore`

### 2.4 函数调用机制

EP18采用**调用栈**机制，支持任意深度嵌套调用：

1. **调用者准备参数**: 将参数从左到右压入操作数栈
2. **执行`call target`指令**:
   - 将返回地址压入调用栈
   - 创建新栈帧，将参数复制到局部变量区
   - 跳转到目标函数地址
3. **被调用者执行**:
   - 执行函数体，使用局部变量和操作数栈
   - 函数执行结果压入操作数栈顶部
   - 执行`ret`指令，从调用栈弹出返回地址并跳转

#### 返回地址管理
- **调用栈**: `callStack[0..1023]`数组，每个元素包含返回地址
- **栈指针**: `framePointer`指向当前栈帧，初始为-1
- **兼容性**: 支持任意深度的函数嵌套调用

---

## 3. 堆栈指令集规范

### 3.1 操作码分配表

| 操作码 | 指令 | 格式 | 操作数 | 语义描述 |
|--------|------|------|--------|----------|
| 1 | iadd | S | - | 整数加法: b=pop(), a=pop(), push(a+b) |
| 2 | isub | S | - | 整数减法: b=pop(), a=pop(), push(a-b) |
| 3 | imul | S | - | 整数乘法: b=pop(), a=pop(), push(a*b) |
| 4 | idiv | S | - | 整数除法: b=pop(), a=pop(), push(a/b) |
| 5 | ilt | S | - | 整数小于: b=pop(), a=pop(), push(a<b?1:0) |
| 6 | ile | S | - | 整数小于等于: b=pop(), a=pop(), push(a≤b?1:0) |
| 7 | igt | S | - | 整数大于: b=pop(), a=pop(), push(a>b?1:0) |
| 8 | ige | S | - | 整数大于等于: b=pop(), a=pop(), push(a≥b?1:0) |
| 9 | ieq | S | - | 整数等于: b=pop(), a=pop(), push(a==b?1:0) |
| 10 | ine | S | - | 整数不等于: b=pop(), a=pop(), push(a!=b?1:0) |
| 11 | ineg | S | - | 整数取负: a=pop(), push(-a) |
| 12 | inot | S | - | 逻辑非: a=pop(), push(a==0?1:0) |
| 13 | iand | S | - | 按位与: b=pop(), a=pop(), push(a&b) |
| 14 | ior | S | - | 按位或: b=pop(), a=pop(), push(a\|b) |
| 15 | ixor | S | - | 按位异或: b=pop(), a=pop(), push(a^b) |
| 16 | fadd | S | - | 浮点加法: b=pop(), a=pop(), push(a+b) |
| 17 | fsub | S | - | 浮点减法: b=pop(), a=pop(), push(a-b) |
| 18 | fmul | S | - | 浮点乘法: b=pop(), a=pop(), push(a*b) |
| 19 | fdiv | S | - | 浮点除法: b=pop(), a=pop(), push(a/b) |
| 20 | flt | S | - | 浮点小于: b=pop(), a=pop(), push(a<b?1:0) |
| 21 | feq | S | - | 浮点等于: b=pop(), a=pop(), push(a==b?1:0) |
| 22 | itof | S | - | 整数转浮点: a=pop(), push((float)a) |
| 23 | call | I | immediate | 函数调用: 保存返回地址；PC = target |
| 24 | ret | S | - | 函数返回: 从调用栈弹出返回地址；PC = 返回地址 |
| 25 | br | I | immediate | 无条件跳转: PC = target |
| 26 | brt | I | immediate | 条件为真跳转: if (pop() != 0) PC = target |
| 27 | brf | I | immediate | 条件为假跳转: if (pop() == 0) PC = target |
| 28 | cconst | I | immediate | 加载字符常量: push(constant) |
| 29 | iconst | I | immediate | 加载整数常量: push(constant) |
| 30 | fconst | I | pool_index | 加载浮点常量: push(pool[pool_index]) |
| 31 | sconst | I | pool_index | 加载字符串常量: push(pool[pool_index]) |
| 32 | load | I | index | 加载局部变量: push(locals[index]) |
| 33 | gload | I | offset | 全局加载: push(heap[GBASE+offset]) |
| 34 | fload | I | offset | 字段加载: structRef=pop(), push(structRef[offset]) |
| 35 | store | I | index | 存储局部变量: value=pop(), locals[index]=value |
| 36 | gstore | I | offset | 全局存储: value=pop(), heap[GBASE+offset]=value |
| 37 | fstore | I | offset | 字段存储: value=pop(), structRef=pop(), structRef[offset]=value |
| 38 | print | S | - | 打印栈顶值: print(pop()) |
| 39 | struct | I | size | 分配结构体: push(allocate_struct(size)) |
| 40 | null | S | - | 加载空指针: push(0) |
| 41 | pop | S | - | 弹出栈顶值: pop() |
| 42 | halt | S | - | 停止执行 |

### 3.2 重要修复记录

#### 结构体统一实现修复（2025-12-18）
**问题**: CymbolStackVM和VMInterpreter使用不同的结构体表示

**修复**: 创建`StructValue`作为统一运行时表示：
```java
public class StructValue {
    private final Object[] fields;
    private StructType type;

    public StructValue(int fieldCount) {
        this.fields = new Object[fieldCount];
        this.type = null;
    }

    // 基于偏移量的访问（保持兼容性）
    public Object getField(int offset) {
        return fields[offset];
    }

    public void setField(int offset, Object value) {
        fields[offset] = value;
    }
}
```

#### 前向引用处理增强
**问题**: 汇编器需要处理前向引用（标签或函数在引用时尚未定义）

**解决方案**:
- 在`LabelSymbol`中记录前向引用及指令类型
- I类型：修补低26位操作数字段
- M类型：修补两个13位索引字段
- 函数定义时自动创建同名标签，解析所有前向引用

---

## 4. 执行引擎设计

### 4.1 核心组件

- **CymbolStackVM**: 虚拟机主类，协调各组件，管理执行状态
  - 负责取指、解码、执行循环
  - 管理调用栈 (`callStack[0..1023]`)
  - 管理操作数栈和局部变量
  - 包含 `StackFrame[] callStack` 字段和 `int framePointer`

### 3.2 执行循环

```java
while (running) {
    // 1. 检查调试器（断点、单步）
    checkDebugger();

    // 2. 取指
    int instruction = fetchInstruction(programCounter);

    // 3. 解码
    InstructionInfo info = decodeInstruction(instruction);

    // 4. 执行前检查（权限、资源）
    if (!preExecuteCheck(info)) {
        handleExecutionError(info);
        continue;
    }

    // 5. 执行指令
    executeInstruction(info);

    // 6. 更新程序计数器（除非跳转指令已修改）
    updateProgramCounter(info);

    // 7. 更新统计信息
    updateStatistics(info);

    // 8. 检查停止条件
    if (shouldHalt()) {
        running = false;
    }
}
```

### 3.3 指令处理流水线

#### 阶段1：取指 (Fetch)
- 从指令缓存读取32位指令
- 指令缓存大小可配置（默认1024条指令）
- 支持指令预取，减少内存访问延迟

#### 阶段2：解码 (Decode)
- 解析操作码（bits[31:26]）
- 根据指令格式解析操作数
  - S类型：无操作数
  - I类型：26位操作数（符号扩展）
  - M类型：两个13位索引
- 符号扩展立即数（26位→32位）

#### 阶段3：执行 (Execute)
- **栈操作**: 访问操作数栈，执行push/pop/arithmetic操作
- **内存访问**: 计算有效地址，加载/存储数据
- **控制流**: 更新程序计数器，处理跳转
- **特殊操作**: 函数调用、系统调用、调试操作

#### 阶段4：写回 (Writeback)
- 将结果写回操作数栈（如果需要）
- 更新局部变量（store指令）
- 更新堆内存（gstore/fstore指令）

### 3.4 程序计数器管理

#### 跳转标志机制
```java
private boolean didJump = false;

// 在cpu()循环中：
if (!didJump) {
    programCounter++;  // 只有在没有跳转的情况下才自动增加PC
}
didJump = false; // 重置跳转标志
```

#### 循环检测机制
```java
// 循环检测和安全机制
private static final int MAX_EXECUTION_STEPS = 1000000; // 最大执行步数
private int executionSteps = 0;

// 在cpu()循环中：
if (executionSteps++ > MAX_EXECUTION_STEPS) {
    throw new RuntimeException("Maximum execution steps exceeded. Possible infinite loop detected at PC=" + programCounter);
}
```

### 3.5 异常处理机制

#### 异常类型
| 异常码 | 异常名称 | 触发条件 |
|--------|----------|----------|
| 1 | 非法操作码 | 操作码不在1-42范围内 |
| 2 | 栈溢出 | 操作数栈超出容量 |
| 3 | 栈下溢 | 操作数栈为空时执行pop |
| 4 | 除零错误 | 整数除法除数为0 |
| 5 | 内存越界 | 访问地址超出有效内存范围 |
| 6 | 空指针访问 | 访问空指针指向的内存 |
| 7 | 局部变量越界 | 局部变量索引超出范围 |

#### 异常处理流程
1. **异常检测**: 在执行阶段检测异常条件
2. **异常触发**: 设置异常码和异常PC
3. **上下文保存**: 保存当前栈帧状态
4. **异常分发**: 根据异常码调用对应处理例程
5. **恢复或终止**: 尝试恢复执行或终止虚拟机

---

## 5. 栈帧管理策略

### 5.1 栈帧布局

#### 栈帧结构
```
栈帧结构（栈增长方向：高地址 → 低地址）
┌─────────────────┐ 高地址
│   调用者栈帧     │
├─────────────────┤ ← 调用者栈帧结束
│   返回地址       │   （存储在调用栈中）
├─────────────────┤
│   动态链接       │   （指向调用者栈帧）
├─────────────────┤
│   局部变量区     │   locals[0..n-1]
│   ┌───────────┐ │
│   │ 参数m-1   │ │   ← 参数存储区
│   │   ...     │ │
│   │ 参数0     │ │
│   ├───────────┤ │
│   │ 局部变量k  │ │   ← 局部变量存储区
│   │   ...     │ │
│   │ 局部变量0  │ │
│   └───────────┘ │
├─────────────────┤
│   操作数栈       │   operandStack[0..s-1]
│   ┌───────────┐ │
│   │    ...    │ │
│   │ 栈顶元素   │ │ ← stackTop
│   │    ...    │ │
│   │ 栈底元素   │ │
│   └───────────┘ │
└─────────────────┘ 低地址 ← 当前栈帧基址
```

### 4.2 栈帧大小计算

```
栈帧大小 = 局部变量区 + 操作数栈区 + 固定开销 + 对齐填充

其中：
- 固定开销: 返回地址 + 动态链接 = 8字节
- 局部变量区: (num_args + num_locals) * 4字节
- 操作数栈区: max_stack * 4字节
- 对齐填充: 确保栈帧大小是8字节的倍数
```

### 4.3 栈帧分配和释放

#### 函数序言（Prologue）
```java
// 分配栈帧
public void allocateFrame(int localVarSize, int operandStackSize) {
    // 计算总大小（考虑对齐）
    int frameSize = calculateFrameSize(localVarSize, operandStackSize);

    // 检查栈空间是否足够
    if (framePointer >= callStack.length - 1) {
        throw new StackOverflowError("Call stack overflow");
    }

    // 创建新栈帧
    StackFrame frame = new StackFrame(frameSize, localVarSize, operandStackSize);
    callStack[++framePointer] = frame;

    // 初始化局部变量（参数从操作数栈复制）
    copyParametersToLocals();
}
```

#### 函数尾声（Epilogue）
```java
// 释放栈帧
public void deallocateFrame() {
    if (framePointer < 0) {
        throw new IllegalStateException("No active frame to deallocate");
    }

    // 保存返回值（如果有）
    Object returnValue = null;
    if (!operandStack.isEmpty()) {
        returnValue = operandStack.peek();
    }

    // 释放当前栈帧
    callStack[framePointer--] = null;

    // 恢复返回值到调用者操作数栈
    if (returnValue != null) {
        operandStack.push(returnValue);
    }
}
```

### 4.4 栈帧访问优化

#### 局部变量访问优化
- **直接索引访问**: 局部变量通过数组索引直接访问
- **缓存友好布局**: 常用局部变量放在低索引位置
- **逃逸分析**: 识别不需要在堆上分配的对象

#### 操作数栈访问优化
- **栈内联**: 将常用栈操作内联到调用者
- **栈缓存**: 为栈顶元素提供快速访问路径
- **栈合并**: 合并连续的栈操作

---

## 6. 汇编器与反汇编器

### 6.1 汇编器设计

#### 整体架构
```
汇编代码 (.asm文件)
    ↓
汇编器 (ByteCodeAssembler) - 集成式实现
    ├── 词法分析 (ANTLR4 VMAssemblerLexer)
    ├── 语法分析 (ANTLR4 VMAssemblerParser)
    ├── 语义检查（集成在汇编器内）
    ├── 代码生成（集成在汇编器内）
    └── 错误报告（基础错误检查）
    ↓
堆栈字节码 (.vm文件)
```

#### 汇编语言语法

##### 语法文件结构
```antlr4
grammar VMAssembler;

program
    :   (globalVariable | globals)?
        (functionDeclaration | instr | label | NEWLINE)+
    ;

// 全局变量声明
globalVariable : '.global' type=ID name=ID NEWLINE;

// 全局数据空间声明
globals : NEWLINE* '.globals' intVal=INT NEWLINE;

// 函数声明
functionDeclaration
    :   '.def' name=ID ':' 'args' '=' a=INT ',' 'locals' '=' lo=INT ',' 'stack' '=' s=INT NEWLINE
    ;

// 指令
instr
    :   op=ID NEWLINE
    |   op=ID operand=INT NEWLINE
    |   op=ID operand1=INT ',' operand2=INT NEWLINE
    ;
```

##### 汇编程序示例
```assembly
# 简单堆栈汇编程序示例
.globals 1024

.def main: args=0, locals=1, stack=2
    iconst 10          # 加载立即数10到栈
    iconst 20          # 加载立即数20到栈
    iadd               # 栈顶两个值相加
    print              # 打印栈顶值
    halt               # 停止执行

.def add_func: args=2, locals=0, stack=2
    load 0             # 加载第一个参数
    load 1             # 加载第二个参数
    iadd               # 相加
    ret                # 返回，结果在栈顶
```

### 6.2 反汇编器设计

#### 反汇编流程
1. **字节码解析**: 读取头部、解析常量池、解析代码段
2. **指令解码**: 指令识别、操作数解码、符号解析
3. **文本生成**: 指令格式化、标签生成、注释添加
4. **输出生成**: 文件写入、格式美化、交叉引用

#### 核心类设计
```java
public class DisAssembler {
    // 反汇编入口方法
    public String disassemble(byte[] bytecode) {
        StringBuilder output = new StringBuilder();

        // 1. 解析字节码结构
        BytecodeParser parser = new BytecodeParser(bytecode);
        BytecodeStructure structure = parser.parse();

        // 2. 反汇编指令
        InstructionDecoder decoder = new InstructionDecoder();
        for (Instruction instruction : structure.getInstructions()) {
            String asm = decoder.decode(instruction);
            output.append(asm).append("\n");
        }

        // 3. 添加头部和常量池信息
        addHeaderInfo(output, structure);
        addConstantPool(output, structure);

        return output.toString();
    }
}
```

#### 指令解码器
```java
public class InstructionDecoder {
    // 解码单个指令
    public String decode(Instruction instruction) {
        int opcode = instruction.getOpcode();
        InstructionInfo info = BytecodeDefinition.getInstruction(opcode);

        if (info == null) {
            return String.format(".word 0x%08x  # 未知指令",
                instruction.getEncoding());
        }

        // 根据指令格式解码操作数
        switch (info.getFormat()) {
            case FORMAT_S:
                return decodeSType(instruction, info);
            case FORMAT_I:
                return decodeIType(instruction, info);
            case FORMAT_M:
                return decodeMType(instruction, info);
            default:
                return info.getName();
        }
    }
}
```

---

## 7. 内存管理与垃圾回收

### 7.1 内存布局

```
0x00000000 ┌─────────────────┐
           │   代码区        │ 存储字节码指令
0x10000000 ├─────────────────┤
           │   常量池        │ 存储浮点、字符串常量
0x20000000 ├─────────────────┤
           │   全局数据区    │ 存储全局变量
0x30000000 ├─────────────────┤
           │   堆区          │ 动态分配内存（结构体）
0x40000000 ├─────────────────┤
           │   栈区          │ 函数调用栈（向下增长）
0x50000000 └─────────────────┘
```

### 7.2 垃圾回收架构

#### 总体架构
```
GarbageCollector (接口)
├── ReferenceCountingGC (引用计数GC)
├── MarkSweepGC (标记-清除GC)
├── IncrementalGC (增量GC)
└── GenerationalGC (分代GC)
```

#### 核心接口设计

##### GC对象接口
```java
public interface GCObject {
    // 引用计数管理
    int getRefCount();
    void incrementRef();
    void decrementRef();

    // 标记支持
    boolean isMarked();
    void setMarked(boolean marked);

    // 清理回调
    void onGC();
}
```

##### 垃圾回收器接口
```java
public interface GarbageCollector {
    // 对象分配
    int allocate(int size);
    int allocateObject(ObjectData data);

    // 引用管理
    void incrementRef(int objectId);
    void decrementRef(int objectId);

    // 垃圾回收
    void collect();
    void collect(GCTypes.CollectionType type);

    // 统计信息
    GCStatistics getStatistics();
    GCHeapInfo getHeapInfo();

    // 配置
    void setConfig(GCConfig config);
    GCConfig getConfig();
}
```

### 7.3 引用计数GC实现

#### 核心设计
```java
public class ReferenceCountingGC implements GarbageCollector {
    // 堆管理
    private final byte[] heap;
    private int heapSize;
    private int heapUsed;

    // 对象管理
    private final Map<Integer, GCObjectHeader> objects;
    private final AtomicInteger nextObjectId;
    private final Queue<Integer> freeObjectIds;

    // 循环引用检测
    private final CycleDetector cycleDetector;
    private final Set<Integer> markedForCollection;

    // 统计信息
    private final GCStatistics statistics;
}
```

#### 对象头结构
```java
public class GCObjectHeader {
    // 基本信息
    public final int objectId;
    public final int size;
    public final GCObjectType type;

    // 引用计数
    public volatile int refCount;

    // 标记信息
    public volatile boolean marked;
    public volatile boolean inCycle;

    // 链接信息
    public GCObjectHeader next;
    public int forwardAddress;
}
```

---

## 8. Struct统一设计

### 8.1 问题背景

EP18模块存在两个不同的struct实现：
1. `CymbolStackVM` - 使用int[]堆存储struct，每个字段一个整数槽位
2. `VMInterpreter` - 使用`StructSpace`对象（Object[] fields）存储struct

### 8.2 统一设计目标

1. **统一内存表示**: 建立一致的struct内存模型
2. **保持向后兼容**: 现有测试必须全部通过
3. **增强类型安全**: 添加字段类型信息
4. **支持嵌套struct**: 允许struct包含其他struct
5. **实现字段映射**: 支持字段名到偏移的映射

### 8.3 技术方案

采用**统一运行时表示**模式，创建`StructValue`作为ep18中结构体的唯一运行时表示：

```
统一结构体运行时表示（StructValue）
        │
        ├── CymbolStackVM适配层（结构体ID映射）
        │       └── 保持int[]栈和堆，内部使用StructValue表
        │
        └── VMInterpreter适配层（直接对象引用）
                └── 保持Object[]操作数栈，直接使用StructValue
```

### 8.4 StructValue设计

```java
public class StructValue {
    private final Object[] fields;
    private StructType type;  // 初始可为null，阶段2填充类型信息

    public StructValue(int fieldCount) {
        this.fields = new Object[fieldCount];
        this.type = null;
    }

    public StructValue(StructType type) {
        this.type = type;
        this.fields = new Object[type.getFieldCount()];
    }

    // 基于偏移量的访问（保持兼容性）
    public Object getField(int offset) {
        return fields[offset];
    }

    public void setField(int offset, Object value) {
        fields[offset] = value;
    }

    // 基于字段名的访问（未来扩展）
    public Object getField(String name) {
        if (type == null) throw new IllegalStateException("No type information");
        Integer offset = type.getFieldOffset(name);
        return fields[offset];
    }
}
```

### 8.5 实现步骤

#### 阶段1：统一结构体表示（3-4天）
**目标**: 创建StructValue作为统一运行时表示

1. **创建StructValue类**
2. **修改VMInterpreter使用StructValue**
3. **修改CymbolStackVM适配StructValue**
4. **统一测试验证**

#### 阶段2：集成类型系统（2-3天）
**目标**: 引入类型信息，为类型安全做准备

1. **复制类型系统组件**
2. **增强ByteCodeAssembler**
3. **增强StructValue类型感知**
4. **测试类型系统集成**

#### 阶段3：功能增强（2-3天）
**目标**: 实现类型安全、嵌套支持和字段映射

1. **类型安全字段访问**
2. **嵌套结构体支持**
3. **字段名映射支持**
4. **全面测试**

---

## 9. 性能优化

### 9.1 指令缓存
- **缓存大小**: 可配置（默认1024条指令）
- **缓存策略**: 直接映射缓存
- **缓存失效**: 当PC跳转到缓存外地址时失效

### 9.2 热点检测
- 统计指令执行频率
- 识别热点代码段（循环、频繁调用函数）
- 为JIT编译做准备（未来扩展）

### 9.3 栈操作优化
- **栈顶缓存**: 将栈顶元素缓存在寄存器中
- **操作合并**: 合并连续的栈操作
- **内联展开**: 将小函数内联到调用者

### 9.4 内存访问优化
- **局部性优化**: 提高内存访问局部性
- **预取优化**: 预取可能访问的内存
- **对齐优化**: 确保内存访问对齐

---

## 10. 调试支持

### 10.1 断点管理
- 支持代码地址断点
- 支持条件断点（栈值条件）
- 断点命中时暂停执行，进入调试模式

### 9.2 单步执行
- 支持指令级单步执行
- 支持函数级单步执行（step over/into/out）
- 单步执行时显示栈状态变化

### 9.3 执行跟踪
- 记录指令执行历史
- 记录栈值变化历史
- 记录内存访问历史
- 支持回放执行轨迹

### 9.4 调试接口
```java
public interface Debugger {
    // 断点操作
    void setBreakpoint(int address);
    void clearBreakpoint(int address);

    // 执行控制
    void step();        // 单步执行
    void continue();    // 继续执行
    void pause();       // 暂停执行

    // 状态查询
    StackSnapshot getStackSnapshot();
    MemorySnapshot getMemory(int address, int size);
    StackTrace getStackTrace();

    // 跟踪控制
    void startTrace();
    ExecutionTrace stopTrace();
}
```

---

## 11. 测试策略

### 11.1 单元测试
- 指令解码正确性测试
- 指令执行正确性测试
- 栈操作功能测试
- 内存管理功能测试

### 11.2 集成测试
- 完整程序执行测试
- 函数调用测试
- 异常处理测试
- 调试功能测试

### 11.3 性能测试
- 指令执行速度基准测试
- 内存访问性能测试
- 与寄存器虚拟机的性能对比

### 11.4 验证结果
- **CymbolStackVMTest**: 测试通过 ✅
- **VMInterpreterTest**: 测试通过 ✅
- **GarbageCollectorTest**: 测试通过 ✅

---

## 12. 附录

### 12.1 相关源文件
- `CymbolStackVM.java`: 虚拟机主类
- `BytecodeDefinition.java`: 指令集定义
- `ByteCodeAssembler.java`: 汇编器
- `DisAssembler.java`: 反汇编器
- `StackFrame.java`: 栈帧实现
- `OperandStack.java`: 操作数栈实现
- `LabelSymbol.java`: 标签符号表

### 12.2 配置参数
- `stackSize`: 操作数栈大小（默认1024槽位）
- `callStackSize`: 调用栈大小（默认1024层）
- `heapSize`: 堆大小（默认131072字节）
- `instructionCacheSize`: 指令缓存大小（默认1024条）
- `maxSteps`: 最大执行步骤（默认1000000）

### 12.3 性能调优建议
1. 调整栈大小以匹配工作集
2. 使用栈顶缓存减少栈操作开销
3. 优化热点代码的指令序列
4. 合理设置堆和栈大小，避免频繁扩展

---

## 13. 文档索引和维护说明

### 13.1 文档体系结构

EP18模块采用分层文档架构，确保设计规范、实现方案和测试策略的一致性：

```
ep18/docs/
├── EP18_核心设计文档.md         # 本文档：总体架构和设计概述
├── EP18_OpenSpecKit_Specification.md  # 规范标准：架构和实现规范
├── EP18_ABI_设计文档.md         # ABI规范：调用约定和二进制接口
└── EP18_TDD_重构优化方案.md     # 重构方案：测试驱动重构计划
```

### 13.2 文档依赖关系

1. **EP18_OpenSpecKit_Specification.md** - 最高层规范
   - 定义架构标准、命名约定、质量要求
   - 所有其他文档必须符合此规范

2. **EP18_ABI_设计文档.md** - 二进制接口规范
   - 定义栈帧布局、参数传递、返回值约定
   - VM实现必须严格遵循ABI规范

3. **EP18_TDD_重构优化方案.md** - 实施计划
   - 指导测试驱动重构过程
   - 确保重构符合OpenSpecKit和ABI规范

4. **EP18_核心设计文档.md** - 技术实现
   - 详细的技术实现说明
   - 必须与上述三个规范保持一致

### 13.3 文档维护规则

1. **同步更新**: 任何设计变更必须同步更新所有相关文档
2. **版本控制**: 文档版本与代码版本保持一致
3. **变更记录**: 重大变更需在变更日志中记录
4. **一致性检查**: 定期检查文档间的一致性

### 13.4 变更日志

| 版本 | 日期 | 主要变更 |
|------|------|----------|
| v1.0 | 2025-12-19 | 初始版本：完整的核心设计文档 |
| v1.1 | 2025-12-19 | 文档整合：添加文档索引和维护说明 |

---

**文档版本**: v1.1
**最后更新**: 2025-12-19
**制定者**: Claude Code
**相关文档**:
- EP18_OpenSpecKit_Specification.md - OpenSpecKit规范标准
- EP18_ABI_设计文档.md - 应用程序二进制接口规范
- EP18_TDD_重构优化方案.md - 测试驱动重构计划

**维护要求**:
- 本文档与上述三个规范文档共同构成EP18完整设计规范
- 任何设计变更必须同步更新所有相关文档
- 详细的实现参考代码见`ep18/src/main/java/org/teachfx/antlr4/ep18/`