# EP21 Cymbol è¯­è¨€è§„èŒƒ

**ç‰ˆæœ¬**: 2.0.0 (EP21 Edition)
**å‘å¸ƒæ—¥æœŸ**: 2025-12-21
**åŸºäº**: Cymbol 1.0 (EP20) æ‰©å±•
**çŠ¶æ€**: æ­£å¼å‘å¸ƒ (Released)

## ğŸ“œ è§„èŒƒå£°æ˜

### 1.1 è§„èŒƒæ€§è´¨

æœ¬è§„èŒƒæ˜¯Cymbolç¼–ç¨‹è¯­è¨€çš„æƒå¨å®šä¹‰æ–‡æ¡£ï¼Œè§„å®šäº†EP21ç‰ˆæœ¬çš„è¯­è¨€è¯­æ³•ã€è¯­ä¹‰å’Œæ ‡å‡†åº“ã€‚æ‰€æœ‰Cymbolç¼–è¯‘å™¨å¿…é¡»éµå¾ªæœ¬è§„èŒƒã€‚

### 1.2 è§„èŒƒä¼˜å…ˆçº§

1. **é¦–è¦åŸåˆ™**: æœ¬è§„èŒƒä¼˜å…ˆçº§é«˜äºæ‰€æœ‰å®ç°
2. **ä¸€è‡´æ€§è¦æ±‚**: æ‰€æœ‰å®ç°å¿…é¡»ä¸æœ¬è§„èŒƒä¿æŒä¸€è‡´
3. **æ‰©å±•é™åˆ¶**: å®ç°å¯ä»¥æ‰©å±•ï¼Œä½†ä¸èƒ½è¿åæœ¬è§„èŒƒ

### 1.3 ç›®æ ‡è¯»è€…

- ç¼–è¯‘å™¨å®ç°è€…
- è¯­è¨€å­¦ä¹ è€…
- å·¥å…·å¼€å‘è€…
- æ•™è‚²å·¥ä½œè€…

---

## 2. è¯­è¨€æ¦‚è§ˆ

### 2.1 è®¾è®¡å“²å­¦

Cymbolæ˜¯ä¸€ç§**æ•™è‚²å¯¼å‘çš„é™æ€ç±»å‹è¯­è¨€**ï¼Œè®¾è®¡ç›®æ ‡æ˜¯ï¼š

1. **ç®€æ´æ€§**: è¯­æ³•ç®€æ´ï¼Œæ˜“äºå­¦ä¹ å’Œç†è§£
2. **è¡¨è¾¾åŠ›**: æ”¯æŒç°ä»£ç¼–ç¨‹èŒƒå¼
3. **å®‰å…¨æ€§**: é™æ€ç±»å‹ç³»ç»Ÿç¡®ä¿ç±»å‹å®‰å…¨
4. **å¯æ‰©å±•æ€§**: æ”¯æŒè¯­è¨€ç‰¹æ€§å’Œåº“çš„æ‰©å±•
5. **æ•™è‚²ä»·å€¼**: é€‚åˆç¼–è¯‘åŸç†æ•™å­¦

### 2.2 è¯­è¨€ç‰¹æ€§çŸ©é˜µ

| ç‰¹æ€§ç±»åˆ« | æ”¯æŒç¨‹åº¦ | EP21æ–°å¢ |
|----------|----------|----------|
| **åŸºæœ¬ç±»å‹** | å®Œå…¨æ”¯æŒ | å¢å¼ºç±»å‹æ¨æ–­ |
| **å¤åˆç±»å‹** | éƒ¨åˆ†æ”¯æŒ | ç»“æ„ä½“ã€æ•°ç»„ |
| **æ§åˆ¶æµ** | å®Œå…¨æ”¯æŒ | æ¨¡å¼åŒ¹é…(å®éªŒæ€§) |
| **å‡½æ•°å¼** | åŸºç¡€æ”¯æŒ | Lambdaè¡¨è¾¾å¼ |
| **é¢å‘å¯¹è±¡** | ä¸æ”¯æŒ | - |
| **å¹¶å‘** | ä¸æ”¯æŒ | - |
| **å…ƒç¼–ç¨‹** | ä¸æ”¯æŒ | - |

### 2.3 ç¤ºä¾‹ç¨‹åº

```cymbol
// Hello World ç¨‹åº
import std.io;

int main() {
    print("Hello, Cymbol World!");
    return 0;
}

// æ–æ³¢é‚£å¥‘æ•°åˆ—ç¤ºä¾‹
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// ç»“æ„ä½“ç¤ºä¾‹
struct Point {
    float x;
    float y;
}

Point create_point(float x, float y) {
    Point p = {x: x, y: y};
    return p;
}
```

---

## 3. è¯æ³•è§„èŒƒ

### 3.1 å­—ç¬¦é›†

Cymbolä½¿ç”¨**UTF-8ç¼–ç **ï¼Œæ”¯æŒä»¥ä¸‹å­—ç¬¦é›†ï¼š

```ebnf
CharSet ::= BasicLatin | IdentifierChars
BasicLatin ::= [\u0000-\u007F]  -- ASCIIå­—ç¬¦
IdentifierChars ::= [\p{L}\p{Nl}\p{Mn}\p{Mc}\p{Pc}]  -- Unicodeæ ‡è¯†ç¬¦å­—ç¬¦
```

### 3.2 è¯æ³•å•å…ƒ

#### 3.2.1 æ ‡è¯†ç¬¦

```ebnf
Identifier ::= IdentifierStart IdentifierPart*
IdentifierStart ::= Letter | '_'
IdentifierPart ::= Letter | Digit | '_'

Letter ::= [A-Za-z]
Digit ::= [0-9]
```

**å‘½åçº¦å®š**:
- å˜é‡å: `camelCase` (å°å†™å¼€å¤´)
- å‡½æ•°å: `camelCase` (å°å†™å¼€å¤´)
- ç±»å‹å: `PascalCase` (å¤§å†™å¼€å¤´)
- å¸¸é‡å: `UPPER_SNAKE_CASE`

#### 3.2.2 å­—é¢é‡

##### æ•´æ•°å­—é¢é‡
```ebnf
IntegerLiteral ::= DecimalLiteral | HexadecimalLiteral | BinaryLiteral
DecimalLiteral ::= [1-9][0-9]* | '0'
HexadecimalLiteral ::= '0' [xX] HexDigit+
BinaryLiteral ::= '0' [bB] [01]+
HexDigit ::= [0-9a-fA-F]
```

##### æµ®ç‚¹æ•°å­—é¢é‡
```ebnf
FloatLiteral ::= DecimalFloat | HexadecimalFloat
DecimalFloat ::= [0-9]* '.' [0-9]+ Exponent?
Exponent ::= [eE] [+-]? [0-9]+
HexadecimalFloat ::= '0' [xX] HexDigit* '.' HexDigit+ BinaryExponent
BinaryExponent ::= [pP] [+-]? [0-9]+
```

##### å¸ƒå°”å­—é¢é‡
```ebnf
BooleanLiteral ::= 'true' | 'false'
```

##### å­—ç¬¦å­—é¢é‡
```ebnf
CharLiteral ::= "'" (EscapeSequence | ~['\\\n\r]) "'"
EscapeSequence ::= '\' [nrt0'"\\]
```

##### å­—ç¬¦ä¸²å­—é¢é‡
```ebnf
StringLiteral ::= '"' (EscapeSequence | ~["\\\n\r])* '"'
```

### 3.3 å…³é”®å­—

#### 3.3.1 ä¿ç•™å…³é”®å­— (33ä¸ª)
```
// ç±»å‹å£°æ˜
int       float     bool      string    void      object
struct    enum      type      var       let       const

// æ§åˆ¶æµ
if        else      while     for       do        switch
case      default   break     continue  return    goto

// å‡½æ•°å’Œæ¨¡å—
function  import    export    from      as

// å…¶ä»–
null      true      false     sizeof    typeof    cast
```

#### 3.3.2 ä¸Šä¸‹æ–‡å…³é”®å­— (5ä¸ª)
```
where     using     async     await     yield
```

### 3.4 æ“ä½œç¬¦

#### 3.4.1 æ“ä½œç¬¦ä¼˜å…ˆçº§è¡¨ (ä»é«˜åˆ°ä½)

| ä¼˜å…ˆçº§ | æ“ä½œç¬¦ | æè¿° | ç»“åˆæ€§ |
|--------|--------|------|--------|
| 1 | `()` `[]` `.` `->` | å‡½æ•°è°ƒç”¨ã€ä¸‹æ ‡ã€æˆå‘˜è®¿é—® | å·¦ç»“åˆ |
| 2 | `++` `--` `+` `-` `!` `~` `*` `&` `sizeof` `typeof` | å‰ç¼€è‡ªå¢ã€ä¸€å…ƒè¿ç®— | å³ç»“åˆ |
| 3 | `*` `/` `%` | ä¹˜é™¤å–æ¨¡ | å·¦ç»“åˆ |
| 4 | `+` `-` | åŠ å‡ | å·¦ç»“åˆ |
| 5 | `<<` `>>` | ä½ç§» | å·¦ç»“åˆ |
| 6 | `<` `<=` `>` `>=` | å…³ç³»æ¯”è¾ƒ | å·¦ç»“åˆ |
| 7 | `==` `!=` | ç›¸ç­‰æ¯”è¾ƒ | å·¦ç»“åˆ |
| 8 | `&` | ä½ä¸ | å·¦ç»“åˆ |
| 9 | `^` | ä½å¼‚æˆ– | å·¦ç»“åˆ |
| 10 | `\|` | ä½æˆ– | å·¦ç»“åˆ |
| 11 | `&&` | é€»è¾‘ä¸ | å·¦ç»“åˆ |
| 12 | `\|\|` | é€»è¾‘æˆ– | å·¦ç»“åˆ |
| 13 | `?:` | æ¡ä»¶è¿ç®—ç¬¦ | å³ç»“åˆ |
| 14 | `=` `+=` `-=` `*=` `/=` `%=` `<<=` `>>=` `&=` `^=` `\|=` | èµ‹å€¼ | å³ç»“åˆ |
| 15 | `,` | é€—å· | å·¦ç»“åˆ |

#### 3.4.2 æ“ä½œç¬¦é‡è½½è§„åˆ™
1. **ä¸å¯é‡è½½æ“ä½œç¬¦**: `.` `::` `?:` `sizeof` `typeof` `cast`
2. **å¯é‡è½½æ“ä½œç¬¦**: `+` `-` `*` `/` `%` `==` `!=` `<` `>` `<=` `>=`
3. **é‡è½½è¦æ±‚**: å¿…é¡»ä¿æŒæ“ä½œç¬¦çš„åŸå§‹è¯­ä¹‰

---

## 4. è¯­æ³•è§„èŒƒ

### 4.1 ç¨‹åºç»“æ„

#### 4.1.1 ç¼–è¯‘å•å…ƒ
```ebnf
CompilationUnit ::= (ImportDeclaration | TypeDeclaration | FunctionDeclaration)*

ImportDeclaration ::= 'import' ModulePath ('as' Identifier)? ';'
ModulePath ::= Identifier ('.' Identifier)*

TypeDeclaration ::= StructDeclaration | EnumDeclaration | TypeAlias
FunctionDeclaration ::= FunctionSignature FunctionBody
```

#### 4.1.2 æ¨¡å—ç³»ç»Ÿ
```ebnf
Module ::= CompilationUnit
ModulePath ::= Identifier ('.' Identifier)*

// å¯¼å…¥ç¤ºä¾‹
import std.io;           // å¯¼å…¥æ ‡å‡†åº“ioæ¨¡å—
import math as m;        // é‡å‘½åå¯¼å…¥
import utils.{max, min}; // é€‰æ‹©æ€§å¯¼å…¥
```

### 4.2 ç±»å‹ç³»ç»Ÿ

#### 4.2.1 åŸºæœ¬ç±»å‹
```ebnf
BasicType ::= 'int' | 'float' | 'bool' | 'string' | 'void' | 'object'

// ç±»å‹å­—é¢é‡
Type ::= BasicType
       | Identifier  -- ç”¨æˆ·å®šä¹‰ç±»å‹
       | PointerType
       | ArrayType
       | FunctionType
       | '(' Type ')'  -- æ‹¬å·ç±»å‹

PointerType ::= Type '*'
ArrayType ::= Type '[' IntegerLiteral? ']'
FunctionType ::= '(' TypeList? ')' '->' Type
TypeList ::= Type (',' Type)*
```

#### 4.2.2 ç»“æ„ä½“ç±»å‹
```ebnf
StructDeclaration ::= 'struct' Identifier '{' FieldDeclaration* '}'
FieldDeclaration ::= Type Identifier ('=' Expression)? ';'
```

#### 4.2.3 æšä¸¾ç±»å‹
```ebnf
EnumDeclaration ::= 'enum' Identifier '{' EnumVariant (',' EnumVariant)* '}'
EnumVariant ::= Identifier ('=' Expression)?
```

### 4.3 å£°æ˜

#### 4.3.1 å˜é‡å£°æ˜
```ebnf
VariableDeclaration ::= ('let' | 'var' | 'const') Identifier (':' Type)? ('=' Expression)? ';'

// ç¤ºä¾‹
let x: int = 42;           // ä¸å¯å˜å˜é‡
var y: float = 3.14;       // å¯å˜å˜é‡
const PI = 3.14159;        // ç¼–è¯‘æ—¶å¸¸é‡
```

#### 4.3.2 å‡½æ•°å£°æ˜
```ebnf
FunctionSignature ::= 'function' Identifier '(' ParameterList? ')' (':' Type)?
ParameterList ::= Parameter (',' Parameter)*
Parameter ::= Identifier ':' Type

FunctionBody ::= BlockStatement | ';'  -- åˆ†å·è¡¨ç¤ºå¤–éƒ¨å‡½æ•°

// ç¤ºä¾‹
function add(x: int, y: int): int {
    return x + y;
}

function external_func(): void;  // å¤–éƒ¨å‡½æ•°å£°æ˜
```

### 4.4 è¯­å¥

#### 4.4.1 è¡¨è¾¾å¼è¯­å¥
```ebnf
ExpressionStatement ::= Expression ';'
```

#### 4.4.2 å£°æ˜è¯­å¥
```ebnf
DeclarationStatement ::= VariableDeclaration | TypeDeclaration
```

#### 4.4.3 æ§åˆ¶æµè¯­å¥

##### æ¡ä»¶è¯­å¥
```ebnf
IfStatement ::= 'if' '(' Expression ')' Statement ('else' Statement)?
```

##### å¾ªç¯è¯­å¥
```ebnf
WhileStatement ::= 'while' '(' Expression ')' Statement
DoWhileStatement ::= 'do' Statement 'while' '(' Expression ')' ';'
ForStatement ::= 'for' '(' (VariableDeclaration | Expression)? ';' Expression? ';' Expression? ')' Statement
```

##### è·³è½¬è¯­å¥
```ebnf
BreakStatement ::= 'break' ';'
ContinueStatement ::= 'continue' ';'
ReturnStatement ::= 'return' Expression? ';'
```

#### 4.4.4 å—è¯­å¥
```ebnf
BlockStatement ::= '{' Statement* '}'
```

### 4.5 è¡¨è¾¾å¼

#### 4.5.1 åŸºæœ¬è¡¨è¾¾å¼
```ebnf
PrimaryExpression ::= Literal
                    | Identifier
                    | '(' Expression ')'
                    | ArrayLiteral
                    | StructLiteral

Literal ::= IntegerLiteral | FloatLiteral | BooleanLiteral | CharLiteral | StringLiteral
```

#### 4.5.2 åç¼€è¡¨è¾¾å¼
```ebnf
PostfixExpression ::= PrimaryExpression
                    | PostfixExpression '[' Expression ']'      -- æ•°ç»„ä¸‹æ ‡
                    | PostfixExpression '(' ArgumentList? ')'   -- å‡½æ•°è°ƒç”¨
                    | PostfixExpression '.' Identifier          -- æˆå‘˜è®¿é—®
                    | PostfixExpression '->' Identifier         -- æŒ‡é’ˆæˆå‘˜è®¿é—®
                    | PostfixExpression '++'                    -- åç¼€è‡ªå¢
                    | PostfixExpression '--'                    -- åç¼€è‡ªå‡

ArgumentList ::= Expression (',' Expression)*
```

#### 4.5.3 ä¸€å…ƒè¡¨è¾¾å¼
```ebnf
UnaryExpression ::= PostfixExpression
                  | '++' UnaryExpression
                  | '--' UnaryExpression
                  | '+' UnaryExpression
                  | '-' UnaryExpression
                  | '!' UnaryExpression
                  | '~' UnaryExpression
                  | '*' UnaryExpression    -- è§£å¼•ç”¨
                  | '&' UnaryExpression    -- å–åœ°å€
                  | 'sizeof' '(' Type ')'  -- ç±»å‹å¤§å°
                  | 'typeof' '(' Expression ')'  -- è¡¨è¾¾å¼ç±»å‹
```

#### 4.5.4 äºŒå…ƒè¡¨è¾¾å¼
```ebnf
BinaryExpression ::= UnaryExpression
                   | BinaryExpression '*' BinaryExpression
                   | BinaryExpression '/' BinaryExpression
                   | BinaryExpression '%' BinaryExpression
                   | BinaryExpression '+' BinaryExpression
                   | BinaryExpression '-' BinaryExpression
                   | BinaryExpression '<<' BinaryExpression
                   | BinaryExpression '>>' BinaryExpression
                   | BinaryExpression '<' BinaryExpression
                   | BinaryExpression '<=' BinaryExpression
                   | BinaryExpression '>' BinaryExpression
                   | BinaryExpression '>=' BinaryExpression
                   | BinaryExpression '==' BinaryExpression
                   | BinaryExpression '!=' BinaryExpression
                   | BinaryExpression '&' BinaryExpression
                   | BinaryExpression '^' BinaryExpression
                   | BinaryExpression '|' BinaryExpression
                   | BinaryExpression '&&' BinaryExpression
                   | BinaryExpression '||' BinaryExpression
```

#### 4.5.5 èµ‹å€¼è¡¨è¾¾å¼
```ebnf
AssignmentExpression ::= BinaryExpression
                       | UnaryExpression '=' AssignmentExpression
                       | UnaryExpression '+=' AssignmentExpression
                       | UnaryExpression '-=' AssignmentExpression
                       | UnaryExpression '*=' AssignmentExpression
                       | UnaryExpression '/=' AssignmentExpression
                       | UnaryExpression '%=' AssignmentExpression
                       | UnaryExpression '<<=' AssignmentExpression
                       | UnaryExpression '>>=' AssignmentExpression
                       | UnaryExpression '&=' AssignmentExpression
                       | UnaryExpression '^=' AssignmentExpression
                       | UnaryExpression '|=' AssignmentExpression
```

#### 4.5.6 æ¡ä»¶è¡¨è¾¾å¼
```ebnf
ConditionalExpression ::= AssignmentExpression
                        | AssignmentExpression '?' Expression ':' ConditionalExpression
```

#### 4.5.7 é€—å·è¡¨è¾¾å¼
```ebnf
Expression ::= ConditionalExpression (',' ConditionalExpression)*
```

### 4.6 å­—é¢é‡è¡¨è¾¾å¼

#### 4.6.1 æ•°ç»„å­—é¢é‡
```ebnf
ArrayLiteral ::= '[' ExpressionList? ']'
ExpressionList ::= Expression (',' Expression)*
```

#### 4.6.2 ç»“æ„ä½“å­—é¢é‡
```ebnf
StructLiteral ::= Identifier '{' FieldInitializerList? '}'
FieldInitializerList ::= FieldInitializer (',' FieldInitializer)*
FieldInitializer ::= Identifier ':' Expression
```

---

## 5. è¯­ä¹‰è§„èŒƒ

### 5.1 ç±»å‹ç³»ç»Ÿ

#### 5.1.1 ç±»å‹åˆ†ç±»

##### å€¼ç±»å‹ (Value Types)
```typescript
// åŸºæœ¬å€¼ç±»å‹
int:    32ä½æœ‰ç¬¦å·æ•´æ•°ï¼ŒèŒƒå›´ [-2^31, 2^31-1]
float:  32ä½IEEE 754æµ®ç‚¹æ•°
bool:   å¸ƒå°”ç±»å‹ï¼Œtrueæˆ–false
char:   8ä½Unicodeå­—ç¬¦

// å¤åˆå€¼ç±»å‹
struct: ç”¨æˆ·å®šä¹‰çš„ç»“æ„ä½“
array:  å›ºå®šé•¿åº¦æ•°ç»„
tuple:  åŒ¿åç»“æ„ä½“(å®éªŒæ€§)
```

##### å¼•ç”¨ç±»å‹ (Reference Types)
```typescript
string:  ä¸å¯å˜UTF-8å­—ç¬¦ä¸²
object:  æ ¹å¯¹è±¡ç±»å‹(æ‰€æœ‰ç±»å‹çš„è¶…ç±»å‹)
pointer: æŒ‡é’ˆç±»å‹ T*
```

#### 5.1.2 ç±»å‹å…³ç³»

##### å­ç±»å‹å…³ç³»
```
object
â”œâ”€â”€ value types
â”‚   â”œâ”€â”€ numeric types
â”‚   â”‚   â”œâ”€â”€ int
â”‚   â”‚   â””â”€â”€ float
â”‚   â”œâ”€â”€ bool
â”‚   â”œâ”€â”€ char
â”‚   â””â”€â”€ struct types
â””â”€â”€ reference types
    â”œâ”€â”€ string
    â””â”€â”€ pointer types
```

##### ç±»å‹å…¼å®¹æ€§çŸ©é˜µ
| æºç±»å‹ â†’ ç›®æ ‡ç±»å‹ | int | float | bool | char | string | pointer |
|-------------------|-----|-------|------|------|--------|---------|
| int | âœ“ | âœ“* | âœ— | âœ“* | âœ— | âœ— |
| float | âœ“* | âœ“ | âœ— | âœ— | âœ— | âœ— |
| bool | âœ— | âœ— | âœ“ | âœ— | âœ— | âœ— |
| char | âœ“ | âœ— | âœ— | âœ“ | âœ“* | âœ— |
| string | âœ— | âœ— | âœ— | âœ“* | âœ“ | âœ— |
| pointer | âœ— | âœ— | âœ— | âœ— | âœ— | âœ“â€  |

* éœ€è¦æ˜¾å¼ç±»å‹è½¬æ¢
â€  éœ€è¦ç›¸åŒåŸºç±»å‹çš„æŒ‡é’ˆ

#### 5.1.3 ç±»å‹æ¨æ–­è§„åˆ™

##### å˜é‡ç±»å‹æ¨æ–­
```cymbol
// æ ¹æ®åˆå§‹åŒ–è¡¨è¾¾å¼æ¨æ–­ç±»å‹
let x = 42;           // x: int
let y = 3.14;         // y: float
let z = "hello";      // z: string
let b = true;         // b: bool

// æ•°ç»„ç±»å‹æ¨æ–­
let arr = [1, 2, 3];  // arr: int[3]

// ç»“æ„ä½“ç±»å‹æ¨æ–­
struct Point { x: float, y: float }
let p = Point{x: 1.0, y: 2.0};  // p: Point
```

##### å‡½æ•°è¿”å›ç±»å‹æ¨æ–­
```cymbol
// æ ¹æ®returnè¯­å¥æ¨æ–­è¿”å›ç±»å‹
function add(x: int, y: int) {
    return x + y;  // è¿”å›ç±»å‹æ¨æ–­ä¸ºint
}

// å¤šreturnè¯­å¥å¿…é¡»ç±»å‹ä¸€è‡´
function abs(x: int) {
    if (x >= 0) {
        return x;      // int
    } else {
        return -x;     // int
    }
}
```

### 5.2 ä½œç”¨åŸŸè§„åˆ™

#### 5.2.1 ä½œç”¨åŸŸç±»å‹

##### é™æ€ä½œç”¨åŸŸ (è¯æ³•ä½œç”¨åŸŸ)
```cymbol
let x = 10;  // å…¨å±€ä½œç”¨åŸŸ

function outer() {
    let y = 20;  // å‡½æ•°ä½œç”¨åŸŸ

    function inner() {
        let z = 30;  // åµŒå¥—å‡½æ•°ä½œç”¨åŸŸ
        print(x + y + z);  // å¯ä»¥è®¿é—®å¤–å±‚å˜é‡
    }

    print(z);  // é”™è¯¯: zåœ¨innerä½œç”¨åŸŸä¸­
}
```

##### å—çº§ä½œç”¨åŸŸ
```cymbol
{
    let x = 42;
    print(x);  // æ­£ç¡®
}

print(x);  // é”™è¯¯: xè¶…å‡ºä½œç”¨åŸŸ

if (condition) {
    let y = 10;  // å—çº§ä½œç”¨åŸŸ
    print(y);
}

print(y);  // é”™è¯¯: yè¶…å‡ºä½œç”¨åŸŸ
```

#### 5.2.2 ä½œç”¨åŸŸæŸ¥æ‰¾è§„åˆ™

1. **æœ€è¿‘åµŒå¥—è§„åˆ™**: ä»å½“å‰ä½œç”¨åŸŸå¼€å§‹ï¼Œå‘å¤–å±‚æŸ¥æ‰¾
2. **é®è”½è§„åˆ™**: å†…å±‚å£°æ˜é®è”½å¤–å±‚åŒåå£°æ˜
3. **ç¦æ­¢é‡å¤å£°æ˜**: åŒä¸€ä½œç”¨åŸŸä¸èƒ½é‡å¤å£°æ˜åŒåå˜é‡
4. **ä½¿ç”¨å‰å£°æ˜**: å˜é‡å¿…é¡»å…ˆå£°æ˜åä½¿ç”¨

### 5.3 å†…å­˜æ¨¡å‹

#### 5.3.1 å­˜å‚¨ç±»åˆ«

##### è‡ªåŠ¨å­˜å‚¨ (æ ˆåˆ†é…)
```cymbol
function example() {
    let x = 42;      // æ ˆåˆ†é…
    let arr: int[10]; // æ ˆåˆ†é…æ•°ç»„
    // å‡½æ•°è¿”å›æ—¶è‡ªåŠ¨é‡Šæ”¾
}
```

##### é™æ€å­˜å‚¨ (å…¨å±€/é™æ€å˜é‡)
```cymbol
let global_var = 100;  // é™æ€å­˜å‚¨ï¼Œç¨‹åºç”Ÿå‘½å‘¨æœŸ

function example() {
    static counter = 0;  // é™æ€å±€éƒ¨å˜é‡
    counter++;
    return counter;
}
```

##### åŠ¨æ€å­˜å‚¨ (å †åˆ†é…)
```cymbol
function create_array(size: int): int* {
    let ptr = alloc(int, size);  // å †åˆ†é…
    return ptr;
}

function free_array(ptr: int*) {
    free(ptr);  // æ‰‹åŠ¨é‡Šæ”¾
}
```

#### 5.3.2 ç”Ÿå‘½å‘¨æœŸ

| å­˜å‚¨ç±»åˆ« | åˆ†é…æ—¶æœº | é‡Šæ”¾æ—¶æœº | ç¤ºä¾‹ |
|----------|----------|----------|------|
| è‡ªåŠ¨å­˜å‚¨ | è¿›å…¥ä½œç”¨åŸŸæ—¶ | ç¦»å¼€ä½œç”¨åŸŸæ—¶ | å±€éƒ¨å˜é‡ |
| é™æ€å­˜å‚¨ | ç¨‹åºå¯åŠ¨æ—¶ | ç¨‹åºç»“æŸæ—¶ | å…¨å±€å˜é‡ |
| åŠ¨æ€å­˜å‚¨ | allocè°ƒç”¨æ—¶ | freeè°ƒç”¨æ—¶ | å †å¯¹è±¡ |

### 5.4 è¡¨è¾¾å¼æ±‚å€¼

#### 5.4.1 æ±‚å€¼é¡ºåº

##### ç¡®å®šé¡ºåº
1. å‡½æ•°å‚æ•°ä»å·¦åˆ°å³æ±‚å€¼
2. èµ‹å€¼æ“ä½œä»å³åˆ°å·¦æ±‚å€¼
3. çŸ­è·¯æ±‚å€¼: `&&`å’Œ`||`è¿ç®—ç¬¦

##### æœªæŒ‡å®šé¡ºåº
1. äºŒå…ƒè¿ç®—ç¬¦çš„æ“ä½œæ•°æ±‚å€¼é¡ºåº
2. å‡½æ•°è°ƒç”¨å‚æ•°çš„å‰¯ä½œç”¨é¡ºåº

#### 5.4.2 å‰¯ä½œç”¨

##### å…è®¸çš„å‰¯ä½œç”¨
```cymbol
x = 42;           // èµ‹å€¼å‰¯ä½œç”¨
x++;              // è‡ªå¢å‰¯ä½œç”¨
print("hello");   // I/Oå‰¯ä½œç”¨
```

##### é™åˆ¶çš„å‰¯ä½œç”¨
1. **åºåˆ—ç‚¹è§„åˆ™**: ä¸¤ä¸ªåºåˆ—ç‚¹ä¹‹é—´ï¼Œæ ‡é‡å¯¹è±¡æœ€å¤šä¿®æ”¹ä¸€æ¬¡
2. **è¯»-æ”¹-å†™åŸå­æ€§**: è¯»å’Œå†™æ“ä½œä¸èƒ½äº¤é”™

### 5.5 é”™è¯¯å¤„ç†

#### 5.5.1 ç¼–è¯‘æ—¶é”™è¯¯
1. **è¯­æ³•é”™è¯¯**: ä¸ç¬¦åˆè¯­æ³•è§„èŒƒ
2. **ç±»å‹é”™è¯¯**: ç±»å‹ä¸åŒ¹é…æˆ–æœªå®šä¹‰
3. **ä½œç”¨åŸŸé”™è¯¯**: æœªå£°æ˜å˜é‡æˆ–é‡å¤å£°æ˜
4. **è¯­ä¹‰é”™è¯¯**: è¿åè¯­è¨€è¯­ä¹‰è§„åˆ™

#### 5.5.2 è¿è¡Œæ—¶é”™è¯¯
1. **é™¤é›¶é”™è¯¯**: æ•´æ•°é™¤ä»¥é›¶
2. **ç©ºæŒ‡é’ˆè§£å¼•ç”¨**: è§£å¼•ç”¨nullæŒ‡é’ˆ
3. **æ•°ç»„è¶Šç•Œ**: è®¿é—®æ•°ç»„æ— æ•ˆç´¢å¼•
4. **ç±»å‹è½¬æ¢é”™è¯¯**: æ— æ•ˆçš„ç±»å‹è½¬æ¢

---

## 6. æ ‡å‡†åº“è§„èŒƒ

### 6.1 æ ¸å¿ƒæ¨¡å— (std.core)

#### 6.1.1 å†…ç½®å‡½æ•°
```typescript
// ç±»å‹è½¬æ¢
function int(x: any): int
function float(x: any): float
function bool(x: any): bool
function string(x: any): string

// æ•°å­¦å‡½æ•°
function abs(x: int | float): int | float
function max(x: T, y: T): T where T: numeric
function min(x: T, y: T): T where T: numeric
function sqrt(x: float): float
function pow(base: float, exponent: float): float

// å†…å­˜ç®¡ç†
function alloc(T: type, count: int): T*
function free(ptr: void*): void
function sizeof(T: type): int
```

#### 6.1.2 å†…ç½®æ“ä½œç¬¦è¯­ä¹‰

##### ç®—æœ¯æ“ä½œç¬¦
```cymbol
// æ•´æ•°è¿ç®—
5 + 3    // 8
5 - 3    // 2
5 * 3    // 15
5 / 3    // 1 (æ•´æ•°é™¤æ³•)
5 % 3    // 2

// æµ®ç‚¹è¿ç®—
5.0 + 3.0  // 8.0
5.0 / 2.0  // 2.5

// æº¢å‡ºå¤„ç†
// æ•´æ•°æº¢å‡º: æœªå®šä¹‰è¡Œä¸º
// æµ®ç‚¹æº¢å‡º: äº§ç”Ÿinfæˆ–NaN
```

##### æ¯”è¾ƒæ“ä½œç¬¦
```cymbol
// æ•°å€¼æ¯”è¾ƒ
5 == 5    // true
5 != 3    // true
5 > 3     // true
5 <= 5    // true

// å­—ç¬¦ä¸²æ¯”è¾ƒ
"hello" == "hello"  // true
"a" < "b"           // true (å­—å…¸åº)

// ç±»å‹å®‰å…¨æ¯”è¾ƒ
5 == 5.0    // é”™è¯¯: ç±»å‹ä¸åŒ¹é…
```

### 6.2 è¾“å…¥è¾“å‡ºæ¨¡å— (std.io)

#### 6.2.1 æ ‡å‡†æµ
```typescript
// æ ‡å‡†è¾“å…¥è¾“å‡º
function print(value: any): void
function println(value: any): void
function read_line(): string
function read_int(): int
function read_float(): float

// æ ¼å¼åŒ–è¾“å‡º
function printf(format: string, args: ...any): void
function sprintf(format: string, args: ...any): string
```

#### 6.2.2 æ–‡ä»¶æ“ä½œ
```typescript
// æ–‡ä»¶ç±»å‹
type File = object

// æ–‡ä»¶æ“ä½œ
function fopen(path: string, mode: string): File*
function fclose(file: File*): int
function fread(buffer: void*, size: int, count: int, file: File*): int
function fwrite(buffer: void*, size: int, count: int, file: File*): int
```

### 6.3 æ•°å­¦æ¨¡å— (std.math)

#### 6.3.1 æ•°å­¦å¸¸æ•°
```typescript
const PI: float = 3.141592653589793
const E: float = 2.718281828459045
const INFINITY: float = 1.0 / 0.0
const NAN: float = 0.0 / 0.0
```

#### 6.3.2 æ•°å­¦å‡½æ•°
```typescript
// ä¸‰è§’å‡½æ•°
function sin(x: float): float
function cos(x: float): float
function tan(x: float): float
function asin(x: float): float
function acos(x: float): float
function atan(x: float): float

// æŒ‡æ•°å’Œå¯¹æ•°
function exp(x: float): float
function log(x: float): float
function log10(x: float): float

// å…¶ä»–å‡½æ•°
function ceil(x: float): float
function floor(x: float): float
function round(x: float): float
```

### 6.4 å­—ç¬¦ä¸²æ¨¡å— (std.string)

#### 6.4.1 å­—ç¬¦ä¸²æ“ä½œ
```typescript
// å­—ç¬¦ä¸²é•¿åº¦
function strlen(s: string): int

// å­—ç¬¦ä¸²æ‹¼æ¥
function strcat(dest: string, src: string): string

// å­—ç¬¦ä¸²æ¯”è¾ƒ
function strcmp(s1: string, s2: string): int

// å­—ç¬¦ä¸²æŸ¥æ‰¾
function strstr(haystack: string, needle: string): int

// å­—ç¬¦ä¸²è½¬æ¢
function strtol(s: string, base: int): int
function strtof(s: string): float
```

### 6.5 æ•°ç»„æ¨¡å— (std.array)

#### 6.5.1 æ•°ç»„æ“ä½œ
```typescript
// æ•°ç»„é•¿åº¦
function array_len(arr: T[]): int

// æ•°ç»„æ“ä½œ
function array_copy(dest: T[], src: T[], count: int): void
function array_fill(arr: T[], value: T, count: int): void
function array_reverse(arr: T[], count: int): void

// æ•°ç»„æŸ¥æ‰¾
function array_find(arr: T[], value: T, count: int): int
function array_binary_search(arr: T[], value: T, count: int): int

// æ•°ç»„æ’åº
function array_sort(arr: T[], count: int, compare: function): void
```

---

## 7. APIè§„èŒƒ

### 7.1 ç¼–è¯‘å™¨API

#### 7.1.1 ç¼–è¯‘å™¨æ¥å£
```java
// ç¼–è¯‘å™¨ä¸»æ¥å£
interface Compiler {
    // ç¼–è¯‘æ–¹æ³•
    CompilationResult compile(SourceFile source);
    CompilationResult compile(String code, String filename);

    // é…ç½®æ–¹æ³•
    void setOptimizationLevel(OptimizationLevel level);
    void setTarget(TargetPlatform target);
    void addIncludePath(String path);

    // è¯Šæ–­æ–¹æ³•
    List<Diagnostic> getDiagnostics();
    boolean hasErrors();
    boolean hasWarnings();
}

// ç¼–è¯‘ç»“æœ
interface CompilationResult {
    boolean success();
    byte[] getBytecode();
    String getAssembly();
    List<Diagnostic> getDiagnostics();
}

// è¯Šæ–­ä¿¡æ¯
interface Diagnostic {
    enum Severity { ERROR, WARNING, INFO }

    Severity getSeverity();
    String getMessage();
    SourceLocation getLocation();
    String getCode();  // é”™è¯¯ä»£ç 
}
```

#### 7.1.2 ç¼–è¯‘å™¨é…ç½®
```java
// ä¼˜åŒ–çº§åˆ«
enum OptimizationLevel {
    O0,  // æ— ä¼˜åŒ–
    O1,  // åŸºç¡€ä¼˜åŒ–
    O2,  // æ ‡å‡†ä¼˜åŒ–
    O3,  // æ¿€è¿›ä¼˜åŒ–
    Os,  // ä¼˜åŒ–ä»£ç å¤§å°
    Oz   // æœ€å¤§ç¨‹åº¦ä¼˜åŒ–ä»£ç å¤§å°
}

// ç›®æ ‡å¹³å°
enum TargetPlatform {
    EP18_VM,      // EP18è™šæ‹Ÿæœº
    X86_64,       // x86-64æ¶æ„
    ARM64,        // ARM64æ¶æ„
    WASM,         // WebAssembly
    LLVM_IR       // LLVMä¸­é—´è¡¨ç¤º
}

// è¯­è¨€æ ‡å‡†
enum LanguageStandard {
    CYMBOL_1_0,   // Cymbol 1.0 (EP20)
    CYMBOL_2_0    // Cymbol 2.0 (EP21)
}
```

### 7.2 æ ‡å‡†åº“API

#### 7.2.1 æ ¸å¿ƒç±»å‹å®šä¹‰
```java
// åŸºç¡€ç±»å‹å°è£…
class CymbolInt {
    int value;
    // ç®—æœ¯è¿ç®—
    CymbolInt add(CymbolInt other);
    CymbolInt sub(CymbolInt other);
    CymbolInt mul(CymbolInt other);
    CymbolInt div(CymbolInt other);
    CymbolInt mod(CymbolInt other);
    // æ¯”è¾ƒè¿ç®—
    bool eq(CymbolInt other);
    bool ne(CymbolInt other);
    bool lt(CymbolInt other);
    bool le(CymbolInt other);
    bool gt(CymbolInt other);
    bool ge(CymbolInt other);
}

class CymbolFloat { /* ç±»ä¼¼å®ç° */ }
class CymbolBool { /* ç±»ä¼¼å®ç° */ }
class CymbolString { /* ç±»ä¼¼å®ç° */ }
```

#### 7.2.2 å†…å­˜ç®¡ç†API
```java
// å†…å­˜åˆ†é…å™¨æ¥å£
interface Allocator {
    // åˆ†é…å†…å­˜
    Pointer allocate(Type type, int count);
    Pointer allocate(int size, int alignment);

    // é‡Šæ”¾å†…å­˜
    void free(Pointer ptr);

    // å†…å­˜ä¿¡æ¯
    int getTotalMemory();
    int getUsedMemory();
    int getFreeMemory();
}

// é»˜è®¤åˆ†é…å™¨
class DefaultAllocator implements Allocator {
    // ä½¿ç”¨ç³»ç»Ÿmalloc/free
}

// åƒåœ¾å›æ”¶åˆ†é…å™¨ (å®éªŒæ€§)
class GCAllocator implements Allocator {
    // ä½¿ç”¨å¼•ç”¨è®¡æ•°æˆ–æ ‡è®°æ¸…é™¤
}
```

### 7.3 æ‰©å±•API

#### 7.3.1 æ’ä»¶ç³»ç»ŸAPI
```java
// æ’ä»¶æ¥å£
interface CompilerPlugin {
    // æ’ä»¶ä¿¡æ¯
    String getName();
    String getVersion();
    String getDescription();

    // ç”Ÿå‘½å‘¨æœŸ
    void initialize(PluginContext context);
    void shutdown();

    // æ‰©å±•ç‚¹
    List<ExtensionPoint> getExtensionPoints();
}

// æ’ä»¶ä¸Šä¸‹æ–‡
interface PluginContext {
    Compiler getCompiler();
    Config getConfig();
    Logger getLogger();

    // æ³¨å†Œæ‰©å±•
    void registerExtension(ExtensionPoint point, Extension extension);
    void unregisterExtension(ExtensionPoint point, Extension extension);
}

// æ‰©å±•ç‚¹ç±»å‹
enum ExtensionPoint {
    LEXER,           // è¯æ³•åˆ†ææ‰©å±•
    PARSER,          // è¯­æ³•åˆ†ææ‰©å±•
    AST_TRANSFORM,   // ASTè½¬æ¢æ‰©å±•
    TYPE_SYSTEM,     // ç±»å‹ç³»ç»Ÿæ‰©å±•
    IR_OPTIMIZATION, // IRä¼˜åŒ–æ‰©å±•
    CODE_GENERATION, // ä»£ç ç”Ÿæˆæ‰©å±•
    TARGET_BACKEND   // ç›®æ ‡åç«¯æ‰©å±•
}
```

#### 7.3.2 è¯­è¨€æ‰©å±•API
```java
// æ–°è¯­æ³•ç‰¹æ€§æ³¨å†Œ
interface SyntaxExtension {
    // è¯­æ³•è§„åˆ™
    String getGrammarRule();
    String getRuleName();

    // ASTèŠ‚ç‚¹æ„å»º
    ASTNode buildAST(ParserRuleContext context);

    // è¯­ä¹‰åˆ†æ
    void analyzeSemantics(ASTNode node, SymbolTable symbolTable);
}

// æ–°ç±»å‹æ³¨å†Œ
interface TypeExtension {
    // ç±»å‹å®šä¹‰
    Type defineType(String name, TypeDefinition definition);

    // ç±»å‹æ£€æŸ¥
    TypeCheckResult checkType(Type type, Expression expression);

    // ç±»å‹è½¬æ¢
    ConversionResult convertType(Type from, Type to, Expression expression);
}

// æ–°ä¼˜åŒ–Passæ³¨å†Œ
interface OptimizationExtension {
    // Passå®šä¹‰
    OptimizationPass createPass();

    // é…ç½®é€‰é¡¹
    List<Option> getOptions();
    void configure(Map<String, Object> options);
}
```

---

## 8. ç¬¦åˆæ€§è¦æ±‚

### 8.1 å®ç°ç¬¦åˆæ€§çº§åˆ«

#### 8.1.1 æ ¸å¿ƒåŠŸèƒ½ (å¿…é¡»å®ç°)
| åŠŸèƒ½ç±»åˆ« | å…·ä½“è¦æ±‚ | æµ‹è¯•è¦†ç›–ç‡ |
|----------|----------|------------|
| è¯æ³•åˆ†æ | å®Œæ•´æ”¯æŒç¬¬3ç« è¯æ³•è§„èŒƒ | â‰¥95% |
| è¯­æ³•åˆ†æ | å®Œæ•´æ”¯æŒç¬¬4ç« è¯­æ³•è§„èŒƒ | â‰¥95% |
| ç±»å‹ç³»ç»Ÿ | å®Œæ•´æ”¯æŒç¬¬5.1èŠ‚ç±»å‹ç³»ç»Ÿ | â‰¥90% |
| è¯­ä¹‰åˆ†æ | å®Œæ•´æ”¯æŒç¬¬5ç« è¯­ä¹‰è§„èŒƒ | â‰¥90% |
| ä»£ç ç”Ÿæˆ | æ”¯æŒåŸºæœ¬ä»£ç ç”Ÿæˆ | â‰¥85% |

#### 8.1.2 æ ‡å‡†åº“ (åº”è¯¥å®ç°)
| æ¨¡å— | æœ€å°å®ç°è¦æ±‚ | æ¨èå®ç° |
|------|--------------|----------|
| std.core | å†…ç½®å‡½æ•°å’Œæ“ä½œç¬¦ | å®Œæ•´å®ç° |
| std.io | print/readåŸºæœ¬I/O | å®Œæ•´I/Oåº“ |
| std.math | åŸºæœ¬æ•°å­¦å‡½æ•° | å®Œæ•´æ•°å­¦åº“ |
| std.string | åŸºæœ¬å­—ç¬¦ä¸²æ“ä½œ | å®Œæ•´å­—ç¬¦ä¸²åº“ |

#### 8.1.3 æ‰©å±•åŠŸèƒ½ (å¯ä»¥å®ç°)
| åŠŸèƒ½ | è¯´æ˜ | ä¼˜å…ˆçº§ |
|------|------|--------|
| ä¼˜åŒ–Pass | å„ç§ä¼˜åŒ–ç®—æ³•å®ç° | é«˜ |
| è°ƒè¯•ä¿¡æ¯ | æºä»£ç çº§è°ƒè¯•æ”¯æŒ | ä¸­ |
| æ’ä»¶ç³»ç»Ÿ | ç¼–è¯‘å™¨æ‰©å±•æœºåˆ¶ | ä½ |
| å¤šç›®æ ‡æ”¯æŒ | å¤šç§ç›®æ ‡æ¶æ„ | ä¸­ |

### 8.2 æµ‹è¯•è¦æ±‚

#### 8.2.1 æµ‹è¯•å¥—ä»¶ç»“æ„
```
tests/
â”œâ”€â”€ lexical/          # è¯æ³•æµ‹è¯•
â”‚   â”œâ”€â”€ identifiers/  # æ ‡è¯†ç¬¦æµ‹è¯•
â”‚   â”œâ”€â”€ literals/     # å­—é¢é‡æµ‹è¯•
â”‚   â””â”€â”€ keywords/     # å…³é”®å­—æµ‹è¯•
â”œâ”€â”€ syntax/           # è¯­æ³•æµ‹è¯•
â”‚   â”œâ”€â”€ declarations/ # å£°æ˜æµ‹è¯•
â”‚   â”œâ”€â”€ statements/   # è¯­å¥æµ‹è¯•
â”‚   â””â”€â”€ expressions/  # è¡¨è¾¾å¼æµ‹è¯•
â”œâ”€â”€ semantic/         # è¯­ä¹‰æµ‹è¯•
â”‚   â”œâ”€â”€ types/        # ç±»å‹æµ‹è¯•
â”‚   â”œâ”€â”€ scope/        # ä½œç”¨åŸŸæµ‹è¯•
â”‚   â””â”€â”€ errors/       # é”™è¯¯æµ‹è¯•
â”œâ”€â”€ optimization/     # ä¼˜åŒ–æµ‹è¯•
â”‚   â”œâ”€â”€ constant_folding/
â”‚   â”œâ”€â”€ dead_code/
â”‚   â””â”€â”€ inlining/
â””â”€â”€ codegen/          # ä»£ç ç”Ÿæˆæµ‹è¯•
    â”œâ”€â”€ arithmetic/
    â”œâ”€â”€ control_flow/
    â””â”€â”€ functions/
```

#### 8.2.2 æµ‹è¯•è´¨é‡æ ‡å‡†
1. **è¦†ç›–ç‡è¦æ±‚**: æ•´ä½“â‰¥85%ï¼Œæ ¸å¿ƒæ¨¡å—â‰¥90%
2. **è¾¹ç•Œæµ‹è¯•**: æ‰€æœ‰è¾¹ç•Œæ¡ä»¶å¿…é¡»æµ‹è¯•
3. **é”™è¯¯æµ‹è¯•**: æ‰€æœ‰é”™è¯¯æƒ…å†µå¿…é¡»æµ‹è¯•
4. **æ€§èƒ½æµ‹è¯•**: å…³é”®ç®—æ³•å¿…é¡»æœ‰æ€§èƒ½æµ‹è¯•
5. **å›å½’æµ‹è¯•**: æ‰€æœ‰ä¿®å¤çš„bugå¿…é¡»æœ‰å›å½’æµ‹è¯•

### 8.3 æ–‡æ¡£è¦æ±‚

#### 8.3.1 å®ç°æ–‡æ¡£
1. **æ¶æ„æ–‡æ¡£**: è¯¦ç»†è¯´æ˜ç¼–è¯‘å™¨æ¶æ„è®¾è®¡
2. **APIæ–‡æ¡£**: æ‰€æœ‰å…¬å¼€APIå¿…é¡»æœ‰å®Œæ•´æ–‡æ¡£
3. **æ‰©å±•æŒ‡å—**: å¦‚ä½•æ‰©å±•ç¼–è¯‘å™¨çš„æŒ‡å—
4. **æµ‹è¯•æŒ‡å—**: å¦‚ä½•æ·»åŠ å’Œè¿è¡Œæµ‹è¯•

#### 8.3.2 ç”¨æˆ·æ–‡æ¡£
1. **è¯­è¨€æ•™ç¨‹**: ä»å…¥é—¨åˆ°ç²¾é€šçš„æ•™ç¨‹
2. **æ ‡å‡†åº“æ–‡æ¡£**: æ‰€æœ‰æ ‡å‡†åº“å‡½æ•°çš„æ–‡æ¡£
3. **å·¥å…·æŒ‡å—**: ç¼–è¯‘å™¨å·¥å…·çš„ä½¿ç”¨æŒ‡å—
4. **æœ€ä½³å®è·µ**: ç¼–ç¨‹æœ€ä½³å®è·µæŒ‡å—

---

## é™„å½•A: è¯­æ³•æ‘˜è¦

### A.1 EBNFè¯­æ³•æ€»è§ˆ
```
Program = {Import | Declaration}
Import = "import" identifier {"." identifier} ["as" identifier] ";"
Declaration = FunctionDecl | VarDecl | TypeDecl

FunctionDecl = "function" identifier "(" [Params] ")" [":" Type] Block
Params = Param {"," Param}
Param = identifier ":" Type

VarDecl = ("let" | "var" | "const") identifier [":" Type] ["=" Expression] ";"

TypeDecl = StructDecl | EnumDecl
StructDecl = "struct" identifier "{" {FieldDecl} "}"
FieldDecl = Type identifier ["=" Expression] ";"
EnumDecl = "enum" identifier "{" identifier ["=" Expression] {"," identifier ["=" Expression]} "}"

Type = BasicType | identifier | PointerType | ArrayType | FunctionType
BasicType = "int" | "float" | "bool" | "string" | "void" | "object"
PointerType = Type "*"
ArrayType = Type "[" [integer] "]"
FunctionType = "(" [TypeList] ")" "->" Type
TypeList = Type {"," Type}

Statement = Block | IfStmt | WhileStmt | ForStmt | ReturnStmt | ExprStmt | VarDecl
Block = "{" {Statement} "}"
IfStmt = "if" "(" Expression ")" Statement ["else" Statement]
WhileStmt = "while" "(" Expression ")" Statement
ForStmt = "for" "(" [VarDecl | Expr] ";" [Expression] ";" [Expression] ")" Statement
ReturnStmt = "return" [Expression] ";"
ExprStmt = Expression ";"

Expression = Assignment
Assignment = Conditional {("=" | "+=" | "-=" | "*=" | "/=" | "%=") Assignment}
Conditional = LogicalOr ["?" Expression ":" Conditional]
LogicalOr = LogicalAnd {"||" LogicalAnd}
LogicalAnd = Equality {"&&" Equality}
Equality = Relational {("==" | "!=") Relational}
Relational = Shift {("<" | ">" | "<=" | ">=") Shift}
Shift = Additive {("<<" | ">>") Additive}
Additive = Multiplicative {("+" | "-") Multiplicative}
Multiplicative = Unary {("*" | "/" | "%") Unary}
Unary = ("+" | "-" | "!" | "~" | "*" | "&") Unary | Postfix
Postfix = Primary {"[" Expression "]" | "(" [ArgList] ")" | "." identifier | "->" identifier | "++" | "--"}
Primary = identifier | literal | "(" Expression ")" | ArrayLiteral | StructLiteral

ArrayLiteral = "[" [Expression {"," Expression}] "]"
StructLiteral = identifier "{" [FieldInit {"," FieldInit}] "}"
FieldInit = identifier ":" Expression

literal = integer | float | boolean | character | string
```

### A.2 ä¼˜å…ˆçº§æ€»ç»“è¡¨
| ä¼˜å…ˆçº§ | æ“ä½œç¬¦ | ç»“åˆæ€§ | è¯´æ˜ |
|--------|--------|--------|------|
| 1 | `()` `[]` `.` `->` | å·¦ | å‡½æ•°è°ƒç”¨ã€æˆå‘˜è®¿é—® |
| 2 | `++` `--` (åç¼€) | å·¦ | åç¼€è‡ªå¢è‡ªå‡ |
| 3 | `++` `--` (å‰ç¼€) `+` `-` `!` `~` `*` `&` | å³ | ä¸€å…ƒæ“ä½œç¬¦ |
| 4 | `*` `/` `%` | å·¦ | ä¹˜æ€§æ“ä½œç¬¦ |
| 5 | `+` `-` | å·¦ | åŠ æ€§æ“ä½œç¬¦ |
| 6 | `<<` `>>` | å·¦ | ç§»ä½æ“ä½œç¬¦ |
| 7 | `<` `<=` `>` `>=` | å·¦ | å…³ç³»æ“ä½œç¬¦ |
| 8 | `==` `!=` | å·¦ | ç›¸ç­‰æ“ä½œç¬¦ |
| 9 | `&` | å·¦ | ä½ä¸ |
| 10 | `^` | å·¦ | ä½å¼‚æˆ– |
| 11 | `\|` | å·¦ | ä½æˆ– |
| 12 | `&&` | å·¦ | é€»è¾‘ä¸ |
| 13 | `\|\|` | å·¦ | é€»è¾‘æˆ– |
| 14 | `?:` | å³ | æ¡ä»¶æ“ä½œç¬¦ |
| 15 | `=` `+=` `-=` `*=` `/=` `%=` `<<=` `>>=` `&=` `^=` `\|=` | å³ | èµ‹å€¼æ“ä½œç¬¦ |
| 16 | `,` | å·¦ | é€—å·æ“ä½œç¬¦ |

## é™„å½•B: æ ‡å‡†åº“å‡½æ•°ç´¢å¼•

### B.1 æ ¸å¿ƒå‡½æ•°
- `int(x)`: è½¬æ¢ä¸ºæ•´æ•°
- `float(x)`: è½¬æ¢ä¸ºæµ®ç‚¹æ•°
- `bool(x)`: è½¬æ¢ä¸ºå¸ƒå°”å€¼
- `string(x)`: è½¬æ¢ä¸ºå­—ç¬¦ä¸²
- `abs(x)`: ç»å¯¹å€¼
- `max(x, y)`: æœ€å¤§å€¼
- `min(x, y)`: æœ€å°å€¼
- `sqrt(x)`: å¹³æ–¹æ ¹
- `pow(x, y)`: å¹‚è¿ç®—

### B.2 I/Oå‡½æ•°
- `print(x)`: æ‰“å°è¾“å‡º
- `println(x)`: æ‰“å°å¹¶æ¢è¡Œ
- `read_line()`: è¯»å–ä¸€è¡Œ
- `read_int()`: è¯»å–æ•´æ•°
- `read_float()`: è¯»å–æµ®ç‚¹æ•°
- `printf(format, ...)`: æ ¼å¼åŒ–è¾“å‡º

### B.3 æ•°å­¦å‡½æ•°
- `sin(x)`, `cos(x)`, `tan(x)`: ä¸‰è§’å‡½æ•°
- `asin(x)`, `acos(x)`, `atan(x)`: åä¸‰è§’å‡½æ•°
- `exp(x)`: æŒ‡æ•°å‡½æ•°
- `log(x)`: è‡ªç„¶å¯¹æ•°
- `log10(x)`: å¸¸ç”¨å¯¹æ•°
- `ceil(x)`, `floor(x)`, `round(x)`: å–æ•´å‡½æ•°

### B.4 å­—ç¬¦ä¸²å‡½æ•°
- `strlen(s)`: å­—ç¬¦ä¸²é•¿åº¦
- `strcat(dest, src)`: å­—ç¬¦ä¸²æ‹¼æ¥
- `strcmp(s1, s2)`: å­—ç¬¦ä¸²æ¯”è¾ƒ
- `strstr(haystack, needle)`: å­ä¸²æŸ¥æ‰¾
- `strtol(s, base)`: å­—ç¬¦ä¸²è½¬æ•´æ•°
- `strtof(s)`: å­—ç¬¦ä¸²è½¬æµ®ç‚¹æ•°

### B.5 æ•°ç»„å‡½æ•°
- `array_len(arr)`: æ•°ç»„é•¿åº¦
- `array_copy(dest, src, n)`: æ•°ç»„å¤åˆ¶
- `array_fill(arr, value, n)`: æ•°ç»„å¡«å……
- `array_find(arr, value, n)`: æ•°ç»„æŸ¥æ‰¾
- `array_sort(arr, n, cmp)`: æ•°ç»„æ’åº

## é™„å½•C: é”™è¯¯ä»£ç è¡¨

### C.1 è¯­æ³•é”™è¯¯ (E001-E099)
| ä»£ç  | æè¿° | å¯èƒ½åŸå›  |
|------|------|----------|
| E001 | ç¼ºå°‘åˆ†å· | è¯­å¥æœ«å°¾ç¼ºå°‘åˆ†å· |
| E002 | ç¼ºå°‘æ‹¬å· | è¡¨è¾¾å¼ç¼ºå°‘é…å¯¹çš„æ‹¬å· |
| E003 | æ— æ•ˆçš„æ ‡è®° | æ— æ³•è¯†åˆ«çš„è¯æ³•å•å…ƒ |
| E004 | è¯­æ³•é”™è¯¯ | ä¸ç¬¦åˆè¯­æ³•è§„åˆ™ |

### C.2 ç±»å‹é”™è¯¯ (E100-E199)
| ä»£ç  | æè¿° | å¯èƒ½åŸå›  |
|------|------|----------|
| E101 | ç±»å‹ä¸åŒ¹é… | è¡¨è¾¾å¼ç±»å‹ä¸æœŸæœ›ç±»å‹ä¸ç¬¦ |
| E102 | æœªå®šä¹‰çš„ç±»å‹ | ä½¿ç”¨äº†æœªå®šä¹‰çš„ç±»å‹å |
| E103 | æ— æ•ˆçš„ç±»å‹è½¬æ¢ | ç±»å‹è½¬æ¢ä¸åˆæ³• |
| E104 | æ“ä½œç¬¦ç±»å‹é”™è¯¯ | æ“ä½œç¬¦åº”ç”¨äºä¸æ”¯æŒçš„ç±»å‹ |

### C.3 ç¬¦å·é”™è¯¯ (E200-E299)
| ä»£ç  | æè¿° | å¯èƒ½åŸå›  |
|------|------|----------|
| E201 | æœªå®šä¹‰çš„å˜é‡ | ä½¿ç”¨äº†æœªå£°æ˜çš„å˜é‡ |
| E202 | æœªå®šä¹‰çš„å‡½æ•° | è°ƒç”¨äº†æœªå®šä¹‰çš„å‡½æ•° |
| E203 | é‡å¤å®šä¹‰ | åŒä¸€ä½œç”¨åŸŸé‡å¤å®šä¹‰åŒåç¬¦å· |
| E204 | ä¸å¯è®¿é—®çš„ç¬¦å· | ç¬¦å·ä¸åœ¨å½“å‰ä½œç”¨åŸŸ |

### C.4 è¯­ä¹‰é”™è¯¯ (E300-E399)
| ä»£ç  | æè¿° | å¯èƒ½åŸå›  |
|------|------|----------|
| E301 | é™¤é›¶é”™è¯¯ | é™¤æ•°ä¸ºé›¶çš„ç¼–è¯‘æ—¶å¸¸é‡ |
| E302 | æ•°ç»„è¶Šç•Œ | æ•°ç»„ç´¢å¼•è¶…å‡ºèŒƒå›´ |
| E303 | æ— é™é€’å½’ | æ£€æµ‹åˆ°å¯èƒ½çš„æ— é™é€’å½’ |
| E304 | ä¸å¯è¾¾ä»£ç  | æ£€æµ‹åˆ°ä¸å¯è¾¾çš„ä»£ç  |

### C.5 ç³»ç»Ÿé”™è¯¯ (E400-E499)
| ä»£ç  | æè¿° | å¯èƒ½åŸå›  |
|------|------|----------|
| E401 | æ–‡ä»¶æœªæ‰¾åˆ° | æ— æ³•æ‰“å¼€æºæ–‡ä»¶ |
| E402 | å†…å­˜ä¸è¶³ | ç¼–è¯‘è¿‡ç¨‹å†…å­˜ä¸è¶³ |
| E403 | å †æ ˆæº¢å‡º | é€’å½’æ·±åº¦è¿‡å¤§ |
| E404 | I/Oé”™è¯¯ | æ–‡ä»¶è¯»å†™é”™è¯¯ |

---

**è§„èŒƒç‰ˆæœ¬**: 2.0.0
**å‘å¸ƒæ—¥æœŸ**: 2025-12-21
**ç”Ÿæ•ˆæ—¥æœŸ**: 2025-12-21
**ç»´æŠ¤è€…**: EP21ç¼–è¯‘å™¨å›¢é˜Ÿ

---
*æœ¬è§„èŒƒæ˜¯Cymbolç¼–ç¨‹è¯­è¨€EP21ç‰ˆæœ¬çš„æƒå¨å®šä¹‰ã€‚æ‰€æœ‰å®ç°å¿…é¡»éµå¾ªæœ¬è§„èŒƒï¼Œå¦‚æœ‰ä¸ä¸€è‡´ï¼Œä»¥æœ¬è§„èŒƒä¸ºå‡†ã€‚*