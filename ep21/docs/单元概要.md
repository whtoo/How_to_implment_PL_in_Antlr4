# EP21 单元概要

## 1. 项目概览

EP21是一个基于ANTLR4的静态分析编译器，专注于三地址码构造和基本块控制流分析。项目采用分层架构，包含语法分析、AST构建、IR生成、CFG分析和代码生成等核心模块。

## 2. 核心模块概要

### 2.1 语法分析模块
**位置**: `src/main/antlr4/`

| 类名 | 功能 | 关键特性 |
|------|------|----------|
| `Cymbol.g4` | 语法定义文件 | 定义Cymbol语言完整语法，包含函数、变量、控制流等语法规则 |

### 2.2 AST模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/ast/`

| 类名 | 功能 | 关键方法 |
|------|------|----------|
| `ASTNode` | AST节点基类 | `accept()`, `dump()`, `getLocation()` |
| `CompileUnit` | 编译单元根节点 | `addFuncDecl()`, `addVarDecl()`, `getFuncDeclarations()` |
| `FuncDeclNode` | 函数声明节点 | `getRetType()`, `getFuncName()`, `getBody()` |
| `VarDeclNode` | 变量声明节点 | `hasInitializer()`, `getSymbol()`, `getAssignExprNode()` |
| `BlockStmtNode` | 语句块节点 | `getStmtNodes()`, `setParentScopeType()` |
| `ExprStmtNode` | 表达式语句节点 | `getExprNode()` |
| `AssignStmtNode` | 赋值语句节点 | `getLhs()`, `getRhs()` |
| `IfStmtNode` | 条件语句节点 | `getCondExpr()`, `getThenBlock()`, `getElseBlock()` |
| `WhileStmtNode` | 循环语句节点 | `getConditionNode()`, `getBlockNode()` |
| `ReturnStmtNode` | 返回语句节点 | `getRetNode()` |
| `BinaryExprNode` | 二元表达式节点 | `getOpType()`, `getLhs()`, `getRhs()` |
| `UnaryExprNode` | 一元表达式节点 | `getOpType()`, `getValExpr()` |
| `CallFuncNode` | 函数调用节点 | `getFuncName()`, `getArgsNode()` |
| `IDExprNode` | 标识符节点 | `getRefSymbol()`, `isLValue()` |

**子类层次**:
- **表达式节点**: `LiteralNode` → `IntExprNode`, `FloatExprNode`, `BoolExprNode`, `StringExprNode`

### 2.3 AST构建模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/pass/ast/`

| 类名 | 功能 | 关键方法 |
|------|------|----------|
| `CymbolASTBuilder` | AST构建器 | `visitCompilationUnit()`, `visitFunctionDecl()`, `visitVarDecl()`, `visitExprBinary()` |
| `ASTBaseVisitor` | AST访问者基类 | 提供visit模式的基础实现 |

### 2.4 符号表模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/symtab/`

**作用域管理**:
| 类名 | 功能 | 关键方法 |
|------|------|----------|
| `Scope` | 作用域基类 | `getEnclosingScope()`, `resolve()` |
| `GlobalScope` | 全局作用域 | 全局符号管理 |
| `LocalScope` | 局部作用域 | 局部符号管理 |
| `BaseScope` | 基础作用域实现 | `define()`, `resolve()` |

**符号定义**:
| 类名 | 功能 | 属性 |
|------|------|------|
| `Symbol` | 符号基类 | `name`, `type` |
| `VariableSymbol` | 变量符号 | 变量类型和名称 |
| `MethodSymbol` | 方法符号 | 参数列表、局部变量 |
| `ScopedSymbol` | 带作用域符号 | 关联作用域 |

**类型系统**:
| 类名 | 功能 |
|------|------|
| `Type` | 类型基类 |
| `BuiltInTypeSymbol` | 内置类型 |
| `OperatorType` | 运算符类型 |
| `TypeTable` | 类型表管理 |

### 2.5 IR模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/ir/`

| 类名 | 功能 | 关键方法 |
|------|------|----------|
| `IRNode` | IR节点基类 | 所有IR节点的父类 |
| `Prog` | 程序根节点 | `addBlock()`, `optimizeBasicBlock()`, `linearInstrs()` |

**操作数系统**:
| 类名 | 功能 | 说明 |
|------|------|------|
| `Operand` | 操作数基类 | 所有操作数的父类 |
| `ConstVal` | 常量值 | 整型、浮点型、布尔型常量 |
| `VarSlot` | 变量槽位 | 抽象变量位置 |
| `FrameSlot` | 栈帧槽位 | 对应栈帧中的变量 |
| `OperandSlot` | 临时操作数槽位 | 临时变量存储 |

**表达式IR**:
| 类名 | 功能 | 关键属性 |
|------|------|----------|
| `CallFunc` | 函数调用 | `funcName`, `args`, `methodSymbol` |
| `BinExpr` | 二元表达式 | `opType`, `lhs`, `rhs` |
| `UnaryExpr` | 一元表达式 | `opType`, `operand` |

**语句IR**:
| 类名 | 功能 | 关键属性 |
|------|------|----------|
| `Label` | 标签 | `scope`, `ord` |
| `FuncEntryLabel` | 函数入口标签 | `name`, `args`, `locals`, `methodSymbol` |
| `Assign` | 赋值语句 | `lhs`, `rhs` |
| `JMP` | 无条件跳转 | `next` |
| `CJMP` | 条件跳转 | `cond`, `thenBlock`, `elseBlock` |
| `ReturnVal` | 返回值 | `value`, `mainEntry` |
| `ExprStmt` | 表达式语句 | `expr` |

### 2.6 IR构建模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/pass/ir/`

| 类名 | 功能 | 关键方法 |
|------|------|----------|
| `CymbolIRBuilder` | IR构建器 | `visit(FuncDeclNode)`, `visit(BinaryExprNode)`, `visit(AssignStmtNode)`, `addInstr()` |

**核心算法**:
- 表达式求值栈管理: `pushEvalOperand()`, `popEvalOperand()`
- 控制流构建: `jump()`, `jumpIf()`
- 基本块管理: `forkNewBlock()`, `setCurrentBlock()`

### 2.7 CFG模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/pass/cfg/`

| 类名 | 功能 | 关键方法 |
|------|------|----------|
| `LinearIRBlock` | 线性IR块 | `addStmt()`, `getStmts()`, `getSuccessors()`, `setLink()` |
| `BasicBlock<I>` | 基本块 | `getIRNodes()`, `mergeNearBlock()`, `getLastInstr()` |
| `CFG<T>` | 控制流程图 | 管理基本块集合和边关系 |
| `CFGBuilder` | CFG构建器 | `build()`, `getCFG()` |

**CFG构建算法**:
1. 从线性IR块开始
2. 识别标签和跳转指令
3. 划分基本块边界
4. 构建基本块间边关系

### 2.8 语义分析模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/pass/semati c/`

| 类名 | 功能 | 关键方法 |
|------|------|----------|
| `TypeChecker` | 类型检查器 | 类型兼容性验证 |

### 2.9 代码生成模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/pass/codegen/`

| 类名 | 功能 | 关键方法 |
|------|------|----------|
| `CymbolAssembler` | 汇编代码生成器 | `visit(IRNode)`, `getAsmInfo()` |
| `CymbolVMIOperatorEmitter` | 虚拟机操作符发射器 | 操作符到汇编的转换 |
| `IOperatorEmitter` | 操作符发射器接口 | 标准发射器接口 |

### 2.10 调试器模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/debugger/`

| 类名 | 功能 |
|------|------|
| `Dumpable` | 可转储接口 |
| `Dumper` | 转储器 |
| `Dumper` | AST调试输出 |

### 2.11 错误处理模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/error/`

| 类名 | 功能 |
|------|------|
| `CymbalError` | 编译错误定义 |

### 2.12 工具模块
**位置**: `src/main/java/org/teachfx/antlr4/ep21/utils/`

| 类名 | 功能 |
|------|------|
| `Kind` | 指令类型枚举 |
| `StreamUtils` | 流操作工具 |
| `Loc<I>` | 位置包装器 |

## 3. 核心编译流程

### 3.1 主控制流程 (Compiler.java)

```java
public static void main(String[] args) {
    // 1. 语法分析
    CharStream charStream = CharStreams.fromStream(is);
    CymbolLexer lexer = new CymbolLexer(charStream);
    CommonTokenStream tokenStream = new CommonTokenStream(lexer);
    CymbolParser parser = new CymbolParser(tokenStream);
    ParseTree parseTree = parser.file();
    
    // 2. AST构建
    CymbolASTBuilder astBuilder = new CymbolASTBuilder();
    ASTNode astRoot = parseTree.accept(astBuilder);
    
    // 3. 符号表分析
    astRoot.accept(new LocalDefine());
    
    // 4. IR生成
    var irBuilder = new CymbolIRBuilder();
    astRoot.accept(irBuilder);
    
    // 5. 基本块优化
    irBuilder.prog.optimizeBasicBlock();
    
    // 6. CFG构建和分析
    for (cfg : getCFGs()) {
        cfg.addOptimizer(new ControlFlowAnalysis<>());
        cfg.applyOptimizers();
    }
    
    // 7. 代码生成
    var assembler = new CymbolAssembler();
    assembler.visit(irNodeList);
    saveToEp18Res(assembler.getAsmInfo());
}
```

### 3.2 AST构建流程
```
解析树节点 → CymbolASTBuilder.visit() → 对应AST节点类型
   ↓
CompilationUnitContext → visitCompilationUnit() → CompileUnit
   ↓
FunctionDeclContext → visitFunctionDecl() → FuncDeclNode
   ↓
VarDeclContext → visitVarDecl() → VarDeclNode
   ↓
ExprBinaryContext → visitExprBinary() → BinaryExprNode
```

### 3.3 IR生成流程
```
AST节点 → CymbolIRBuilder.visit() → IR指令
   ↓
BinaryExprNode → pushEvalOperand(lhs) → 二元运算
   ↓                    → pushEvalOperand(rhs)
   ↓                    → addInstr(BinExpr)
   ↓
AssignStmtNode → visit(rhs) → pushEvalOperand()
   ↓                 → Assign.with(lhs, rhs)
   ↓
WhileStmtNode → 条件块 → do块 → end块
   ↓            → CJMP指令 → JMP指令
```

### 3.4 CFG构建流程
```
LinearIRBlock序列 → CFGBuilder.build() → BasicBlock集合
   ↓
识别标签指令 → 基本块开始
   ↓
识别跳转指令 → 基本块结束
   ↓
JMP指令 → 无条件边
   ↓
CJMP指令 → 条件边(then, else)
```

## 4. 关键数据流

### 4.1 符号表数据流
```
局部定义分析 → 作用域层次构建 → 符号引用解析
```

### 4.2 IR数据流
```
表达式求值栈 → 临时变量生成 → 指令序列构建
```

### 4.3 CFG数据流
```
基本块划分 → 边关系构建 → 控制流分析
```

## 5. 设计模式应用总结

| 模式名称 | 应用位置 | 作用 |
|----------|----------|------|
| 访问者模式 | ASTVisitor, IRVisitor | 分离数据结构和操作 |
| 构建者模式 | CymbolASTBuilder, CymbolIRBuilder | 简化复杂对象构建 |
| 工厂模式 | OperandSlot.pushStack() | 动态创建对象 |
| 组合模式 | BlockStmtNode, CompileUnit | 统一处理层次结构 |

## 6. 扩展点

### 6.1 优化器扩展
- 实现 `IFlowOptimizer` 接口
- 集成到CFG优化链

### 6.2 目标代码生成扩展
- 实现 `IOperatorEmitter` 接口
- 支持不同目标架构

### 6.3 类型系统扩展
- 扩展内置类型
- 添加用户定义类型

## 7. 性能特性

### 7.1 内存优化
- 对象池管理临时变量
- 延迟计算减少中间结果

### 7.2 算法效率
- 拓扑排序CFG构建
- 基本块合并优化

该单元概要为理解和维护EP21编译器提供了清晰的模块划分和关键接口说明。