# EP21: é«˜çº§æ•°æ®æµä¼˜åŒ– - æ•™å­¦æ–‡æ¡£

**ç¼–è¯‘å™¨æ„é€ é˜¶æ®µ**: ä¼˜åŒ–å±‚
**éš¾åº¦ç­‰çº§**: â­â­â­â­â­ ä¸“å®¶
**é¢„è®¡å­¦æ—¶**: 12å°æ—¶
**å‰ç½®çŸ¥è¯†**: EP12ï¼ˆSSAæ„å»ºï¼‰ã€EP13ï¼ˆæ•°æ®æµåˆ†æï¼‰ã€EP17ï¼ˆCFGæ„å»ºï¼‰

---

## ğŸ“š å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬EPåï¼Œä½ å°†èƒ½å¤Ÿï¼š

- [ ] ç†è§£æ•°æ®æµåˆ†æçš„æ•°å­¦åŸºç¡€ï¼ˆåŠæ ¼ã€ä¼ é€’å‡½æ•°ã€ä¸åŠ¨ç‚¹ç®—æ³•ï¼‰
- [ ] å®ç°å‰å‘å’Œåå‘æ•°æ®æµåˆ†ææ¡†æ¶
- [ ] æŒæ¡CFGä¸Šçš„å›¾ç®—æ³•ï¼ˆå¯è¾¾æ€§ã€æ”¯é…åˆ†æï¼‰
- [ ] å®ç°æ­»ä»£ç æ¶ˆé™¤ä¼˜åŒ–
- [ ] å®ç°å¸¸é‡æŠ˜å ä¼˜åŒ–
- [ ] ç†è§£æ´»è·ƒå˜é‡åˆ†æåŠå…¶åº”ç”¨
- [ ] æŒæ¡ä¼˜åŒ–å™¨çš„è®¾è®¡æ¨¡å¼ï¼ˆç­–ç•¥æ¨¡å¼ã€è®¿é—®è€…æ¨¡å¼ï¼‰

---

# Layer 1: æ¶æ„å…¨æ™¯å›¾

## 1.1 EP21åœ¨ç¼–è¯‘æµç¨‹ä¸­çš„ä½ç½®

```
å®Œæ•´ç¼–è¯‘æµç¨‹:

æºä»£ç 
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å‰ç«¯ (EP1-10)                                       â”‚
â”‚  è¯æ³• â†’ è¯­æ³• â†’ AST â†’ ç±»å‹ â†’ ç¬¦å· â†’ è¯­ä¹‰              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¸­ç«¯ (EP11-17)                                      â”‚
â”‚  è‡ªå®šä¹‰AST â†’ SSA â†’ CFG â†’ æ•°æ®æµåˆ†æ                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä¼˜åŒ–å±‚ (EP21) â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æœ¬EP       â”‚
â”‚  æ•°æ®æµæ¡†æ¶ â†’ æ´»è·ƒåˆ†æ â†’ ä¼˜åŒ–Pass â†’ ä¼˜åŒ–å™¨é“¾          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åç«¯ (EP16-20)                                      â”‚
â”‚  LIR â†’ ä»£ç ç”Ÿæˆ â†’ å­—èŠ‚ç                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“
ç›®æ ‡ç¨‹åº
```

**EP21çš„èŒè´£**: åœ¨ä¸­ç«¯IRå’Œåç«¯ä»£ç ç”Ÿæˆä¹‹é—´ï¼Œæå‡ç¨‹åºæ€§èƒ½

---

## 1.2 EP21å†…éƒ¨ï¼š5ä¸»é¢˜çš„åˆ†å±‚ä¾èµ–å…³ç³»

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                EP21 ä¼˜åŒ–ç³»ç»Ÿçš„åˆ†å±‚æ¶æ„                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç¬¬1å±‚: åŸºç¡€æ¡†æ¶ (ä¸»é¢˜ä¸€)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AbstractDataFlowAnalysis<T>                        â”‚
â”‚  â”œâ”€ analyze(): è¿­ä»£æ±‚è§£ç®—æ³•                         â”‚
â”‚  â”œâ”€ forwardIteration(): å‰å‘éå†                    â”‚
â”‚  â”œâ”€ backwardIteration(): åå‘éå†                   â”‚
â”‚  â””â”€ [æŠ½è±¡æ–¹æ³•] meet(), transfer(), isForward()      â”‚
â”‚                                                        â”‚
â”‚  ç›®æ ‡: æä¾›é€šç”¨çš„æ•°æ®æµåˆ†æèƒ½åŠ›                         â”‚
â”‚  äº§å‡º: å¯å¤ç”¨çš„åˆ†ææ¡†æ¶                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
                        â”‚ ç»§æ‰¿/æ‰©å±•
                        â†“
ç¬¬2å±‚: å…·ä½“åˆ†æ (ä¸»é¢˜äºŒ)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LiveVariableAnalysis extends AbstractDataFlowAnalysis â”‚
â”‚  â”œâ”€ isForward(): return false (åå‘åˆ†æ)             â”‚
â”‚  â”œâ”€ meet(): å¹¶é›†æ“ä½œ                                 â”‚
â”‚  â””â”€ transfer(): IN = use âˆª (OUT \ def)               â”‚
â”‚                                                        â”‚
â”‚  ç›®æ ‡: å®ç°æ´»è·ƒå˜é‡åˆ†æ                               â”‚
â”‚  äº§å‡º: æ¯ä¸ªç¨‹åºç‚¹çš„æ´»è·ƒå˜é‡é›†åˆ                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
                        â”‚ è¢«ä½¿ç”¨
                        â†“
ç¬¬3å±‚: ä¼˜åŒ–å™¨ (ä¸»é¢˜ä¸‰ã€å››)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DeadCodeEliminationOptimizer            â”‚ â”‚ ç‹¬ç«‹ä¼˜åŒ–å™¨â”‚
â”‚  â”œâ”€ eliminateUnreachableCode()          â”‚ â”‚          â”‚
â”‚  â””â”€ eliminateDeadStores()               â”‚ â”‚ - å¸¸é‡æŠ˜å â”‚
â”‚       â†“ ä½¿ç”¨                            â”‚ â”‚ - CSE    â”‚
â”‚   LiveVariableAnalysis                   â”‚ â”‚ - å°¾é€’å½’ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
                        â”‚ æ³¨å†Œåˆ°
                        â†“
ç¬¬4å±‚: ä¼˜åŒ–å™¨é“¾ (ä¸»é¢˜äº”)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CFG.applyOptimizers()                              â”‚
â”‚  â”œâ”€ Pass 1: ConstantFoldingOptimizer               â”‚
â”‚  â”œâ”€ Pass 2: DeadCodeEliminationOptimizer           â”‚
â”‚  â”œâ”€ Pass 3: CommonSubexpressionEliminationOptimizerâ”‚
â”‚  â””â”€ Pass 4: TailRecursionOptimizer                 â”‚
â”‚                                                        â”‚
â”‚  ç›®æ ‡: æŒ‰åºæ‰§è¡Œå¤šä¸ªä¼˜åŒ–Pass                           â”‚
â”‚  äº§å‡º: ä¼˜åŒ–çš„CFG                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1.3 4é˜¶æ®µæ„å»ºé€»è¾‘

```
é˜¶æ®µ1: æ„å»ºåˆ†ææ¡†æ¶ (ä¸»é¢˜ä¸€)
  â””â”€ ç›®æ ‡: å®ç° AbstractDataFlowAnalysis
     â””â”€ æä¾›é€šç”¨çš„è¿­ä»£æ±‚è§£ç®—æ³•
     â””â”€ å®šä¹‰æ•°æ®æµåˆ†æçš„æ¥å£å¥‘çº¦

é˜¶æ®µ2: å®ç°å…·ä½“åˆ†æ (ä¸»é¢˜äºŒ)
  â””â”€ ç›®æ ‡: å®ç° LiveVariableAnalysis
     â””â”€ ç»§æ‰¿ AbstractDataFlowAnalysis
     â””â”€ å®ç°æ´»è·ƒå˜é‡åˆ†æçš„GEN/KILLé›†åˆ

é˜¶æ®µ3: åº”ç”¨åˆ†æè¿›è¡Œä¼˜åŒ– (ä¸»é¢˜ä¸‰ã€å››)
  â””â”€ ç›®æ ‡: å®ç°å„ç§ Optimizer
     â””â”€ å¸¸é‡æŠ˜å : ç‹¬ç«‹ä¼˜åŒ–ï¼Œä¸ä¾èµ–åˆ†æ
     â””â”€ æ­»ä»£ç æ¶ˆé™¤: ä½¿ç”¨ LiveVariableAnalysis
     â””â”€ å…¶ä»–ä¼˜åŒ–: ç‹¬ç«‹æˆ–ç»„åˆ

é˜¶æ®µ4: ç»„åˆä¼˜åŒ–å™¨é“¾ (ä¸»é¢˜äº”)
  â””â”€ ç›®æ ‡: å®ç° CFG.addOptimizer() + applyOptimizers()
     â””â”€ æ³¨å†Œå¤šä¸ªä¼˜åŒ–å™¨
     â””â”€ æŒ‰åºæ‰§è¡Œï¼Œå‰ä¸€ä¸ªçš„è¾“å‡ºæ˜¯åä¸€ä¸ªçš„è¾“å…¥
```

**å…³é”®è®¾è®¡åŸåˆ™**:
- **åˆ†å±‚æ„å»º**: æ¯å±‚ä¾èµ–ä¸Šå±‚ï¼Œé€å±‚å®Œå–„åŠŸèƒ½
- **æœ€å°ä¾èµ–**: å¤§éƒ¨åˆ†ä¼˜åŒ–å™¨ç‹¬ç«‹ï¼Œå¯å¹¶è¡Œå¼€å‘
- **å¯æ‰©å±•**: æ˜“äºæ·»åŠ æ–°çš„åˆ†ææˆ–ä¼˜åŒ–å™¨

---

## 1.4 å­¦ä¹ è·¯å¾„æŒ‡å¼•

```
æ¨èå­¦ä¹ é¡ºåº:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸»é¢˜ä¸€: æ•°æ®æµåˆ†ææ¡†æ¶ (3å°æ—¶)                   â”‚
â”‚ â†’ è¿™æ˜¯æ‰€æœ‰åç»­åˆ†æçš„åŸºç¡€ï¼Œå¿…é¡»å…ˆæŒæ¡            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“ å¿…é¡»å…ˆå®Œæˆ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸»é¢˜äºŒ: æ´»è·ƒå˜é‡åˆ†æ (2å°æ—¶)                     â”‚
â”‚ â†’ ç»§æ‰¿ä¸»é¢˜ä¸€çš„æ¡†æ¶ï¼Œå®ç°å…·ä½“çš„åå‘åˆ†æ           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“ è¢«ä»¥ä¸‹ä¸»é¢˜ä½¿ç”¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸»é¢˜ä¸‰: æ­»ä»£ç æ¶ˆé™¤ (2å°æ—¶)                       â”‚
â”‚ â†’ ä½¿ç”¨ä¸»é¢˜äºŒçš„æ´»è·ƒå˜é‡åˆ†æç»“æœ                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸»é¢˜å››: å¸¸é‡æŠ˜å  (2å°æ—¶)                         â”‚
â”‚ â†’ ç‹¬ç«‹ä¼˜åŒ–ï¼Œå¯ä¸ä¸»é¢˜ä¸‰å¹¶è¡Œå­¦ä¹                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸»é¢˜äº”: ä¼˜åŒ–å™¨é“¾è®¾è®¡ (1å°æ—¶)                     â”‚
â”‚ â†’ å°†æ‰€æœ‰ä¼˜åŒ–å™¨ç»„åˆæˆå®Œæ•´çš„ä¼˜åŒ–æµç¨‹               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç»¼åˆå®æˆ˜: ç«¯åˆ°ç«¯ä¼˜åŒ–æµç¨‹ (2å°æ—¶)                 â”‚
â”‚ â†’ ä»é›¶æ„å»ºå®Œæ•´çš„ä¼˜åŒ–ç³»ç»Ÿ                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š ç†è®ºæ•™æç´¢å¼•

### å¯¹åº”ã€Šç¼–è¯‘åŸç†ã€‹ï¼ˆé¾™ä¹¦ç¬¬äºŒç‰ˆï¼‰

**å¯¹åº”ç« èŠ‚**: ç¬¬9ç« ï¼šæœºå™¨æ— å…³ä¼˜åŒ–

**å…³é”®ç†è®ºæ¦‚å¿µ**:
- **æ•°æ®æµåˆ†æ**: åœ¨ç¼–è¯‘æ—¶æ¨å¯¼ç¨‹åºè¿è¡Œæ—¶ä¿¡æ¯çš„é™æ€åˆ†ææŠ€æœ¯
- **åŠæ ¼ï¼ˆSemilatticeï¼‰**: å¸¦æœ‰meetè¿ç®—ï¼ˆâˆ©ï¼‰çš„ååºé›†ï¼Œè¡¨ç¤ºæ•°æ®æµå€¼çš„åˆå¹¶æ–¹å¼
- **ä¼ é€’å‡½æ•°ï¼ˆTransfer Functionï¼‰**: æè¿°ä¸€æ¡æŒ‡ä»¤å¦‚ä½•æ”¹å˜æ•°æ®æµå€¼çš„å‡½æ•°
- **ä¸åŠ¨ç‚¹ç®—æ³•**: è¿­ä»£æ±‚è§£æ•°æ®æµæ–¹ç¨‹ç›´åˆ°æ”¶æ•›çš„ç®—æ³•
- **æ´»è·ƒå˜é‡åˆ†æ**: åˆ¤æ–­å˜é‡åœ¨æŸä¸ªç¨‹åºç‚¹æ˜¯å¦ä¼šè¢«ä½¿ç”¨çš„åå‘æ•°æ®æµåˆ†æ
- **æ­»ä»£ç æ¶ˆé™¤**: åˆ é™¤ä¸å¯è¾¾ä»£ç å’Œæ­»å­˜å‚¨çš„ä¼˜åŒ–æŠ€æœ¯
- **å¸¸é‡æŠ˜å **: åœ¨ç¼–è¯‘æ—¶è®¡ç®—å¸¸é‡è¡¨è¾¾å¼å¹¶ç”¨ç»“æœæ›¿æ¢çš„ä¼˜åŒ–
- **ä¼˜åŒ–å™¨Pass**: ç‹¬ç«‹çš„ä¼˜åŒ–è½¬æ¢ï¼Œå¯ä»¥æŒ‰é¡ºåºç»„åˆæ‰§è¡Œ

**ç†è®ºå®è·µå¯¹ç…§**:
| é¾™ä¹¦æ¦‚å¿µ | æœ¬EPå®ç° | å­¦ä¹ è¦ç‚¹ |
|---------|---------|---------|
| æ•°æ®æµæ–¹ç¨‹ | AbstractDataFlowAnalysis<T> | ç†è®ºï¼šæ•°å­¦å½¢å¼åŒ– â†’ å®è·µï¼šæ³›å‹æ¡†æ¶ |
| åŠæ ¼ç†è®º | meet()æ–¹æ³• + initialize()è¾¹ç•Œæ¡ä»¶ | ç†è®ºï¼šååºé›† â†’ å®è·µï¼šé›†åˆè¿ç®— |
| å‰å‘/åå‘åˆ†æ | isForward()æ–¹å‘æ ‡è®° | ç†è®ºï¼šåˆ†ææ–¹å‘ â†’ å®è·µï¼šå¸ƒå°”æ ‡å¿— |
| ä¼ é€’å‡½æ•° | transfer()æ–¹æ³• | ç†è®ºï¼šf: Lâ†’L â†’ å®è·µï¼šJavaå‡½æ•° |
| ä¸åŠ¨ç‚¹è¿­ä»£ | analyze()è¿­ä»£ç®—æ³• | ç†è®ºï¼šæ”¶æ•›æ€§è¯æ˜ â†’ å®è·µï¼šwhileå¾ªç¯ |
| æ´»è·ƒå˜é‡åˆ†æ | LiveVariableAnalysis | ç†è®ºï¼šGEN/KILLé›†åˆ â†’ å®è·µï¼šç»§æ‰¿æ¡†æ¶ |
| ä¼˜åŒ–Pass | IFlowOptimizeræ¥å£ | ç†è®ºï¼šä¼˜åŒ–è½¬æ¢ â†’ å®è·µï¼šç­–ç•¥æ¨¡å¼ |
| ä¼˜åŒ–å™¨é“¾ | CFG.applyOptimizers() | ç†è®ºï¼šPassç»„åˆ â†’ å®è·µï¼šè´£ä»»é“¾æ¨¡å¼ |

**æ¨èå­¦ä¹ è·¯å¾„**:
1. é˜…è¯»é¾™ä¹¦ç¬¬9.1-9.2èŠ‚ï¼ˆ3å°æ—¶ï¼‰- ç†è§£ä¼˜åŒ–çš„åŸºæœ¬æ¦‚å¿µå’Œæ•°æ®æµåˆ†æåŸºç¡€
2. é˜…è¯»é¾™ä¹¦ç¬¬9.3èŠ‚ï¼ˆ2å°æ—¶ï¼‰- ç†è§£æ´»è·ƒå˜é‡åˆ†æç­‰å…·ä½“åˆ†æ
3. é˜…è¯»é¾™ä¹¦ç¬¬9.4-9.5èŠ‚ï¼ˆ3å°æ—¶ï¼‰- ç†è§£å¸¸é‡ä¼ æ’­ã€æ­»ä»£ç æ¶ˆé™¤ç­‰ä¼˜åŒ–æŠ€æœ¯
4. å®Œæˆæœ¬EPå®è·µï¼ˆ12å°æ—¶ï¼‰- å®ç°æ•°æ®æµæ¡†æ¶å’Œå„ç§ä¼˜åŒ–å™¨
5. å¯¹æ¯”æ€»ç»“ï¼ˆ2å°æ—¶ï¼‰- ç†è®ºä¿è¯ vs å·¥ç¨‹æƒè¡¡

**è¡¥å……é˜…è¯»**:
- **SSAè®ºæ–‡**: Cytron et al. 1991 - "Efficiently Computing Static Single Assignment Form and the Control Dependence Graph"ï¼ˆé¾™ä¹¦æœªè¦†ç›–SSAçš„è¯¦ç»†æ„å»ºç®—æ³•ï¼‰
- **LLVMæ–‡æ¡£**: Getting Started with LLVM - ç†è§£å·¥ä¸šçº§ä¼˜åŒ–å™¨çš„è®¾è®¡
- **Whitneyè®ºæ–‡**: "A Survey of Compiler Optimization Techniques" - ä¼˜åŒ–æŠ€æœ¯å…¨æ™¯
- **æ•°æ®æµåˆ†æ**: "Data Flow Analysis: A Practical Approach"ï¼ˆMuchnick - ç¼–è¯‘å™¨è®¾è®¡ä¸å®ç°ï¼‰

**å­¦ä¹ æç¤º**:
- é¾™ä¹¦ç¬¬9ç« æ˜¯ä¼˜åŒ–çš„ç†è®ºæ ¸å¿ƒï¼Œä½†æ•°å­¦å½¢å¼åŒ–è¾ƒé‡
- æœ¬EPå°†æ•°å­¦ç†è®ºè½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„Javaä»£ç ï¼Œæ˜¯ç†è®ºåˆ°å®è·µçš„å…³é”®æ¡¥æ¢
- æ•°æ®æµåˆ†ææ¡†æ¶æ˜¯æ¨¡æ¿æ–¹æ³•æ¨¡å¼çš„å…¸å‹åº”ç”¨
- ç†è§£"å‰å‘ vs åå‘"ã€"GEN/KILL"ã€"meetè¿ç®—"è¿™ä¸‰ç»„æ¦‚å¿µæ˜¯å…³é”®
- é¾™ä¹¦é‡ç‚¹è®²è§£åˆ°è¾¾å®šä¹‰åˆ†æï¼Œæœ¬EPé€‰æ‹©æ´»è·ƒå˜é‡åˆ†æä½œä¸ºå®è·µæ¡ˆä¾‹
- ä¼˜åŒ–å™¨çš„é¡ºåºéå¸¸é‡è¦ï¼šå¸¸é‡æŠ˜å  â†’ æ­»ä»£ç æ¶ˆé™¤ â†’ å†æ¬¡æ­»ä»£ç æ¶ˆé™¤
- ç†è®ºä¿è¯å®‰å…¨æ€§ï¼ˆover-approximationï¼‰ï¼Œå®è·µå…³æ³¨æ€§èƒ½å’Œå¯ç”¨æ€§
- ä¸åŠ¨ç‚¹ç®—æ³•çš„å¤æ‚åº¦æ˜¯O(NÃ—H)ï¼ŒNæ˜¯èŠ‚ç‚¹æ•°ï¼ŒHæ˜¯åŠæ ¼é«˜åº¦
- ç†è§£ä¸ºä»€ä¹ˆéœ€è¦ä¸åŠ¨ç‚¹ï¼šæ•°æ®æµå€¼å¯èƒ½éœ€è¦å¤šæ¬¡è¿­ä»£æ‰èƒ½æ”¶æ•›

**æ•°å­¦åŸºç¡€è¦æ±‚**:
- é›†åˆè®ºï¼šå¹¶é›†ã€äº¤é›†ã€å·®é›†è¿ç®—
- ååºé›†ï¼šéƒ¨åˆ†æœ‰åºã€ä¸Šç•Œã€ä¸‹ç•Œ
- æ ¼è®ºï¼šåŠæ ¼ã€meetè¿ç®—ã€å•è°ƒå‡½æ•°
- å›¾è®ºï¼šCFGã€å¯è¾¾æ€§ã€æ‹“æ‰‘æ’åº

**å®è·µvsç†è®ºçš„å…³é”®å·®å¼‚**:
- ç†è®ºä½¿ç”¨æ•°å­¦ç¬¦å·è¯æ˜æ­£ç¡®æ€§ï¼Œå®è·µä½¿ç”¨ä»£ç å®ç°å¯æ‰§è¡Œç³»ç»Ÿ
- ç†è®ºå‡è®¾ç†æƒ³çš„æ— é™ç²¾åº¦ï¼Œå®è·µéœ€è¦å¤„ç†å·¥ç¨‹çº¦æŸ
- ç†è®ºè¿½æ±‚å½¢å¼åŒ–çš„å®Œå¤‡æ€§ï¼Œå®è·µè¿½æ±‚å¯ç»´æŠ¤å’Œæ‰©å±•æ€§

---

# Layer 2: ä¸»é¢˜å•å…ƒ

## ğŸ“ ä¸»é¢˜ä¸€ï¼šæ•°æ®æµåˆ†ææ¡†æ¶

> **å­¦ä¹ æ—¶é—´**: 3å°æ—¶ | **éš¾åº¦**: â­â­â­â­ | **ç›®æ ‡**: å®ç°é€šç”¨çš„æ•°æ®æµåˆ†ææ¡†æ¶

### ğŸ“ æœ¬ä¸»é¢˜åœ¨EP21ä¸­çš„ä½ç½®

```
EP21å†…éƒ¨æ„é€ :
é˜¶æ®µ1: [æ•°æ®æµåˆ†ææ¡†æ¶] â† æœ¬ä¸»é¢˜ âœï¸
       â†“ ç»§æ‰¿/æ‰©å±•
é˜¶æ®µ2: [æ´»è·ƒå˜é‡åˆ†æ] â† ä¸»é¢˜äºŒ
       â†“ è¢«ä½¿ç”¨
é˜¶æ®µ3: [æ­»ä»£ç æ¶ˆé™¤] â† ä¸»é¢˜ä¸‰
```

### ğŸ”— ä¸»é¢˜é—´çš„ä¾èµ–å…³ç³»

**åç»­åº”ç”¨**: ä¸»é¢˜äºŒï¼ˆæ´»è·ƒå˜é‡åˆ†æï¼‰
- ä¸»é¢˜äºŒ**ç»§æ‰¿**æœ¬ä¸»é¢˜çš„AbstractDataFlowAnalysis
- ä¸ºä»€ä¹ˆéœ€è¦æ¡†æ¶ï¼Ÿâ†’ é¿å…é‡å¤å®ç°è¿­ä»£æ±‚è§£ç®—æ³•
- æ¡†æ¶æä¾›ä»€ä¹ˆï¼Ÿâ†’ analyze()é€šç”¨ç®—æ³•ï¼Œå­ç±»åªéœ€å®ç°meet/transfer

**å…¶ä»–åç»­åº”ç”¨**: ä»»ä½•æ•°æ®æµåˆ†æ
- åˆ°è¾¾å®šä¹‰åˆ†æï¼ˆReachingDefinitionsï¼‰
- å¯ç”¨è¡¨è¾¾å¼åˆ†æï¼ˆAvailableExpressionsï¼‰
- å¸¸é‡ä¼ æ’­ï¼ˆConstantPropagationï¼‰

---

### 1.1 æ ¸å¿ƒæ¦‚å¿µ

#### ä»€ä¹ˆæ˜¯æ•°æ®æµåˆ†æï¼Ÿ

**å®šä¹‰**: åœ¨ç¼–è¯‘æ—¶æ¨å¯¼ç¨‹åºè¿è¡Œæ—¶ä¿¡æ¯çš„é™æ€åˆ†ææŠ€æœ¯

**æœ¬è´¨**: å›ç­”"åœ¨ç¨‹åºçš„æŸä¸ªç‚¹ï¼Œå˜é‡xçš„å¯èƒ½å€¼æ˜¯ä»€ä¹ˆï¼Ÿ"

**åº”ç”¨åœºæ™¯**:
- **ä¼˜åŒ–**: å¸¸é‡ä¼ æ’­ã€æ­»ä»£ç æ¶ˆé™¤
- **éªŒè¯**: ç±»å‹æ£€æŸ¥ã€ç©ºæŒ‡é’ˆåˆ†æ
- **è½¬æ¢**: SSAæ„å»ºã€å¯„å­˜å™¨åˆ†é…

#### æ•°æ®æµåˆ†æçš„ä¸‰å¤§è¦ç´ 

**è¦ç´ 1: æ–¹å‘ï¼ˆDirectionï¼‰**

```
å‰å‘åˆ†æ: å…¥å£ â†’ å‡ºå£
ç¤ºä¾‹: åˆ°è¾¾å®šä¹‰åˆ†æã€å¯ç”¨è¡¨è¾¾å¼åˆ†æ

åå‘åˆ†æ: å‡ºå£ â†’ å…¥å£
ç¤ºä¾‹: æ´»è·ƒå˜é‡åˆ†æã€éå¸¸é‡è¡¨è¾¾å¼åˆ†æ
```

**è¦ç´ 2: åŠæ ¼ï¼ˆSemilatticeï¼‰**

**å®šä¹‰**: ä¸€ä¸ªå¸¦æœ‰meetè¿ç®—ï¼ˆâˆ©ï¼‰çš„ååºé›†

**ä½œç”¨**: è¡¨ç¤ºæ•°æ®æµå€¼çš„åˆå¹¶æ–¹å¼

**å¸¸è§åŠæ ¼**:
```java
// é›†åˆåŠæ ¼ï¼ˆç”¨äºåˆ°è¾¾å®šä¹‰ï¼‰
L = P(å˜é‡å®šä¹‰)    // å˜é‡å®šä¹‰çš„å¹‚é›†
âŠ¤ = âˆ…             // ç©ºé›†ï¼ˆæœ€å¤§å…ƒç´ ï¼‰
âŠ¥ = å…¨é›†          // æ‰€æœ‰å®šä¹‰ï¼ˆæœ€å°å…ƒç´ ï¼‰
x âŠ“ y = x âˆª y      // meetè¿ç®— = å¹¶é›†

// å¸¸é‡å€¼åŠæ ¼ï¼ˆç”¨äºå¸¸é‡ä¼ æ’­ï¼‰
L = {âŠ¤, âŠ¥, câ‚, câ‚‚, ...}  // top + bottom + æ‰€æœ‰å¸¸é‡
âŠ¤ = unknown              // æœªçŸ¥å€¼
âŠ¥ = undefined            // æœªå®šä¹‰
câ‚ âŠ“ câ‚‚ =
    if câ‚ == câ‚‚: câ‚       // ç›¸ç­‰åˆ™åˆå¹¶
    else: âŠ¤              // ä¸ç­‰åˆ™æœªçŸ¥
```

**è¦ç´ 3: ä¼ é€’å‡½æ•°ï¼ˆTransfer Functionï¼‰**

**å®šä¹‰**: æè¿°ä¸€æ¡æŒ‡ä»¤å¦‚ä½•æ”¹å˜æ•°æ®æµå€¼

**ç¬¦å·**: `f: L â†’ L`ï¼ˆLæ˜¯åŠæ ¼ï¼‰

**è¦æ±‚**: å•è°ƒå‡½æ•°ï¼ˆä¿æŒååºå…³ç³»ï¼‰

**ç¤ºä¾‹**:
```java
// å¯¹äºè¯­å¥ "x = 5"
// ä¼ é€’å‡½æ•°: OUT = IN âˆª {xçš„å®šä¹‰}

// å¯¹äºè¯­å¥ "y = x + 1"
// å¦‚æœxåœ¨INä¸­ï¼Œåˆ™ä½¿ç”¨xçš„å®šä¹‰
// ä¼ é€’å‡½æ•°è§†å…·ä½“åˆ†æè€Œå®š
```

#### æ•°æ®æµæ–¹ç¨‹

**å‰å‘åˆ†ææ–¹ç¨‹**:
```
IN[B] = â‹‚_{Pâˆˆpred(B)} OUT[P]    # meetæ‰€æœ‰å‰é©±çš„OUT
OUT[B] = f_B(IN[B])             # åº”ç”¨ä¼ é€’å‡½æ•°
```

**åå‘åˆ†ææ–¹ç¨‹**:
```
OUT[B] = â‹‚_{Sâˆˆsucc(B)} IN[S]   # meetæ‰€æœ‰åç»§çš„IN
IN[B] = f_B(OUT[B])             # åº”ç”¨ä¼ é€’å‡½æ•°
```

**ä¸åŠ¨ç‚¹ç®—æ³•**:
```
# åˆå§‹åŒ–
for all blocks B:
    IN[B] = âŠ¤   # æˆ– âŠ¥ï¼Œå–å†³äºåˆ†ææ–¹å‘
    OUT[B] = âŠ¤

# è¿­ä»£ç›´åˆ°ä¸åŠ¨ç‚¹
while (changed):
    for all blocks B:
        IN[B] = meet(æ‰€æœ‰å‰é©±/åç»§)
        new_OUT = f_B(IN[B])
        if new_OUT != OUT[B]:
            OUT[B] = new_OUT
            changed = true
```

**å…³é”®æ€§è´¨**:
- **å®‰å…¨æ€§**: åˆ†æç»“æœå¿…é¡»æ˜¯å®é™…è¡Œä¸ºçš„è¶…é›†ï¼ˆover-approximationï¼‰
- **æ”¶æ•›æ€§**: ç®—æ³•å¿…ç„¶ç»ˆæ­¢ï¼ˆåŠæ ¼é«˜åº¦æœ‰é™ï¼‰
- **å¤æ‚åº¦**: O(N Ã— H)ï¼ŒNæ˜¯èŠ‚ç‚¹æ•°ï¼ŒHæ˜¯åŠæ ¼é«˜åº¦

---

### 1.2 å®ç°åŸç†

#### æ¡†æ¶è®¾è®¡

**ç›®æ ‡**: å®ç°ä¸€ä¸ªé€šç”¨æ¡†æ¶ï¼Œæ”¯æŒæ‰€æœ‰å‰å‘/åå‘æ•°æ®æµåˆ†æ

**è®¾è®¡æ¨¡å¼**: **æ¨¡æ¿æ–¹æ³•æ¨¡å¼**

```
AbstractDataFlowAnalysis (æŠ½è±¡åŸºç±»)
â”œâ”€â”€ analyze()           # ç®—æ³•éª¨æ¶ï¼ˆæ¨¡æ¿æ–¹æ³•ï¼‰
â”œâ”€â”€ initialize()        # åˆå§‹åŒ–ï¼ˆå­ç±»å®ç°ï¼‰
â”œâ”€â”€ meet()              # meetè¿ç®—ï¼ˆå­ç±»å®ç°ï¼‰
â”œâ”€â”€ transfer()          # ä¼ é€’å‡½æ•°ï¼ˆå­ç±»å®ç°ï¼‰
â”œâ”€â”€ isForward()         # åˆ†ææ–¹å‘ï¼ˆå­ç±»å®ç°ï¼‰
â””â”€â”€ boundaryCondition() # è¾¹ç•Œæ¡ä»¶ï¼ˆå­ç±»å®ç°ï¼‰

å…·ä½“åˆ†æç±»ï¼ˆå­ç±»ï¼‰
â”œâ”€â”€ LiveVariableAnalysis
â”œâ”€â”€ ReachingDefinitionsAnalysis
â”œâ”€â”€ AvailableExpressionsAnalysis
â””â”€â”€ ...
```

#### å…³é”®ä»£ç å®ç°

**æ­¥éª¤1: å®šä¹‰æŠ½è±¡åŸºç±»**

```java
public abstract class AbstractDataFlowAnalysis<T> {
    protected static final int MAX_ITERATIONS = 1000;

    // åˆ†ææ–¹å‘ï¼ˆå­ç±»å®ç°ï¼‰
    public abstract boolean isForward();

    // åˆå§‹åŒ–è¾¹ç•Œæ¡ä»¶ï¼ˆå­ç±»å®ç°ï¼‰
    protected abstract T initialize();

    // meetè¿ç®—ï¼ˆå­ç±»å®ç°ï¼‰
    protected abstract T meet(Set<T> sets);

    // ä¼ é€’å‡½æ•°ï¼ˆå­ç±»å®ç°ï¼‰
    protected abstract T transfer(T in, BasicBlock block);

    // è¾¹ç•Œæ¡ä»¶ï¼ˆå…¥å£/å‡ºå£å—çš„åˆå§‹å€¼ï¼‰
    protected abstract T boundaryCondition();

    // ç®—æ³•éª¨æ¶ï¼ˆæ¨¡æ¿æ–¹æ³•ï¼‰
    public DataFlowResult<T> analyze(CFG cfg) {
        // ... å®ç°è§ä¸‹æ–‡
    }
}
```

**æ­¥éª¤2: å®ç°å‰å‘è¿­ä»£ç®—æ³•**

```java
protected DataFlowResult<T> forwardIteration(CFG cfg) {
    Map<BasicBlock, T> inSets = new HashMap<>();
    Map<BasicBlock, T> outSets = new HashMap<>();
    Map<BasicBlock, T> oldOutSets = new HashMap<>();

    // 1. åˆå§‹åŒ–æ‰€æœ‰åŸºæœ¬å—
    for (BasicBlock block : cfg.getBlocks()) {
        T init = initialize();
        inSets.put(block, init);
        outSets.put(block, init);
    }

    // 2. è®¾ç½®å…¥å£å—è¾¹ç•Œæ¡ä»¶
    BasicBlock entryBlock = cfg.getEntryBlock();
    if (entryBlock != null) {
        inSets.put(entryBlock, boundaryCondition());
    }

    boolean changed;
    int iterations = 0;

    // 3. ä¸åŠ¨ç‚¹è¿­ä»£
    do {
        changed = false;
        iterations++;

        // ä¿å­˜æ—§å€¼
        for (BasicBlock block : cfg.getBlocks()) {
            oldOutSets.put(block, outSets.get(block));
        }

        // 4. æŒ‰æ‹“æ‰‘åºå¤„ç†
        List<BasicBlock> order = topologicalOrder(cfg);
        for (BasicBlock block : order) {
            // 4.1 Meetæ“ä½œ
            Set<T> predOuts = new HashSet<>();
            for (BasicBlock pred : block.getPredecessors()) {
                predOuts.add(outSets.get(pred));
            }
            T newIn = meet(predOuts);

            // 4.2 åº”ç”¨ä¼ é€’å‡½æ•°
            T newOut = transfer(newIn, block);

            // 4.3 æ£€æŸ¥å˜åŒ–
            if (!newIn.equals(inSets.get(block)) ||
                !newOut.equals(outSets.get(block))) {
                changed = true;
            }

            inSets.put(block, newIn);
            outSets.put(block, newOut);
        }

    } while (changed && iterations < MAX_ITERATIONS);

    return new DataFlowResult<>(inSets, outSets);
}
```

**ä»£ç è§£æ**:

| è¡Œå· | åŠŸèƒ½ | å…³é”®ç‚¹ |
|------|------|--------|
| 8-13 | **åˆå§‹åŒ–** | æ‰€æœ‰å—è®¾ä¸ºåˆå§‹å€¼ï¼ˆé€šå¸¸æ˜¯âŠ¤ï¼‰ |
| 16-19 | **è¾¹ç•Œæ¡ä»¶** | å…¥å£å—è®¾ä¸ºç‰¹æ®Šå€¼ï¼ˆå¦‚ç©ºé›†ï¼‰ |
| 22 | **ä¸åŠ¨ç‚¹å¾ªç¯** | ç›´åˆ°ä¸å†å˜åŒ–æˆ–è¶…æ—¶ |
| 27-29 | **ä¿å­˜æ—§å€¼** | ç”¨äºä¸‹ä¸€è½®æ¯”è¾ƒ |
| 32 | **æ‹“æ‰‘åº** | åŠ é€Ÿæ”¶æ•›ï¼ˆé‡è¦ä¼˜åŒ–ï¼‰ |
| 35-39 | **Meetæ“ä½œ** | åˆå¹¶æ‰€æœ‰å‰é©±çš„OUT |
| 41 | **ä¼ é€’å‡½æ•°** | è®¡ç®—å½“å‰å—çš„OUT |
| 43-47 | **å˜åŒ–æ£€æµ‹** | ä»»ä¸€é›†åˆå˜åŒ–åˆ™ç»§ç»­ |

**æ­¥éª¤3: å®ç°åå‘è¿­ä»£ç®—æ³•**

```java
protected DataFlowResult<T> backwardIteration(CFG cfg) {
    // ç±»ä¼¼å‰å‘ï¼Œä½†æ–¹å‘ç›¸å
    // 1. åˆå§‹åŒ–
    // 2. è®¾ç½®å‡ºå£å—è¾¹ç•Œæ¡ä»¶
    // 3. åå‘æ‹“æ‰‘åºè¿­ä»£
    // 4. Meetåç»§çš„INï¼Œè®¡ç®—å½“å‰å—çš„IN

    // å…³é”®å·®å¼‚ï¼š
    // - å‰å‘: IN[B] = â‹‚ OUT[pred], OUT = f(IN)
    // - åå‘: OUT[B] = â‹‚ IN[succ], IN = f(OUT)
}
```

---

### 1.3 å®è·µç»ƒä¹ 

**ç»ƒä¹ 1: å®ç°åˆ°è¾¾å®šä¹‰åˆ†æ**

**ä»»åŠ¡**: å®ç°å‰å‘æ•°æ®æµåˆ†æ - åˆ°è¾¾å®šä¹‰åˆ†æ

**ç›®æ ‡**: å¯¹äºæ¯ä¸ªç¨‹åºç‚¹ï¼Œè®¡ç®—å“ªäº›å®šä¹‰å¯èƒ½åˆ°è¾¾è¯¥ç‚¹

**æç¤º**:
```java
public class ReachingDefinitionsAnalysis extends AbstractDataFlowAnalysis<Definition> {
    @Override
    public boolean isForward() {
        return true;  // å‰å‘åˆ†æ
    }

    @Override
    protected Set<Definition> initialize() {
        return new HashSet<>();  // âŠ¤ = ç©ºé›†
    }

    @Override
    protected Set<Definition> meet(Set<Set<Definition>> sets) {
        // å¹¶é›†
        Set<Definition> result = new HashSet<>();
        for (Set<Definition> set : sets) {
            result.addAll(set);
        }
        return result;
    }

    @Override
    protected Set<Definition> transfer(Set<Definition> in, BasicBlock block) {
        // OUT = (IN \ KILL) âˆª GEN
        Set<Definition> out = new HashSet<>(in);

        // KILL: åŒä¸€å˜é‡çš„å…¶ä»–å®šä¹‰
        Set<Definition> kill = computeKill(block, in);
        out.removeAll(kill);

        // GEN: å—å†…çš„å®šä¹‰
        Set<Definition> gen = computeGen(block);
        out.addAll(gen);

        return out;
    }
}
```

**æµ‹è¯•**:
```
ç¨‹åº:
d1: x = 1
d2: x = 2
d3: y = x

é¢„æœŸç»“æœ:
d1ä¹‹å: {d1}
d2ä¹‹å: {d2}        (d1è¢«d2 kill)
d3ä¹‹å: {d2, d3}    (d2åˆ°è¾¾yçš„ä½¿ç”¨)
```

---

### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ä¸‹ä¸€ä¸»é¢˜

**ä½ åˆšåˆšå®ç°äº†**:
```java
public abstract class AbstractDataFlowAnalysis<T> {
    public final DataFlowResult<T> analyze(CFG cfg) {
        // é€šç”¨çš„è¿­ä»£æ±‚è§£ç®—æ³•
        while (changed) {
            // å‰å‘æˆ–åå‘è¿­ä»£
            if (isForward()) forwardIteration();
            else backwardIteration();
        }
    }

    // å­ç±»éœ€è¦å®ç°è¿™äº›æ–¹æ³•
    public abstract boolean isForward();
    protected abstract T meet(Set<T> sets);
    protected abstract T transfer(T in, BasicBlock block);
}
```

**ä¸‹ä¸€æ­¥å­¦ä¹ ï¼ˆä¸»é¢˜äºŒï¼‰**: æ´»è·ƒå˜é‡åˆ†æ
- å°†**ç»§æ‰¿**AbstractDataFlowAnalysis
- å®ç°åå‘æ•°æ®æµåˆ†æ
- è®¡ç®—æ¯ä¸ªç¨‹åºç‚¹çš„æ´»è·ƒå˜é‡é›†åˆ

**è¿æ¥ä»£ç **:
```java
// åœ¨ä¸»é¢˜äºŒä¸­ï¼Œä½ ä¼šè¿™æ ·ç»§æ‰¿æœ¬ä¸»é¢˜çš„æ¡†æ¶
public class LiveVariableAnalysis extends AbstractDataFlowAnalysis<Set<Operand>> {

    @Override
    public boolean isForward() {
        return false;  // åå‘åˆ†æ
    }

    @Override
    protected Set<Operand> meet(Set<Set<Operand>> sets) {
        // å®ç°æ´»è·ƒå˜é‡çš„meetè¿ç®—
        Set<Operand> result = new HashSet<>();
        for (Set<Operand> set : sets) {
            result.addAll(set);  // å¹¶é›†
        }
        return result;
    }

    @Override
    protected Set<Operand> transfer(Set<Operand> in, BasicBlock block) {
        // å®ç°æ´»è·ƒå˜é‡çš„ä¼ é€’å‡½æ•°
        // IN = use âˆª (OUT \ def)
        Set<Operand> gen = computeGen(block);
        Set<Operand> kill = computeKill(block);
        Set<Operand> result = new HashSet<>(in);
        result.removeAll(kill);
        result.addAll(gen);
        return result;
    }
}

// ä½¿ç”¨æ—¶ï¼ˆæ¡†æ¶çš„analyze()æ–¹æ³•å·²å®ç°è¿­ä»£æ±‚è§£ï¼‰
LiveVariableAnalysis lva = new LiveVariableAnalysis(cfg);
lva.analyze();  // è°ƒç”¨çˆ¶ç±»çš„é€šç”¨ç®—æ³•
Set<Operand> liveOut = lva.getOUT(block);
```

---

## ğŸ“ ä¸»é¢˜äºŒï¼šæ´»è·ƒå˜é‡åˆ†æ

> **å­¦ä¹ æ—¶é—´**: 2å°æ—¶ | **éš¾åº¦**: â­â­â­ | **ç›®æ ‡**: ç†è§£åå‘æ•°æ®æµåˆ†æï¼Œå®ç°æ´»è·ƒå˜é‡åˆ†æ

### ğŸ“ æœ¬ä¸»é¢˜åœ¨EP21ä¸­çš„ä½ç½®

```
EP21å†…éƒ¨æ„é€ :
é˜¶æ®µ1: [æ•°æ®æµåˆ†ææ¡†æ¶] â† ä¸»é¢˜ä¸€ (å·²å®Œæˆ)
       â†“ ç»§æ‰¿
é˜¶æ®µ2: [æ´»è·ƒå˜é‡åˆ†æ] â† æœ¬ä¸»é¢˜ âœï¸
       â†“ è¢«ä½¿ç”¨
é˜¶æ®µ3: [æ­»ä»£ç æ¶ˆé™¤] â† ä¸»é¢˜ä¸‰ (å°†å­¦ä¹ )
```

### ğŸ”— ä¸»é¢˜é—´çš„ä¾èµ–å…³ç³»

**å‰ç½®ä¾èµ–**: ä¸»é¢˜ä¸€ï¼ˆæ•°æ®æµåˆ†ææ¡†æ¶ï¼‰
- æœ¬ä¸»é¢˜**ç»§æ‰¿**AbstractDataFlowAnalysis
- éœ€è¦å®ç°`isForward()`, `meet()`, `transfer()`, `initialize()`æ–¹æ³•
- æ¡†æ¶æä¾›ä»€ä¹ˆï¼Ÿâ†’ analyze()é€šç”¨ç®—æ³•ï¼Œè‡ªåŠ¨å¤„ç†è¿­ä»£æ±‚è§£

**åç»­åº”ç”¨**: ä¸»é¢˜ä¸‰ï¼ˆæ­»ä»£ç æ¶ˆé™¤ï¼‰
- æ­»ä»£ç æ¶ˆé™¤**ä½¿ç”¨**æœ¬ä¸»é¢˜çš„åˆ†æç»“æœ
- åˆ¤æ–­å˜é‡å®šä¹‰æ˜¯å¦æ˜¯æ­»å­˜å‚¨ï¼ˆä¸æ´»è·ƒçš„å®šä¹‰ï¼‰
- ä¾èµ–å…³ç³»: DeadCodeEliminationOptimizer â†’ LiveVariableAnalysis.analyze()

---

### 2.1 æ ¸å¿ƒæ¦‚å¿µ

#### ä»€ä¹ˆæ˜¯æ´»è·ƒå˜é‡ï¼Ÿ

**å®šä¹‰**: å˜é‡xåœ¨ç¨‹åºç‚¹pæ˜¯æ´»è·ƒçš„ï¼Œå¦‚æœï¼š
1. å­˜åœ¨ä¸€æ¡ä»påˆ°ç¨‹åºå‡ºå£çš„è·¯å¾„
2. xåœ¨pä¹‹åè¢«ä½¿ç”¨
3. åœ¨påˆ°è¯¥ä½¿ç”¨ç‚¹ä¹‹é—´ï¼Œxæœªè¢«é‡æ–°å®šä¹‰

**ç›´è§‚ç†è§£**: "è¿™ä¸ªå˜é‡çš„å€¼åœ¨æœªæ¥ä¼šè¢«ç”¨åˆ°å—ï¼Ÿ"

**ä¸ºä»€ä¹ˆé‡è¦ï¼Ÿ**
- **å¯„å­˜å™¨åˆ†é…**: æ´»è·ƒå˜é‡éœ€è¦é©»ç•™åœ¨å¯„å­˜å™¨
- **æ­»ä»£ç æ¶ˆé™¤**: ä¸æ´»è·ƒçš„èµ‹å€¼å¯ä»¥åˆ é™¤
- **ä»£ç ç§»åŠ¨**: å°†è®¡ç®—ç§»åŠ¨åˆ°å˜é‡æ´»è·ƒçš„åŒºåŸŸ

#### ç¤ºä¾‹åˆ†æ

**ä»£ç **:
```c
void example() {
    int a = 1;    // d1
    int b = 2;    // d2
    int c = a + b; // d3
    int d = 3;    // d4  â† æ­»å­˜å‚¨ï¼
    return c;
}
```

**æ´»è·ƒå˜é‡åˆ†æ**:
```
ç¨‹åºç‚¹            æ´»è·ƒå˜é‡
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
d1ä¹‹å‰:           {a, b, c}
d1ä¹‹å (a=1):     {b, c}
d2ä¹‹å (b=2):     {c}
d3ä¹‹å (c=a+b):   {c}
d4ä¹‹å (d=3):     {c}    â† dä¸æ´»è·ƒï¼
returnä¹‹å:       {}
```

**ç»“è®º**: `d = 3` æ˜¯æ­»å­˜å‚¨ï¼Œå¯ä»¥å®‰å…¨åˆ é™¤

#### æ•°æ®æµæ–¹ç¨‹

**åå‘åˆ†æ**:
```
OUT[B] = â‹‚_{Sâˆˆsucc(B)} IN[S]           # meetæ‰€æœ‰åç»§çš„IN
IN[B]  = use_B âˆª (OUT[B] \ def_B)      # ä¼ é€’å‡½æ•°
```

**é›†åˆå®šä¹‰**:
- `use_B`: å—Bä¸­**ä½¿ç”¨å‰æœªå®šä¹‰**çš„å˜é‡
- `def_B`: å—Bä¸­**å®šä¹‰**çš„å˜é‡

**è¾¹ç•Œæ¡ä»¶**:
```
OUT[exit] = âˆ…    # å‡ºå£å—æ²¡æœ‰æ´»è·ƒå˜é‡
```

---

### 2.2 å®ç°åŸç†

#### ç±»è®¾è®¡

```java
public class LiveVariableAnalysis extends AbstractDataFlowAnalysis<IRNode> {

    @Override
    public boolean isForward() {
        return false;  // åå‘åˆ†æï¼
    }

    @Override
    protected Set<IRNode> initialize() {
        return new HashSet<>();  // âŠ¤ = ç©ºé›†
    }

    @Override
    protected Set<IRNode> meet(Set<Set<IRNode>> sets) {
        // äº¤é›†ï¼ˆä¸æ˜¯å¹¶é›†ï¼ï¼‰
        Set<IRNode> result = null;
        for (Set<IRNode> set : sets) {
            if (result == null) {
                result = new HashSet<>(set);
            } else {
                result.retainAll(set);  // äº¤é›†
            }
        }
        return (result != null) ? result : new HashSet<>();
    }

    @Override
    protected Set<IRNode> transfer(Set<IRNode> in, BasicBlock block) {
        // IN = use âˆª (OUT \ def)
        Set<IRNode> gen = computeGen(block);  // useé›†åˆ
        Set<IRNode> kill = computeKill(block); // defé›†åˆ

        Set<IRNode> result = new HashSet<>(in);
        result.removeAll(kill);  // OUT \ def
        result.addAll(gen);      // âˆª use

        return result;
    }

    @Override
    protected Set<IRNode> boundaryCondition() {
        return new HashSet<>();  // OUT[exit] = âˆ…
    }

    // è®¡ç®—GEN (use) é›†åˆ
    private Set<IRNode> computeGen(BasicBlock block) {
        Set<IRNode> gen = new HashSet<>();
        Set<IRNode> defined = new HashSet<>();

        for (IRNode node : block.getIRNodes()) {
            if (node.getType() == IRNodeType.VariableWrite) {
                defined.add(node.getVariable());
            } else if (node.getType() == IRNodeType.VariableRead) {
                if (!defined.contains(node.getVariable())) {
                    gen.add(node);  // ä½¿ç”¨å‰æœªå®šä¹‰
                }
            }
        }
        return gen;
    }

    // è®¡ç®—KILL (def) é›†åˆ
    private Set<IRNode> computeKill(BasicBlock block) {
        Set<IRNode> kill = new HashSet<>();
        for (IRNode node : block.getIRNodes()) {
            if (node.getType() == IRNodeType.VariableWrite) {
                kill.add(node);
            }
        }
        return kill;
    }
}
```

#### å…³é”®ä»£ç è§£æ

**ä¼ é€’å‡½æ•°å®ç°**:
```java
@Override
protected Set<IRNode> transfer(Set<IRNode> in, BasicBlock block) {
    // 1. ä»INå¼€å§‹
    Set<IRNode> result = new HashSet<>(in);

    // 2. åå‘éå†æŒ‡ä»¤ï¼ˆé‡è¦ï¼ï¼‰
    List<IRNode> nodes = block.getIRNodes();
    for (int i = nodes.size() - 1; i >= 0; i--) {
        IRNode node = nodes.get(i);

        if (node.getType() == IRNodeType.VariableWrite) {
            // å®šä¹‰ï¼šä»æ´»è·ƒé›†åˆç§»é™¤
            result.remove(node.getVariable());
        } else if (node.getType() == IRNodeType.VariableRead) {
            // ä½¿ç”¨ï¼šæ·»åŠ åˆ°æ´»è·ƒé›†åˆ
            result.add(node.getVariable());
        }
    }

    return result;
}
```

**ä¸ºä»€ä¹ˆåå‘éå†ï¼Ÿ**
```
åŸºæœ¬å—:
    a = 1    # def(a)
    b = a    # use(a), def(b)
    return b

æ­£å‘éå†ï¼ˆé”™è¯¯ï¼‰:
    IN = {}
    å¤„ç† a=1:  def(a) â†’ IN = {}
    å¤„ç† b=a:  use(a) â†’ IN = {a}
    OUT = {a}  â† é”™è¯¯ï¼bä¸æ´»è·ƒ

åå‘éå†ï¼ˆæ­£ç¡®ï¼‰:
    IN = {}
    å¤„ç† return b:  use(b) â†’ IN = {b}
    å¤„ç† b=a:      def(b) â†’ IN = {a}, use(a) â†’ IN = {a}
    å¤„ç† a=1:      def(a) â†’ IN = {}
    OUT = {}  â† æ­£ç¡®ï¼
```

---

### 2.3 å®è·µç»ƒä¹ 

**ç»ƒä¹ 2: åº”ç”¨æ´»è·ƒå˜é‡åˆ†æä¼˜åŒ–ä»£ç **

**ä»»åŠ¡**: ä½¿ç”¨æ´»è·ƒå˜é‡åˆ†æç»“æœï¼Œæ¶ˆé™¤æ­»å­˜å‚¨

**è¾“å…¥**:
```c
int example(int x) {
    int a = x * 2;  // d1
    int b = a + 1;  // d2
    int c = 5;      // d3  â† æ­»å­˜å‚¨ï¼Ÿ
    return b;
}
```

**æ­¥éª¤**:
1. è¿è¡Œæ´»è·ƒå˜é‡åˆ†æ
2. è¯†åˆ«ä¸æ´»è·ƒçš„å˜é‡å®šä¹‰
3. åˆ é™¤æ­»å­˜å‚¨

**é¢„æœŸè¾“å‡º**:
```c
int example(int x) {
    int a = x * 2;
    int b = a + 1;
    return b;  // cçš„å®šä¹‰è¢«åˆ é™¤
}
```

**ä»£ç æ¡†æ¶**:
```java
public class DeadStoreElimination {
    public BasicBlock eliminateDeadStores(BasicBlock block,
                                         LiveVariableAnalysis lva) {
        // 1. è·å–æ´»è·ƒå˜é‡ä¿¡æ¯
        Set<IRNode> liveOut = lva.getOUT(block);

        // 2. åå‘éå†æŒ‡ä»¤
        List<IRNode> toRemove = new ArrayList<>();
        for (IRNode node : reverse(block.getNodes())) {
            if (node.isDefinition()) {
                Variable var = node.getDefinedVariable();
                if (!liveOut.contains(var)) {
                    toRemove.add(node);  // æ­»å­˜å‚¨
                }
                // æ›´æ–°æ´»è·ƒé›†åˆ
                liveOut = lva.transfer(liveOut, node);
            }
        }

        // 3. åˆ é™¤æ­»å­˜å‚¨
        block.removeAll(toRemove);
        return block;
    }
}
```

---

### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ä¸‹ä¸€ä¸»é¢˜

**ä½ åˆšåˆšå®ç°äº†**:
```java
public class LiveVariableAnalysis extends AbstractDataFlowAnalysis<Set<Operand>> {
    // åå‘åˆ†æ
    public boolean isForward() { return false; }

    // å¹¶é›†meet
    protected Set<Operand> meet(Set<Set<Operand>> sets) { ... }

    // ä¼ é€’å‡½æ•°: IN = use âˆª (OUT \ def)
    protected Set<Operand> transfer(Set<Operand> in, BasicBlock block) { ... }

    // è®¡ç®—GEN/KILLé›†åˆ
    private Set<Operand> computeGen(BasicBlock block) { ... }
    private Set<Operand> computeKill(BasicBlock block) { ... }
}
```

**åˆ†æç»“æœ**: æ¯ä¸ªç¨‹åºç‚¹çš„æ´»è·ƒå˜é‡é›†åˆ
```java
LiveVariableAnalysis lva = new LiveVariableAnalysis(cfg);
lva.analyze();
Set<Operand> liveOut = lva.getOUT(block);  // è·å–æ´»è·ƒå˜é‡
```

**ä¸‹ä¸€æ­¥å­¦ä¹ ï¼ˆä¸»é¢˜ä¸‰ï¼‰**: æ­»ä»£ç æ¶ˆé™¤
- å°†**ä½¿ç”¨**æœ¬ä¸»é¢˜çš„åˆ†æç»“æœ
- åˆ é™¤ä¸æ´»è·ƒçš„å˜é‡å®šä¹‰ï¼ˆæ­»å­˜å‚¨ï¼‰
- åˆ é™¤ä¸å¯è¾¾çš„åŸºæœ¬å—

**è¿æ¥ä»£ç **:
```java
// åœ¨ä¸»é¢˜ä¸‰ä¸­ï¼Œä½ ä¼šè¿™æ ·ä½¿ç”¨æ´»è·ƒå˜é‡åˆ†æ
public class DeadCodeEliminationOptimizer implements IFlowOptimizer<IRNode> {

    @Override
    public void onHandle(CFG<IRNode> cfg) {
        // ç¬¬ä¸€é˜¶æ®µï¼šä¸å¯è¾¾ä»£ç æ¶ˆé™¤ï¼ˆç‹¬ç«‹ï¼‰
        eliminateUnreachableCode(cfg);

        // ç¬¬äºŒé˜¶æ®µï¼šæ­»å­˜å‚¨æ¶ˆé™¤ï¼ˆä½¿ç”¨ä¸»é¢˜äºŒçš„åˆ†æï¼‰
        eliminateDeadStores(cfg);
    }

    private void eliminateDeadStores(CFG<IRNode> cfg) {
        // è¿è¡Œæ´»è·ƒå˜é‡åˆ†æï¼ˆä½ åœ¨ä¸»é¢˜äºŒå®ç°çš„ï¼‰
        LiveVariableAnalysis lva = new LiveVariableAnalysis(cfg);
        lva.analyze();  // è°ƒç”¨æ¡†æ¶çš„analyze()æ–¹æ³•

        // ä½¿ç”¨åˆ†æç»“æœåˆ é™¤æ­»å­˜å‚¨
        for (BasicBlock<IRNode> block : cfg) {
            Set<Operand> liveOut = lva.getOUT(block);

            // åå‘éå†æŒ‡ä»¤
            for (IRNode instr : reverse(block.getIRNodes())) {
                if (instr instanceof Assign assign) {
                    VarSlot lhs = assign.getLhs();

                    // æ£€æŸ¥å˜é‡æ˜¯å¦æ´»è·ƒ
                    if (!liveOut.contains(lhs)) {
                        // ä¸æ´»è·ƒï¼Œåˆ é™¤è¿™æ¡æŒ‡ä»¤
                        block.remove(instr);
                        System.out.println("Removed dead store: " + instr);
                    }
                }
            }
        }
    }
}
```

---

## ğŸ“ ä¸»é¢˜ä¸‰ï¼šæ­»ä»£ç æ¶ˆé™¤

> **å­¦ä¹ æ—¶é—´**: 2å°æ—¶ | **éš¾åº¦**: â­â­â­ | **ç›®æ ‡**: å®ç°ä¸å¯è¾¾ä»£ç å’Œæ­»å­˜å‚¨çš„æ¶ˆé™¤

### ğŸ“ æœ¬ä¸»é¢˜åœ¨EP21ä¸­çš„ä½ç½®

```
EP21å†…éƒ¨æ„é€ :
é˜¶æ®µ2: [æ´»è·ƒå˜é‡åˆ†æ] â† ä¸»é¢˜äºŒ (å·²å®Œæˆ)
       â†“ è¢«ä½¿ç”¨
é˜¶æ®µ3: [æ­»ä»£ç æ¶ˆé™¤] â† æœ¬ä¸»é¢˜ âœï¸
       â†“ æ³¨å†Œåˆ°
é˜¶æ®µ4: [ä¼˜åŒ–å™¨é“¾] â† ä¸»é¢˜äº”
```

### ğŸ”— ä¸»é¢˜é—´çš„ä¾èµ–å…³ç³»

**å‰ç½®ä¾èµ–**:
- ä¸»é¢˜ä¸€ï¼ˆæ•°æ®æµåˆ†ææ¡†æ¶ï¼‰: ä½¿ç”¨CFGã€BasicBlockç­‰æ•°æ®ç»“æ„
- ä¸»é¢˜äºŒï¼ˆæ´»è·ƒå˜é‡åˆ†æï¼‰: **ç”¨äºæ­»å­˜å‚¨æ¶ˆé™¤**

**åç»­åº”ç”¨**: ä¸»é¢˜äº”ï¼ˆä¼˜åŒ–å™¨é“¾è®¾è®¡ï¼‰
- æœ¬ä¸»é¢˜å®ç°çš„`DeadCodeEliminationOptimizer`å°†æ³¨å†Œåˆ°ä¼˜åŒ–å™¨é“¾
- åœ¨ä¼˜åŒ–å™¨é“¾ä¸­ä½œä¸ºç¬¬2æˆ–ç¬¬4ä¸ªPassæ‰§è¡Œ

---

### 3.1 æ ¸å¿ƒæ¦‚å¿µ

#### ä»€ä¹ˆæ˜¯æ­»ä»£ç ï¼Ÿ

**ç±»å‹1: ä¸å¯è¾¾ä»£ç ï¼ˆUnreachable Codeï¼‰**

å®šä¹‰: æ²¡æœ‰ä»»ä½•æ‰§è¡Œè·¯å¾„èƒ½åˆ°è¾¾çš„ä»£ç 

**ç¤ºä¾‹**:
```c
if (false) {
    x = 1;  // ä¸å¯è¾¾ï¼
    y = 2;  // ä¸å¯è¾¾ï¼
}
return;
z = 3;     // ä¸å¯è¾¾ï¼
```

**æ£€æµ‹æ–¹æ³•**: DFSå¯è¾¾æ€§åˆ†æï¼ˆç‹¬ç«‹å®ç°ï¼Œä¸ä¾èµ–å…¶ä»–åˆ†æï¼‰

**ç±»å‹2: æ­»å­˜å‚¨ï¼ˆDead Storeï¼‰**

å®šä¹‰: å®šä¹‰çš„å˜é‡ä»æœªè¢«ä½¿ç”¨çš„èµ‹å€¼è¯­å¥

**ç¤ºä¾‹**:
```c
x = 1;  // æ­»å­˜å‚¨
x = 2;  // è¦†ç›–äº†å‰é¢çš„å®šä¹‰
y = x;  // åªä½¿ç”¨äº†ç¬¬äºŒä¸ªå®šä¹‰
```

**æ£€æµ‹æ–¹æ³•**: åŸºäºæ´»è·ƒå˜é‡åˆ†æï¼ˆ**ä¾èµ–ä¸»é¢˜äºŒ**ï¼‰

#### ä¼˜åŒ–æ•ˆæœ

**ä»£ç å¤§å°å‡å°‘**:
```
ä¼˜åŒ–å‰: 1000 è¡Œ
ä¼˜åŒ–å: 700 è¡Œ
å‡å°‘: 30%
```

**æ‰§è¡Œæ—¶é—´å‡å°‘**:
```
ä¼˜åŒ–å‰: 100 ms
ä¼˜åŒ–å: 70 ms
å‡å°‘: 30%
```

**å¯„å­˜å™¨å‹åŠ›é™ä½**:
- åˆ é™¤æ­»å®šä¹‰é‡Šæ”¾å¯„å­˜å™¨
- ä¾¿äºåç»­å¯„å­˜å™¨åˆ†é…

---

### 3.2 å®ç°åŸç†

#### ä¸å¯è¾¾ä»£ç æ¶ˆé™¤

**ç®—æ³•: DFSå¯è¾¾æ€§åˆ†æ**

```java
public class DeadCodeEliminationOptimizer implements IFlowOptimizer {

    // æŸ¥æ‰¾æ‰€æœ‰å¯è¾¾å—
    private Set<BasicBlock> findReachableBlocks(CFG cfg) {
        Set<BasicBlock> reachable = new HashSet<>();
        Queue<BasicBlock> queue = new LinkedList<>();

        // 1. ä»å…¥å£å—å¼€å§‹BFS
        BasicBlock entry = findEntryBlock(cfg);
        if (entry != null) {
            queue.add(entry);
            reachable.add(entry);
        }

        // 2. å¹¿åº¦ä¼˜å…ˆæœç´¢
        while (!queue.isEmpty()) {
            BasicBlock current = queue.poll();

            // 3. éå†æ‰€æœ‰åç»§
            for (BasicBlock successor : current.getSuccessors()) {
                if (!reachable.contains(successor)) {
                    reachable.add(successor);
                    queue.add(successor);
                }
            }
        }

        return reachable;
    }

    // æ¶ˆé™¤ä¸å¯è¾¾ä»£ç 
    public CFG eliminateUnreachableCode(CFG cfg) {
        // 1. æŸ¥æ‰¾å¯è¾¾å—
        Set<BasicBlock> reachable = findReachableBlocks(cfg);

        // 2. æ”¶é›†ä¸å¯è¾¾å—
        List<BasicBlock> toRemove = new ArrayList<>();
        for (BasicBlock block : cfg.getBlocks()) {
            if (!reachable.contains(block)) {
                toRemove.add(block);
            }
        }

        // 3. åˆ é™¤ä¸å¯è¾¾å—
        for (BasicBlock block : toRemove) {
            cfg.removeBlock(block);
            System.out.println("Removed unreachable block: " + block.getId());
        }

        // 4. æ¸…ç†è¾¹
        cfg.cleanupEdges();

        return cfg;
    }
}
```

**ç®—æ³•å¤æ‚åº¦**:
- æ—¶é—´: O(V + E)ï¼ŒVæ˜¯åŸºæœ¬å—æ•°ï¼ŒEæ˜¯è¾¹æ•°
- ç©ºé—´: O(V)

#### æ­»å­˜å‚¨æ¶ˆé™¤

**ç®—æ³•: åŸºäºæ´»è·ƒå˜é‡çš„æ­»å­˜å‚¨æ£€æµ‹**

```java
public CFG eliminateDeadStores(CFG cfg) {
    // è¿è¡Œæ´»è·ƒå˜é‡åˆ†æï¼ˆä½¿ç”¨ä¸»é¢˜äºŒçš„å®ç°ï¼‰
    LiveVariableAnalysis lva = new LiveVariableAnalysis(cfg);
    lva.analyze();

    // å¯¹æ¯ä¸ªåŸºæœ¬å—
    for (BasicBlock block : cfg.getBlocks()) {
        Set<IRNode> liveOut = lva.getOUT(block);
        List<IRNode> toRemove = new ArrayList<>();

        // åå‘éå†æŒ‡ä»¤
        List<IRNode> instructions = block.getIRNodes();
        for (int i = instructions.size() - 1; i >= 0; i--) {
            IRNode instr = instructions.get(i);

            if (instr.getType() == IRNodeType.VariableWrite) {
                Variable var = instr.getDefinedVariable();

                // æ£€æŸ¥å˜é‡æ˜¯å¦æ´»è·ƒ
                if (!isVariableLive(var, liveOut)) {
                    toRemove.add(instr);
                    System.out.println("Dead store: " + instr);
                }
            }

            // æ›´æ–°æ´»è·ƒé›†åˆ
            liveOut = lva.transferSingleNode(liveOut, instr);
        }

        // åˆ é™¤æ­»å­˜å‚¨
        block.removeNodes(toRemove);
    }

    return cfg;
}

private boolean isVariableLive(Variable var, Set<IRNode> liveSet) {
    for (IRNode node : liveSet) {
        if (node.getVariable().equals(var)) {
            return true;
        }
    }
    return false;
}
```

**å…³é”®ç‚¹**:
- ç¬¬3è¡Œ: åˆ›å»º`LiveVariableAnalysis`å®ä¾‹ï¼ˆä¸»é¢˜äºŒå®ç°ï¼‰
- ç¬¬4è¡Œ: è°ƒç”¨`analyze()`æ‰§è¡Œåˆ†æï¼ˆç»§æ‰¿è‡ªä¸»é¢˜ä¸€çš„æ¡†æ¶ï¼‰
- ç¬¬8è¡Œ: è·å–`OUT`é›†åˆï¼ˆæ´»è·ƒå˜é‡ä¿¡æ¯ï¼‰
- ç¬¬22è¡Œ: ä½¿ç”¨æ´»è·ƒå˜é‡ä¿¡æ¯åˆ¤æ–­æ˜¯å¦æ­»å­˜å‚¨

---

### 3.3 å®è·µç»ƒä¹ 

**ç»ƒä¹ 3: å¤„ç†æ¡ä»¶è·³è½¬ä¼˜åŒ–**

**ä»»åŠ¡**: ä¼˜åŒ–å¸¸é‡æ¡ä»¶è·³è½¬

**è¾“å…¥**:
```c
if (true) {
    x = 1;
} else {
    y = 2;  // ä¸å¯è¾¾
}
```

**æ­¥éª¤**:
1. æ£€æµ‹æ¡ä»¶æ˜¯å¦ä¸ºå¸¸é‡
2. åˆ é™¤ä¸å¯è¾¾åˆ†æ”¯
3. å°†æ¡ä»¶è·³è½¬æ”¹ä¸ºæ— æ¡ä»¶è·³è½¬

**æç¤º**:
```java
public void optimizeConstantBranch(BasicBlock block) {
    IRNode last = block.getLastInstruction();

    if (last.getType() == IRNodeType.ConditionalBranch) {
        IRNode condition = last.getCondition();

        if (condition.isConstant()) {
            boolean value = condition.getConstantValue();

            if (value) {
                // æ€»æ˜¯è·³è½¬ï¼Œæ”¹ä¸ºæ— æ¡ä»¶è·³è½¬
                block.replaceLast(new UnconditionalBranch(last.getTrueTarget()));
            } else {
                // ä»ä¸è·³è½¬ï¼Œåˆ é™¤æŒ‡ä»¤
                block.removeLast();
            }
        }
    }
}
```

---

### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ä¸‹ä¸€ä¸»é¢˜

**ä½ åˆšåˆšå®ç°äº†**:
```java
public class DeadCodeEliminationOptimizer implements IFlowOptimizer<IRNode> {

    @Override
    public void onHandle(CFG<IRNode> cfg) {
        // ä¸å¯è¾¾ä»£ç æ¶ˆé™¤ï¼ˆç‹¬ç«‹å®ç°ï¼‰
        eliminateUnreachableCode(cfg);

        // æ­»å­˜å‚¨æ¶ˆé™¤ï¼ˆä½¿ç”¨ä¸»é¢˜äºŒçš„LiveVariableAnalysisï¼‰
        eliminateDeadStores(cfg);
    }

    private void eliminateDeadStores(CFG<IRNode> cfg) {
        // ä½¿ç”¨æ´»è·ƒå˜é‡åˆ†æ
        LiveVariableAnalysis lva = new LiveVariableAnalysis(cfg);
        lva.analyze();  // è°ƒç”¨æ¡†æ¶æ–¹æ³•

        // ä½¿ç”¨åˆ†æç»“æœ
        Set<Operand> liveOut = lva.getOUT(block);
        // åˆ é™¤ä¸æ´»è·ƒçš„èµ‹å€¼...
    }
}
```

**ä¸‹ä¸€æ­¥å­¦ä¹ ï¼ˆä¸»é¢˜å››ï¼‰**: å¸¸é‡æŠ˜å 
- ç‹¬ç«‹ä¼˜åŒ–ï¼Œä¸ä¾èµ–å…¶ä»–åˆ†æ
- å¯ä»¥ä¸ä¸»é¢˜ä¸‰å¹¶è¡Œå­¦ä¹ 
- åŒæ ·å®ç°`IFlowOptimizer`æ¥å£

**ä¸‹ä¸€æ­¥å­¦ä¹ ï¼ˆä¸»é¢˜äº”ï¼‰**: ä¼˜åŒ–å™¨é“¾è®¾è®¡
- å°†æœ¬ä¸»é¢˜å’Œä¸»é¢˜å››çš„ä¼˜åŒ–å™¨æ³¨å†Œåˆ°ä¼˜åŒ–å™¨é“¾
- æŒ‰åºæ‰§è¡Œå¤šä¸ªä¼˜åŒ–Pass

---

## ğŸ“ ä¸»é¢˜å››ï¼šå¸¸é‡æŠ˜å 

> **å­¦ä¹ æ—¶é—´**: 2å°æ—¶ | **éš¾åº¦**: â­â­ | **ç›®æ ‡**: å®ç°ç¼–è¯‘æ—¶å¸¸é‡è¡¨è¾¾å¼æ±‚å€¼

### ğŸ“ æœ¬ä¸»é¢˜åœ¨EP21ä¸­çš„ä½ç½®

```
EP21å†…éƒ¨æ„é€ :
é˜¶æ®µ1: [æ•°æ®æµåˆ†ææ¡†æ¶] â† ä¸»é¢˜ä¸€
       â†“
é˜¶æ®µ2: [æ´»è·ƒå˜é‡åˆ†æ] â† ä¸»é¢˜äºŒ
       â†“
é˜¶æ®µ3: [æ­»ä»£ç æ¶ˆé™¤] â† ä¸»é¢˜ä¸‰
       â†“ å¹¶è¡Œå…³ç³»
é˜¶æ®µ3: [å¸¸é‡æŠ˜å ] â† æœ¬ä¸»é¢˜ âœï¸ (ç‹¬ç«‹)
       â†“ æ³¨å†Œåˆ°
é˜¶æ®µ4: [ä¼˜åŒ–å™¨é“¾] â† ä¸»é¢˜äº”
```

### ğŸ”— ä¸»é¢˜é—´çš„ä¾èµ–å…³ç³»

**ç‹¬ç«‹æ€§**: æœ¬ä¸»é¢˜æ˜¯ç‹¬ç«‹ä¼˜åŒ–å™¨
- ä¸ä¾èµ–ä¸»é¢˜ä¸€çš„æ•°æ®æµåˆ†ææ¡†æ¶
- ä¸ä¾èµ–ä¸»é¢˜äºŒçš„æ´»è·ƒå˜é‡åˆ†æ
- ä¸ä¾èµ–ä¸»é¢˜ä¸‰çš„æ­»ä»£ç æ¶ˆé™¤

**åç»­åº”ç”¨**: ä¸»é¢˜äº”ï¼ˆä¼˜åŒ–å™¨é“¾è®¾è®¡ï¼‰
- æœ¬ä¸»é¢˜å®ç°çš„`ConstantFoldingOptimizer`å°†æ³¨å†Œåˆ°ä¼˜åŒ–å™¨é“¾
- é€šå¸¸ä½œä¸ºä¼˜åŒ–å™¨é“¾çš„ç¬¬1ä¸ªPassï¼ˆäº§ç”Ÿæ–°å¸¸é‡ï¼Œè§¦å‘åç»­ä¼˜åŒ–ï¼‰

---

### 4.1 æ ¸å¿ƒæ¦‚å¿µ

#### ä»€ä¹ˆæ˜¯å¸¸é‡æŠ˜å ï¼Ÿ

**å®šä¹‰**: åœ¨ç¼–è¯‘æ—¶è®¡ç®—å¸¸é‡è¡¨è¾¾å¼çš„å€¼ï¼Œå¹¶ç”¨ç»“æœæ›¿æ¢åŸè¡¨è¾¾å¼

**è¦æ±‚**: æ‰€æœ‰æ“ä½œæ•°éƒ½æ˜¯ç¼–è¯‘æ—¶å¸¸é‡

**ç¤ºä¾‹**:
```
æºä»£ç            ç¼–è¯‘å
x = 3 + 5   â†’    x = 8
y = 2 * 4   â†’    y = 8
z = x > 10  â†’    z = false
```

#### æ”¯æŒçš„è¿ç®—

**ç®—æœ¯è¿ç®—**: `+`, `-`, `*`, `/`, `%`
**æ¯”è¾ƒè¿ç®—**: `==`, `!=`, `<`, `>`, `<=`, `>=`
**é€»è¾‘è¿ç®—**: `&&`, `||`, `!`
**ä½è¿ç®—**: `&`, `|`, `^`, `~`

#### ä¼˜åŒ–æ•ˆæœ

**å°†è¿è¡Œæ—¶è®¡ç®—è½¬ç§»åˆ°ç¼–è¯‘æ—¶**
```
è¿è¡Œæ—¶: 1000æ¬¡åŠ æ³• â†’ 10ms
ç¼–è¯‘æ—¶: 1æ¬¡åŠ æ³• â†’ 0ms
```

**è§¦å‘åç»­ä¼˜åŒ–**
```
if (3 + 5 > 10) â†’ if (8 > 10) â†’ if (false) â†’ åˆ é™¤åˆ†æ”¯
```

---

### 4.2 å®ç°åŸç†

#### å¸¸é‡æŠ˜å ç®—æ³•

```java
public class ConstantFoldingOptimizer implements IFlowOptimizer {

    @Override
    public CFG onHandle(CFG cfg) {
        for (BasicBlock block : cfg.getBlocks()) {
            optimizeBlock(block);
        }
        return cfg;
    }

    private void optimizeBlock(BasicBlock block) {
        List<IRNode> nodes = block.getIRNodes();

        for (int i = 0; i < nodes.size(); i++) {
            IRNode node = nodes.get(i);

            if (node.getType() == IRNodeType.BinaryOp) {
                IRNode folded = tryFoldBinaryExpression(node);
                if (folded != node) {
                    nodes.set(i, folded);  // æ›¿æ¢
                }
            } else if (node.getType() == IRNodeType.UnaryOp) {
                IRNode folded = tryFoldUnaryExpression(node);
                if (folded != node) {
                    nodes.set(i, folded);
                }
            }
        }
    }

    // å°è¯•æŠ˜å äºŒå…ƒè¡¨è¾¾å¼
    private IRNode tryFoldBinaryExpression(BinaryOpNode node) {
        // 1. é€’å½’æŠ˜å å­è¡¨è¾¾å¼
        IRNode left = tryFold(node.getLeft());
        IRNode right = tryFold(node.getRight());

        // 2. æ£€æŸ¥æ˜¯å¦éƒ½æ˜¯å¸¸é‡
        if (!left.isConstant() || !right.isConstant()) {
            return new BinaryOpNode(left, right, node.getOperator());
        }

        // 3. æå–å¸¸é‡å€¼
        Object leftVal = left.getConstantValue();
        Object rightVal = right.getConstantValue();

        // 4. æ ¹æ®æ“ä½œç¬¦è®¡ç®—
        try {
            Object result = evalBinaryOp(node.getOperator(), leftVal, rightVal);
            return new ConstantNode(result);  // åˆ›å»ºå¸¸é‡èŠ‚ç‚¹
        } catch (ArithmeticException e) {
            // é™¤é›¶ç­‰é”™è¯¯ï¼Œä¿æŒåŸæ ·
            return node;
        }
    }

    // äºŒå…ƒè¿ç®—æ±‚å€¼
    private Object evalBinaryOp(BinaryOperator op, Object left, Object right) {
        switch (op) {
            case ADD:
                return evalAdd(left, right);
            case SUBTRACT:
                return evalSub(left, right);
            case MULTIPLY:
                return evalMul(left, right);
            case DIVIDE:
                return evalDiv(left, right);
            case EQUAL:
                return evalEqual(left, right);
            case LESS_THAN:
                return evalLessThan(left, right);
            // ... å…¶ä»–æ“ä½œç¬¦
            default:
                throw new UnsupportedOperationException("Unknown operator: " + op);
        }
    }

    // åŠ æ³•æ±‚å€¼ï¼ˆæ”¯æŒå¤šç§ç±»å‹ï¼‰
    private Object evalAdd(Object left, Object right) {
        if (left instanceof Integer && right instanceof Integer) {
            return (Integer) left + (Integer) right;
        } else if (left instanceof Double && right instanceof Double) {
            return (Double) left + (Double) right;
        } else if (left instanceof String || right instanceof String) {
            return left.toString() + right.toString();
        }
        throw new RuntimeException("Type mismatch in addition");
    }

    // é™¤æ³•æ±‚å€¼ï¼ˆæ£€æŸ¥é™¤é›¶ï¼‰
    private Object evalDiv(Object left, Object right) {
        if (left instanceof Integer && right instanceof Integer) {
            int r = (Integer) right;
            if (r == 0) {
                throw new ArithmeticException("Division by zero");
            }
            return (Integer) left / r;
        } else if (left instanceof Double && right instanceof Double) {
            double r = (Double) right;
            if (r == 0.0) {
                throw new ArithmeticException("Division by zero");
            }
            return (Double) left / r;
        }
        throw new RuntimeException("Type mismatch in division");
    }
}
```

**ç‹¬ç«‹æ€§è¯´æ˜**:
- æ²¡æœ‰ç»§æ‰¿`AbstractDataFlowAnalysis`
- æ²¡æœ‰ä½¿ç”¨`LiveVariableAnalysis`
- å®Œå…¨ç‹¬ç«‹å®ç°ï¼Œåªä¾èµ–`IFlowOptimizer`æ¥å£å’Œ`IRNode`ç±»å‹

#### ä¼˜åŒ–ç¤ºä¾‹

**è¾“å…¥ç¨‹åº**:
```c
x = (3 + 5) * (2 - 1)
y = x > 10
```

**ä¼˜åŒ–è¿‡ç¨‹**:
```
æ­¥éª¤1: æŠ˜å  3 + 5 â†’ 8
x = 8 * (2 - 1)
y = x > 10

æ­¥éª¤2: æŠ˜å  2 - 1 â†’ 1
x = 8 * 1
y = x > 10

æ­¥éª¤3: æŠ˜å  8 * 1 â†’ 8
x = 8
y = x > 10

æ­¥éª¤4: ä¼ æ’­å¸¸é‡ x â†’ 8
x = 8
y = 8 > 10

æ­¥éª¤5: æŠ˜å  8 > 10 â†’ false
x = 8
y = false
```

**æœ€ç»ˆç»“æœ**:
```c
x = 8
y = false
```

---

### 4.3 å®è·µç»ƒä¹ 

**ç»ƒä¹ 4: æ‰©å±•å¸¸é‡æŠ˜å æ”¯æŒæ›´å¤šç±»å‹**

**ä»»åŠ¡**: æ·»åŠ å¸ƒå°”è¿ç®—å’Œä½è¿ç®—çš„å¸¸é‡æŠ˜å 

**æ–°å¢è¿ç®—**:
- é€»è¾‘: `&&`, `||`, `!`
- ä½è¿ç®—: `&`, `|`, `^`, `<<`, `>>`

**ä»£ç æ¡†æ¶**:
```java
private Object evalLogicalAnd(Object left, Object right) {
    // TODO: å®ç°é€»è¾‘ä¸
    // çŸ­è·¯æ±‚å€¼: if (!left) return false
}

private Object evalBitwiseAnd(Object left, Object right) {
    // TODO: å®ç°æŒ‰ä½ä¸
    // ä»…æ”¯æŒæ•´æ•°ç±»å‹
}
```

---

### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ä¸‹ä¸€ä¸»é¢˜

**ä½ åˆšåˆšå®ç°äº†**:
```java
public class ConstantFoldingOptimizer implements IFlowOptimizer<IRNode> {
    // ç‹¬ç«‹ä¼˜åŒ–ï¼Œä¸ä¾èµ–å…¶ä»–åˆ†æ
    public CFG onHandle(CFG cfg) {
        // æ”¶é›†å¸¸é‡
        // æŠ˜å è¡¨è¾¾å¼
    }

    private IRNode tryFoldBinaryExpression(BinaryOpNode node) {
        // é€’å½’å°è¯•æŠ˜å 
        // å¦‚æœä¸¤ä¸ªæ“ä½œæ•°éƒ½æ˜¯å¸¸é‡ï¼Œè®¡ç®—ç»“æœ
    }
}
```

**ä¸å…¶ä»–ä¼˜åŒ–å™¨çš„å…³ç³»**:
```
å¹¶è¡Œå…³ç³»:
â”œâ”€â”€ ä¸»é¢˜ä¸‰: DeadCodeEliminationOptimizer
â””â”€â”€ ä¸»é¢˜å››: ConstantFoldingOptimizer (æœ¬ä¸»é¢˜)
   ä¸¤è€…ç‹¬ç«‹ï¼Œå¯ä»¥å¹¶è¡Œå¼€å‘å’Œæ‰§è¡Œ
```

**ä¸‹ä¸€æ­¥å­¦ä¹ ï¼ˆä¸»é¢˜äº”ï¼‰**: ä¼˜åŒ–å™¨é“¾è®¾è®¡
- å°†æœ¬ä¸»é¢˜å’Œä¸»é¢˜ä¸‰çš„ä¼˜åŒ–å™¨æ³¨å†Œåˆ°ä¼˜åŒ–å™¨é“¾
- æŒ‰åºæ‰§è¡Œï¼šå¸¸é‡æŠ˜å  â†’ æ­»ä»£ç æ¶ˆé™¤
- ä¸ºä»€ä¹ˆæ˜¯è¿™ä¸ªé¡ºåºï¼Ÿâ†’ å¸¸é‡æŠ˜å å¯èƒ½äº§ç”Ÿæ–°çš„æ­»ä»£ç 

---

## ğŸ“ ä¸»é¢˜äº”ï¼šä¼˜åŒ–å™¨é“¾è®¾è®¡

> **å­¦ä¹ æ—¶é—´**: 2å°æ—¶ | **éš¾åº¦**: â­â­ | **ç›®æ ‡**: ç†è§£ä¼˜åŒ–å™¨çš„ç»„åˆå’Œæ‰§è¡Œé¡ºåº

### ğŸ“ æœ¬ä¸»é¢˜åœ¨EP21ä¸­çš„ä½ç½®

```
EP21å†…éƒ¨æ„é€ :
é˜¶æ®µ1-3: [åˆ†æ + ä¼˜åŒ–å™¨] â† ä¸»é¢˜ä¸€-å›› (å·²å®Œæˆ)
       â†“ æ³¨å†Œåˆ°
é˜¶æ®µ4: [ä¼˜åŒ–å™¨é“¾] â† æœ¬ä¸»é¢˜ âœï¸
       â†“
æœ€ç»ˆäº§å‡º: å®Œæ•´çš„ä¼˜åŒ–ç³»ç»Ÿ
```

### ğŸ”— ä¸»é¢˜é—´çš„ä¾èµ–å…³ç³»

**å‰ç½®ä¾èµ–**: ä¸»é¢˜ä¸€è‡³å››
- ä¸»é¢˜ä¸€: æä¾›æ•°æ®æµåˆ†ææ¡†æ¶
- ä¸»é¢˜äºŒ: æä¾›æ´»è·ƒå˜é‡åˆ†æ
- ä¸»é¢˜ä¸‰: æä¾›æ­»ä»£ç æ¶ˆé™¤ä¼˜åŒ–å™¨
- ä¸»é¢˜å››: æä¾›å¸¸é‡æŠ˜å ä¼˜åŒ–å™¨

**æœ¬ä¸»é¢˜èŒè´£**: ç»„åˆæ‰€æœ‰ä¼˜åŒ–å™¨
- å®šä¹‰ä¼˜åŒ–å™¨æ¥å£`IFlowOptimizer`
- åœ¨`CFG`ä¸­ç®¡ç†ä¼˜åŒ–å™¨é“¾
- æŒ‰åºæ‰§è¡Œæ‰€æœ‰ä¼˜åŒ–Pass

---

### 5.1 æ ¸å¿ƒæ¦‚å¿µ

#### ä¸ºä»€ä¹ˆéœ€è¦ä¼˜åŒ–å™¨é“¾ï¼Ÿ

**å•ä¸€ä¼˜åŒ–çš„å±€é™æ€§**:
```
å¸¸é‡æŠ˜å : x = 3 + 5 â†’ x = 8
æ­»ä»£ç æ¶ˆé™¤: if (false) {...} â†’ åˆ é™¤åˆ†æ”¯

é—®é¢˜: éœ€è¦ä¸¤ç§ä¼˜åŒ–é…åˆï¼
```

**ä¼˜åŒ–å™¨é“¾çš„å¥½å¤„**:
- **æ¨¡å—åŒ–**: æ¯ä¸ªä¼˜åŒ–å™¨ç‹¬ç«‹
- **å¯ç»„åˆ**: çµæ´»é€‰æ‹©ä¼˜åŒ–Pass
- **å¯æ‰©å±•**: æ˜“äºæ·»åŠ æ–°ä¼˜åŒ–

#### ä¼˜åŒ–å™¨é¡ºåºçš„é‡è¦æ€§

**é”™è¯¯é¡ºåº**:
```
1. æ­»ä»£ç æ¶ˆé™¤
2. å¸¸é‡æŠ˜å 

é—®é¢˜: å¸¸é‡æŠ˜å äº§ç”Ÿçš„æ–°æ­»ä»£ç ä¸ä¼šè¢«æ¶ˆé™¤
```

**æ­£ç¡®é¡ºåº**:
```
1. å¸¸é‡æŠ˜å     # äº§ç”Ÿæ–°å¸¸é‡
2. æ­»ä»£ç æ¶ˆé™¤  # åˆ é™¤å› å¸¸é‡è€Œæ­»çš„ä»£ç 
3. é‡å¤1-2ç›´åˆ°ä¸åŠ¨ç‚¹
```

**å…¸å‹ä¼˜åŒ–åºåˆ—**:
```
1. å¸¸é‡æŠ˜å            # ä¸»é¢˜å››
2. æ­»ä»£ç æ¶ˆé™¤         # ä¸»é¢˜ä¸‰
3. å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤   # (ç»ƒä¹ )
4. æ­»ä»£ç æ¶ˆé™¤         # ä¸»é¢˜ä¸‰ (å†æ¬¡)
5. å°¾é€’å½’ä¼˜åŒ–         # (å…¶ä»–)
```

---

### 5.2 å®ç°åŸç†

#### ä¼˜åŒ–å™¨æ¥å£

```java
// ä¼˜åŒ–å™¨æ¥å£ï¼ˆç­–ç•¥æ¨¡å¼ï¼‰
public interface IFlowOptimizer {
    String getName();
    CFG onHandle(CFG cfg);
}
```

**å·²å®ç°çš„ä¼˜åŒ–å™¨**:
- `ConstantFoldingOptimizer implements IFlowOptimizer` (ä¸»é¢˜å››)
- `DeadCodeEliminationOptimizer implements IFlowOptimizer` (ä¸»é¢˜ä¸‰)
- `CommonSubexpressionEliminationOptimizer implements IFlowOptimizer`
- `TailRecursionOptimizer implements IFlowOptimizer`

#### ä¼˜åŒ–å™¨é“¾å®ç°

```java
public class CFG {
    private List<IFlowOptimizer> optimizers = new ArrayList<>();

    // æ³¨å†Œä¼˜åŒ–å™¨
    public void addOptimizer(IFlowOptimizer optimizer) {
        optimizers.add(optimizer);
        System.out.println("Registered optimizer: " + optimizer.getName());
    }

    // æ‰§è¡Œæ‰€æœ‰ä¼˜åŒ–å™¨
    public CFG applyOptimizers() {
        CFG currentCFG = this;
        int pass = 1;

        for (IFlowOptimizer optimizer : optimizers) {
            System.out.println("\n=== Pass " + pass + ": " + optimizer.getName() + " ===");

            long startTime = System.currentTimeMillis();
            currentCFG = optimizer.onHandle(currentCFG);
            long endTime = System.currentTimeMillis();

            System.out.println("Completed in " + (endTime - startTime) + "ms");
            System.out.println("Blocks: " + currentCFG.getBlocks().size());

            pass++;
        }

        return currentCFG;
    }
}
```

#### ä½¿ç”¨ç¤ºä¾‹

```java
// åˆ›å»ºCFG
CFG cfg = new CFG(irProgram);

// æ³¨å†Œä¼˜åŒ–å™¨ï¼ˆé¡ºåºé‡è¦ï¼ï¼‰
cfg.addOptimizer(new ConstantFoldingOptimizer());           // ä¸»é¢˜å››
cfg.addOptimizer(new DeadCodeEliminationOptimizer());       // ä¸»é¢˜ä¸‰
cfg.addOptimizer(new CommonSubexpressionEliminationOptimizer()); // ç»ƒä¹ 
cfg.addOptimizer(new DeadCodeEliminationOptimizer());       // ä¸»é¢˜ä¸‰ (å†æ¬¡)

// æ‰§è¡Œä¼˜åŒ–
CFG optimized = cfg.applyOptimizers();
```

**æ‰§è¡Œè¾“å‡º**:
```
Registered optimizer: Constant Folding
Registered optimizer: Dead Code Elimination
Registered optimizer: Common Subexpression Elimination

=== Pass 1: Constant Folding ===
Folded 15 expressions
Completed in 15ms
Blocks: 10

=== Pass 2: Dead Code Elimination ===
Removed 2 unreachable blocks
Removed 5 dead stores
Completed in 8ms
Blocks: 8

=== Pass 3: Common Subexpression Elimination ===
Eliminated 3 common subexpressions
Completed in 12ms
Blocks: 8

=== Pass 4: Dead Code Elimination ===
Removed 1 dead store
Completed in 5ms
Blocks: 8
```

---

### 5.3 è®¾è®¡æ¨¡å¼

#### 1. ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰

```
IFlowOptimizer (æ¥å£)
â”œâ”€â”€ ConstantFoldingOptimizer
â”œâ”€â”€ DeadCodeEliminationOptimizer
â”œâ”€â”€ CommonSubexpressionEliminationOptimizer
â””â”€â”€ ...

å¥½å¤„:
- ä¼˜åŒ–å™¨å¯æ’æ‹”
- æ˜“äºæ·»åŠ æ–°ä¼˜åŒ–
- æ¯ä¸ªä¼˜åŒ–å™¨ç‹¬ç«‹æµ‹è¯•
```

#### 2. è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibilityï¼‰

```
CFG.addOptimizer(A)
   .addOptimizer(B)
   .addOptimizer(C)

æ‰§è¡Œæµç¨‹:
Input â†’ A.onHandle() â†’ B.onHandle() â†’ C.onHandle() â†’ Output

å¥½å¤„:
- çµæ´»ç»„åˆ
- å‰ä¸€ä¸ªçš„è¾“å‡ºæ˜¯åä¸€ä¸ªçš„è¾“å…¥
```

#### 3. æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼ˆTemplate Methodï¼‰

```
AbstractDataFlowAnalysis
â”œâ”€â”€ analyze()  # æ¨¡æ¿æ–¹æ³•
â”œâ”€â”€ initialize()  # å­ç±»å®ç°
â”œâ”€â”€ meet()  # å­ç±»å®ç°
â””â”€â”€ transfer()  # å­ç±»å®ç°

å¥½å¤„:
- ç®—æ³•æ¡†æ¶ç»Ÿä¸€
- å­ç±»åªéœ€å®ç°å·®å¼‚åŒ–éƒ¨åˆ†
```

---

### 5.4 å®è·µç»ƒä¹ 

**ç»ƒä¹ 5: å®ç°æ–°çš„ä¼˜åŒ–å™¨**

**ä»»åŠ¡**: å®ç°å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ï¼ˆCSEï¼‰

**ç›®æ ‡**: æ¶ˆé™¤é‡å¤è®¡ç®—

**ç¤ºä¾‹**:
```
ä¼˜åŒ–å‰:
x = a + b * c
y = a + b * c

ä¼˜åŒ–å:
t = a + b * c
x = t
y = t
```

**æç¤º**:
```java
public class CommonSubexpressionEliminationOptimizer implements IFlowOptimizer {
    @Override
    public CFG onHandle(CFG cfg) {
        // 1. å¯ç”¨è¡¨è¾¾å¼åˆ†æï¼ˆå‰å‘æ•°æ®æµåˆ†æï¼‰
        AvailableExpressionsAnalysis analysis = new AvailableExpressionsAnalysis();
        DataFlowResult<Expression> result = analysis.analyze(cfg);

        // 2. æŸ¥æ‰¾é‡å¤è¡¨è¾¾å¼
        for (BasicBlock block : cfg.getBlocks()) {
            eliminateDuplicates(block, result);
        }

        return cfg;
    }
}
```

---

### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ç»¼åˆå®æˆ˜

**ä½ åˆšåˆšå®ç°äº†**:
```java
public class CFG {
    private List<IFlowOptimizer> optimizers = new ArrayList<>();

    public void addOptimizer(IFlowOptimizer optimizer) {
        optimizers.add(optimizer);
    }

    public CFG applyOptimizers() {
        for (IFlowOptimizer optimizer : optimizers) {
            optimizer.onHandle(this);  // æŒ‰åºæ‰§è¡Œ
        }
        return this;
    }
}
```

**ç°åœ¨ä½ å·²ç»æŒæ¡äº†**:
- âœ… ä¸»é¢˜ä¸€: æ•°æ®æµåˆ†ææ¡†æ¶
- âœ… ä¸»é¢˜äºŒ: æ´»è·ƒå˜é‡åˆ†æ
- âœ… ä¸»é¢˜ä¸‰: æ­»ä»£ç æ¶ˆé™¤
- âœ… ä¸»é¢˜å››: å¸¸é‡æŠ˜å 
- âœ… ä¸»é¢˜äº”: ä¼˜åŒ–å™¨é“¾è®¾è®¡

**ä¸‹ä¸€æ­¥**: ç»¼åˆå®æˆ˜ - ä»é›¶æ„å»ºå®Œæ•´çš„ä¼˜åŒ–ç³»ç»Ÿ

---

# Layer 3: ç»¼åˆå®æˆ˜

## ğŸš€ å®æˆ˜é¡¹ç›®ï¼šä»é›¶æ„å»ºå®Œæ•´ä¼˜åŒ–ç³»ç»Ÿ

> **å­¦ä¹ æ—¶é—´**: 2å°æ—¶ | **éš¾åº¦**: â­â­â­â­ | **ç›®æ ‡**: æ•´åˆæ‰€æœ‰ä¸»é¢˜ï¼Œå®ç°ç«¯åˆ°ç«¯ä¼˜åŒ–æµç¨‹

### é¡¹ç›®æ¦‚è¿°

**ç›®æ ‡**: å®ç°ä¸€ä¸ªå®Œæ•´çš„ç¼–è¯‘å™¨ä¼˜åŒ–Passç³»ç»Ÿ

**è¾“å…¥**: æœªä¼˜åŒ–çš„IRç¨‹åº

**è¾“å‡º**: ä¼˜åŒ–åçš„IRç¨‹åº

**éªŒè¯**: å¯¹æ¯”ä¼˜åŒ–å‰åçš„æ€§èƒ½å’Œä»£ç å¤§å°

---

### é˜¶æ®µ1: æ„å»ºåŸºç¡€æ•°æ®ç»“æ„

**ä»»åŠ¡**: å®ç°CFGå’ŒBasicBlock

**ä»£ç **:
```java
// æ§åˆ¶æµå›¾
public class CFG<I extends IRNode> implements Iterable<BasicBlock<I>> {
    private final List<BasicBlock<I>> blocks = new ArrayList<>();
    private final List<IFlowOptimizer<I>> optimizers = new ArrayList<>();

    public void addBlock(BasicBlock<I> block) {
        blocks.add(block);
    }

    public void addOptimizer(IFlowOptimizer<I> optimizer) {
        optimizers.add(optimizer);
    }

    public CFG<I> applyOptimizers() {
        CFG<I> current = this;
        for (IFlowOptimizer<I> optimizer : optimizers) {
            current = optimizer.onHandle(current);
        }
        return current;
    }
}

// åŸºæœ¬å—
public class BasicBlock<I extends IRNode> {
    private final int id;
    private final List<I> instructions = new ArrayList<>();
    private final Set<BasicBlock<I>> predecessors = new HashSet<>();
    private final Set<BasicBlock<I>> successors = new HashSet<>();

    public void addInstruction(I instr) {
        instructions.add(instr);
    }

    public void addSuccessor(BasicBlock<I> succ) {
        successors.add(succ);
        succ.predecessors.add(this);
    }
}
```

---

### é˜¶æ®µ2: å®ç°æ•°æ®æµåˆ†ææ¡†æ¶

**ä»»åŠ¡**: å®ç°`AbstractDataFlowAnalysis`

**ä»£ç **:
```java
public abstract class AbstractDataFlowAnalysis<T, I extends IRNode> {
    protected final CFG<I> cfg;
    protected final Map<Integer, T> in = new HashMap<>();
    protected final Map<Integer, T> out = new HashMap<>();

    public AbstractDataFlowAnalysis(CFG<I> cfg) {
        this.cfg = cfg;
    }

    // æ¨¡æ¿æ–¹æ³•ï¼šå®šä¹‰ç®—æ³•éª¨æ¶
    public final void analyze() {
        initialize();

        boolean changed = true;
        while (changed) {
            changed = isForward() ? forwardIteration() : backwardIteration();
        }
    }

    // æŠ½è±¡æ–¹æ³•ï¼šç”±å­ç±»å®ç°
    public abstract boolean isForward();
    protected abstract T initialize();
    protected abstract T meet(T a, T b);
    protected abstract T transfer(I instr, T input);
}
```

**éªŒè¯**: ç¡®ä¿æ¡†æ¶ä»£ç å¯ä»¥ç¼–è¯‘é€šè¿‡

---

### é˜¶æ®µ3: å®ç°æ´»è·ƒå˜é‡åˆ†æ

**ä»»åŠ¡**: ç»§æ‰¿æ¡†æ¶ï¼Œå®ç°æ´»è·ƒå˜é‡åˆ†æ

**ä»£ç **:
```java
public class LiveVariableAnalysis extends AbstractDataFlowAnalysis<Set<Operand>, IRNode> {

    public LiveVariableAnalysis(CFG<IRNode> cfg) {
        super(cfg);
    }

    @Override
    public boolean isForward() {
        return false;  // åå‘åˆ†æ
    }

    @Override
    protected Set<Operand> initialize() {
        Set<Operand> empty = new HashSet<>();
        for (BasicBlock<IRNode> block : cfg) {
            in.put(block.getId(), empty);
            out.put(block.getId(), empty);
        }
        return empty;
    }

    @Override
    protected Set<Operand> meet(Set<Operand> a, Set<Operand> b) {
        Set<Operand> result = new HashSet<>(a);
        result.addAll(b);  // å¹¶é›†
        return result;
    }

    @Override
    protected Set<Operand> transfer(IRNode instr, Set<Operand> input) {
        Set<Operand> result = new HashSet<>(input);

        if (instr.getType() == IRNodeType.VariableWrite) {
            result.remove(instr.getVariable());  // def: ç§»é™¤
        } else if (instr.getType() == IRNodeType.VariableRead) {
            result.add(instr.getVariable());    // use: æ·»åŠ 
        }

        return result;
    }

    public Set<Operand> getOUT(BasicBlock<IRNode> block) {
        return out.get(block.getId());
    }
}
```

**éªŒè¯**: ç¼–å†™æµ‹è¯•ç”¨ä¾‹éªŒè¯åˆ†æç»“æœ

---

### é˜¶æ®µ4: å®ç°ä¼˜åŒ–å™¨

**ä»»åŠ¡4.1**: å¸¸é‡æŠ˜å ä¼˜åŒ–å™¨

```java
public class ConstantFoldingOptimizer implements IFlowOptimizer<IRNode> {

    @Override
    public CFG<IRNode> onHandle(CFG<IRNode> cfg) {
        for (BasicBlock<IRNode> block : cfg) {
            for (IRNode node : block.getInstructions()) {
                if (node instanceof BinExpr) {
                    tryFold((BinExpr) node, block);
                }
            }
        }
        return cfg;
    }

    private void tryFold(BinExpr expr, BasicBlock<IRNode> block) {
        IRNode left = expr.getLeft();
        IRNode right = expr.getRight();

        if (left.isConstant() && right.isConstant()) {
            Object result = eval(expr.getOp(), left.getValue(), right.getValue());
            block.replace(expr, new ConstantNode(result));
        }
    }
}
```

**ä»»åŠ¡4.2**: æ­»ä»£ç æ¶ˆé™¤ä¼˜åŒ–å™¨

```java
public class DeadCodeEliminationOptimizer implements IFlowOptimizer<IRNode> {

    @Override
    public CFG<IRNode> onHandle(CFG<IRNode> cfg) {
        // 1. ä¸å¯è¾¾ä»£ç æ¶ˆé™¤
        eliminateUnreachable(cfg);

        // 2. æ­»å­˜å‚¨æ¶ˆé™¤ï¼ˆä½¿ç”¨æ´»è·ƒå˜é‡åˆ†æï¼‰
        LiveVariableAnalysis lva = new LiveVariableAnalysis(cfg);
        lva.analyze();
        eliminateDeadStores(cfg, lva);

        return cfg;
    }

    private void eliminateDeadStores(CFG<IRNode> cfg, LiveVariableAnalysis lva) {
        for (BasicBlock<IRNode> block : cfg) {
            Set<Operand> liveOut = lva.getOUT(block);

            for (IRNode instr : reverse(block.getInstructions())) {
                if (instr instanceof Assign) {
                    VarSlot var = ((Assign) instr).getLhs();
                    if (!liveOut.contains(var)) {
                        block.remove(instr);  // æ­»å­˜å‚¨ï¼Œåˆ é™¤
                    }
                }
                liveOut = lva.transfer(instr, liveOut);
            }
        }
    }
}
```

**éªŒè¯**: åˆ†åˆ«æµ‹è¯•æ¯ä¸ªä¼˜åŒ–å™¨çš„æ•ˆæœ

---

### é˜¶æ®µ5: ç»„è£…ä¼˜åŒ–å™¨é“¾

**ä»»åŠ¡**: å°†æ‰€æœ‰ä¼˜åŒ–å™¨ç»„åˆæˆå®Œæ•´ç³»ç»Ÿ

**ä»£ç **:
```java
public class OptimizationPipeline {
    public static void main(String[] args) {
        // 1. æ„å»ºCFG
        CFG<IRNode> cfg = buildCFGFromIR(irProgram);

        // 2. é…ç½®ä¼˜åŒ–å™¨é“¾
        cfg.addOptimizer(new ConstantFoldingOptimizer());
        cfg.addOptimizer(new DeadCodeEliminationOptimizer());

        // 3. æ‰§è¡Œä¼˜åŒ–
        CFG<IRNode> optimized = cfg.applyOptimizers();

        // 4. ç”Ÿæˆä»£ç 
        generateCode(optimized);
    }

    private static CFG<IRNode> buildCFGFromIR(IRProgram program) {
        // å°†IRç¨‹åºè½¬æ¢ä¸ºCFG
        CFGBuilder builder = new CFGBuilder();
        return builder.build(program);
    }

    private static void generateCode(CFG<IRNode> cfg) {
        // å°†ä¼˜åŒ–çš„CFGè½¬æ¢ä¸ºç›®æ ‡ä»£ç 
        CodeGenerator gen = new CodeGenerator();
        gen.generate(cfg);
    }
}
```

---

### é˜¶æ®µ6: ç«¯åˆ°ç«¯æµ‹è¯•

**æµ‹è¯•ç¨‹åº**:
```c
int example(int x) {
    int a = 3 + 5;    // å¸¸é‡æŠ˜å  â†’ a = 8
    int b = x * 2;
    int c = a + b;
    int d = 10;       // æ­»å­˜å‚¨ï¼ˆæœªä½¿ç”¨ï¼‰
    return c;
}
```

**ä¼˜åŒ–è¿‡ç¨‹**:
```
åŸå§‹IR:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚ a=3+5 â”‚
â”‚ b=x*2 â”‚
â”‚ c=a+b â”‚
â”‚ d=10  â”‚ â† æ­»å­˜å‚¨
â”‚ ret c â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜

Pass 1: å¸¸é‡æŠ˜å 
â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚ a=8   â”‚ â† æŠ˜å 
â”‚ b=x*2 â”‚
â”‚ c=a+b â”‚
â”‚ d=10  â”‚
â”‚ ret c â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜

Pass 2: æ­»ä»£ç æ¶ˆé™¤ï¼ˆä½¿ç”¨æ´»è·ƒå˜é‡åˆ†æï¼‰
â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚ a=8   â”‚
â”‚ b=x*2 â”‚
â”‚ c=a+b â”‚
â”‚ ret c â”‚ â† d=10è¢«åˆ é™¤
â””â”€â”€â”€â”€â”€â”€â”€â”˜

æœ€ç»ˆä»£ç :
int example(int x) {
    return 8 + x * 2;
}
```

**æ€§èƒ½å¯¹æ¯”**:
```
ä¼˜åŒ–å‰:
- ä»£ç å¤§å°: 100 bytes
- æ‰§è¡Œæ—¶é—´: 100 ns

ä¼˜åŒ–å:
- ä»£ç å¤§å°: 60 bytes (â†“40%)
- æ‰§è¡Œæ—¶é—´: 70 ns (â†“30%)
```

---

## ğŸ“– æ€»ç»“ä¸è¿›é˜¶

### è®¾è®¡æ¨¡å¼å›é¡¾

| æ¨¡å¼ | åº”ç”¨ | å¥½å¤„ |
|------|------|------|
| **æ¨¡æ¿æ–¹æ³•** | æ•°æ®æµåˆ†ææ¡†æ¶ | ç®—æ³•å¤ç”¨ï¼Œç»Ÿä¸€æ¡†æ¶ |
| **ç­–ç•¥æ¨¡å¼** | ä¼˜åŒ–å™¨æ¥å£ | å¯æ’æ‹”ï¼Œæ˜“æ‰©å±• |
| **è´£ä»»é“¾** | ä¼˜åŒ–å™¨é“¾ | çµæ´»ç»„åˆ |
| **è®¿é—®è€…** | CFGéå† | æ“ä½œä¸ç»“æ„åˆ†ç¦» |

### æ ¸å¿ƒç®—æ³•æ€»ç»“

| ç®—æ³• | å¤æ‚åº¦ | åº”ç”¨ |
|------|--------|------|
| ä¸åŠ¨ç‚¹è¿­ä»£ | O(NÃ—H) | æ•°æ®æµåˆ†æ |
| DFSå¯è¾¾æ€§ | O(V+E) | ä¸å¯è¾¾ä»£ç  |
| æ‹“æ‰‘æ’åº | O(V+E) | åŠ é€Ÿæ”¶æ•› |
| å¸¸é‡æŠ˜å  | O(N) | è¡¨è¾¾å¼æ±‚å€¼ |

### è¿›é˜¶ä¸»é¢˜

#### ä¸»é¢˜1: è¿‡ç¨‹é—´ä¼˜åŒ–

**å†…è”ï¼ˆInliningï¼‰**:
```c
// å†…è”å‰
int square(int x) { return x * x; }
int y = square(5);

// å†…è”å
int y = 5 * 5;
```

#### ä¸»é¢˜2: å¾ªç¯ä¼˜åŒ–

**å¾ªç¯å±•å¼€ï¼ˆLoop Unrollingï¼‰**:
```c
// ä¼˜åŒ–å‰
for (int i = 0; i < 4; i++) {
    a[i] = b[i] * c;
}

// ä¼˜åŒ–å
a[0] = b[0] * c;
a[1] = b[1] * c;
a[2] = b[2] * c;
a[3] = b[3] * c;
```

#### ä¸»é¢˜3: SSAä¸Šçš„ä¼˜åŒ–

**ä¼˜åŠ¿**:
- ä½¿ç”¨-å®šä¹‰é“¾æ˜¾å¼
- ç®€åŒ–æ•°æ®æµåˆ†æ
- ä¾¿äºä¼˜åŒ–å®ç°

---

## âœ… æ£€æŸ¥ç‚¹

å®Œæˆæœ¬EPåï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] è§£é‡Šæ•°æ®æµåˆ†æçš„æ•°å­¦åŸºç¡€ï¼ˆåŠæ ¼ã€ä¼ é€’å‡½æ•°ã€ä¸åŠ¨ç‚¹ï¼‰
- [ ] å®ç°å‰å‘å’Œåå‘æ•°æ®æµåˆ†ææ¡†æ¶
- [ ] ç†è§£æ´»è·ƒå˜é‡åˆ†æçš„GEN/KILLé›†åˆ
- [ ] å®ç°æ­»ä»£ç æ¶ˆé™¤ï¼ˆä¸å¯è¾¾ä»£ç  + æ­»å­˜å‚¨ï¼‰
- [ ] å®ç°å¸¸é‡æŠ˜å ä¼˜åŒ–
- [ ] ç†è§£ä¼˜åŒ–å™¨é“¾çš„è®¾è®¡æ¨¡å¼
- [ ] åˆ†æä¼˜åŒ–å™¨çš„æ‰§è¡Œé¡ºåºå’Œä¾èµ–å…³ç³»
- [ ] è¯„ä¼°ä¼˜åŒ–æ•ˆæœï¼ˆä»£ç å¤§å°ã€æ‰§è¡Œæ—¶é—´ï¼‰
- [ ] ä»é›¶æ„å»ºå®Œæ•´çš„ä¼˜åŒ–ç³»ç»Ÿ

---

## ğŸ“ ä¸‹ä¸€æ­¥

- **æ·±å…¥ç ”ç©¶**: é˜…è¯»LLVMæºç ï¼Œç†è§£å·¥ä¸šçº§ä¼˜åŒ–å™¨å®ç°
- **å®è·µé¡¹ç›®**: ä¸ºè‡ªå·±çš„è¯­è¨€å®ç°ä¼˜åŒ–Pass
- **æ€§èƒ½åˆ†æ**: ä½¿ç”¨åŸºå‡†æµ‹è¯•è¯„ä¼°ä¼˜åŒ–æ•ˆæœ
- **æ‰©å±•å­¦ä¹ **: æ¢ç´¢SSAä¸Šçš„é«˜çº§ä¼˜åŒ–

---

*ç‰ˆæœ¬: v3.0 | EP21æ•™å­¦æ–‡æ¡£ï¼ˆä¸‰å±‚å™äº‹ç»“æ„ï¼‰| 2025-12-27*
