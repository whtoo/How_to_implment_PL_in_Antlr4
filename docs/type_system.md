# Cymbol 语言类型系统

## 1. 引言

Cymbol采用静态类型系统。这意味着每个变量、表达式和函数参数的类型在编译时都是已知的，并且编译器会检查这些类型以确保类型安全和操作的有效性。类型系统旨在提供清晰的语义，并帮助在早期捕获常见的编程错误。

## 2. 基本数据类型 (Primitive Types)

Cymbol支持以下内置的基本数据类型：

*   **`int`**:
    *   描述：表示32位有符号整数。
    *   范围：通常对应Java的 `int` 类型（例如，-2,147,483,648 到 2,147,483,647）。
    *   示例：`10`, `0`, `-123`。

*   **`float`**:
    *   描述：表示单精度浮点数（在解释器中可能使用Java的 `float` 或 `double` 实现）。
    *   精度：通常对应Java的 `float` 类型。
    *   示例：`3.14`, `-0.001`, `100.0`。

*   **`boolean`**:
    *   描述：表示逻辑值。
    *   值：只能是 `true` 或 `false`。
    *   示例：`true`, `false`。

*   **`string`**:
    *   描述：表示文本字符序列。字符串是不可变的。
    *   示例：`"hello"`, `""` (空字符串)。

*   **`char`**:
    *   描述：表示单个字符。
    *   示例：`'a'`, `'%'`, `'7'`。

*   **`void`**:
    *   描述：一个特殊的类型，表示“没有值”。
    *   用途：主要用作函数的返回类型，表明该函数不返回任何值。不能用于声明变量。

## 3. 用户定义类型 (User-Defined Types)

### 3.1 结构体 (Structs)

结构体是一种复合数据类型，允许将多个不同或相同类型的变量（称为成员或字段）组合成一个单一的命名单元。

*   **定义**:
    ```cymbol
    struct Point {
        int x;
        int y;
        string label;
    }; // Cymbol EP19 语法定义 ('struct' ID '{' structMemeber+ '}') 不需要分号
    ```
*   **特性**:
    *   每个结构体定义了一种新的类型。
    *   结构体的成员可以是任何基本类型或其他已定义的结构体类型（允许嵌套结构体）。
    *   结构体还可以包含方法（在结构体内部定义的函数）。
*   **实例化**: 当声明一个结构体类型的变量时，会为其分配内存并创建一个实例。
    ```cymbol
    Point p1; // p1 是一个 Point 类型的实例
    p1.x = 10;
    ```

### 3.2 类型别名 (`typedef`)

`typedef` 允许为已有的类型创建一个新的名称（别名）。这可以使代码更具可读性或简化复杂类型的声明。

*   **语法**: `typedef existingType newTypeName;`
*   **示例**:
    ```cymbol
    typedef int Count;
    typedef string Message;
    typedef Point Vec2D;

    Count itemCount = 100;
    Message greeting = "Hello";
    Vec2D direction;
    direction.x = 1;
    ```
*   `typedef` 不创建新类型，它只是为现有类型提供一个备用名称。`newTypeName` 在类型检查时与 `existingType` 完全等价。

## 4. 数组类型 (Array Types)

数组是固定大小的、存储相同类型元素的有序集合。

*   **声明**: `elementType arrayName[size];`
    *   `elementType` 指定数组中所有元素的类型。
    *   `arrayName` 是数组变量的名称。
    *   `size` 是一个整数表达式，指定数组可以容纳的元素数量。
*   **示例**:
    ```cymbol
    int scores[10];         // 一个包含10个int类型元素的数组
    float readings[3];      // 一个包含3个float类型元素的数组
    Point pathNodes[5];     // 一个包含5个Point结构体实例的数组
    ```
*   **特性**:
    *   数组大小在声明后是固定的。
    *   数组索引从 `0` 开始，到 `size - 1` 结束。
    *   Cymbol中的数组是一维的。

## 5. 类型兼容性和转换

类型兼容性决定了在不同类型的操作数之间可以执行哪些操作（如赋值、算术运算等）。Cymbol主要依赖于隐式类型转换规则。

### 5.1 赋值兼容性

在赋值语句 `LHS = RHS;` 中，右侧表达式 (`RHS`) 的类型必须与左侧变量 (`LHS`) 的类型兼容。

*   **相同类型**: 任何类型都可以赋值给相同类型的变量。
    ```cymbol
    int a = 10;
    int b = a; // OK

    Point p1;
    Point p2 = p1; // OK (结构体赋值通常是浅拷贝其实例数据)
    ```
*   **`int` 到 `float`**: `int` 类型的值可以隐式转换为 `float` 类型并赋值给 `float` 变量。
    ```cymbol
    float f;
    int i = 100;
    f = i; // OK, f 将是 100.0
    ```
*   **`float` 到 `int`**: 不允许隐式转换。这通常需要显式转换函数（Cymbol EP19中未提供）。
    ```cymbol
    // int i;
    // float f = 12.34;
    // i = f; // 错误：类型不兼容
    ```
*   **结构体类型**: 结构体变量只能赋值给相同结构体类型的变量。不同结构体类型即使成员完全相同，也被视为不兼容。
    ```cymbol
    struct A { int x; };
    struct B { int x; };
    A a1;
    B b1;
    // a1 = b1; // 错误：类型不兼容
    ```
*   **数组类型**: 数组赋值通常要求类型和大小都匹配，或者可能不支持直接的数组赋值（需要逐元素复制）。Cymbol EP19倾向于不支持直接的数组对数组赋值，而是通过元素操作。
*   **`string`, `char`, `boolean`**: 通常只兼容其自身类型。

### 5.2 运算兼容性

#### 5.2.1 算术运算 (`+`, `-`, `*`, `/`, `%`)

*   **`int` 和 `int`**: 结果为 `int`。
*   **`float` 和 `float`**: 结果为 `float`。
*   **`int` 和 `float`**: `int` 操作数会提升为 `float`，结果为 `float`。
    ```cymbol
    int i = 5; float f = 2.0;
    float result = i + f; // result 是 7.0 (float)
    ```
*   **`%` (取模)**: 操作数必须是 `int` 类型，结果为 `int`。
*   **`+` 与 `string`**: 如果其中一个操作数是 `string`，`+` 运算符执行字符串连接。非字符串操作数会尝试转换成其字符串表示。
    ```cymbol
    string s1 = "Hello";
    string s2 = s1 + " World"; // "Hello World"
    string s3 = "Value: " + 10; // "Value: 10"
    ```

#### 5.2.2 比较运算 (`==`, `!=`, `<`, `>`, `<=`, `>=`)

*   **数字类型 (`int`, `float`)**: 可以相互比较。如果一个是 `int` 而另一个是 `float`，`int` 会提升为 `float` 进行比较。结果为 `boolean`。
*   **`boolean`**: 可以进行 `==` 和 `!=` 比较。
*   **`string`, `char`**: 可以进行 `==` 和 `!=` 比较。对于 `string`，比较的是内容是否相同。
*   **结构体和数组**: 通常不支持直接的比较运算（除了 `==` 和 `!=` 可能比较引用，但这在Cymbol中行为需明确）。Cymbol EP19中，结构体和数组不支持这些比较运算符。

#### 5.2.3 逻辑运算 (`&&`, `!`)

*   操作数必须是 `boolean` 类型。
*   结果为 `boolean` 类型。

## 6. 类型检查 (Type Checking)

Cymbol编译器在编译过程中执行严格的类型检查，主要由 `TypeCheckVisitor` 组件完成。

*   **变量声明**: 检查变量类型是否有效。
*   **赋值**: 检查赋值语句左右两边的类型兼容性。
*   **表达式**: 检查操作符的操作数类型是否兼容，并确定表达式结果的类型。
*   **函数调用**:
    *   检查传递给函数的参数数量和类型是否与函数声明匹配。
    *   检查函数调用表达式本身的类型是否与其上下文兼容（例如，在赋值语句中）。
*   **`return` 语句**: 检查函数体中 `return` 语句返回的表达式类型是否与函数声明的返回类型兼容。`void` 函数不能返回值，非 `void` 函数必须返回正确类型的值。
*   **结构体成员访问**: 确保访问的成员存在于结构体中，并正确使用其类型。
*   **数组访问**: 确保数组索引是 `int` 类型。

类型检查的目标是确保程序在运行时不会因为类型不匹配而发生错误。任何违反类型规则的代码都会在编译阶段报告错误。

## 7. `null` 值

Cymbol 语法中定义了 `NULL : 'null';` 词法规则。然而，在当前的EP19实现中：

*   基本类型（`int`, `float`, `boolean`, `char`）不能为 `null`。它们总是有默认值（例如，`int` 默认为0，`boolean` 默认为 `false`，尽管Cymbol可能要求显式初始化）。
*   `string` 类型的变量可以被赋予 `null` 的概念，或者表示一个未初始化的字符串。
*   结构体实例在声明后即被创建，不会是 `null`。
*   目前，`null` 主要用于解释器内部表示某些空或未定义状态，用户层面直接使用 `null` 字面量进行赋值或比较的行为需要谨慎对待，可能未被完全支持或行为未明确定义。在类型检查层面，`null` 的处理尚不突出。

## 8. 类型推断

Cymbol不进行类型推断。所有变量、函数参数和函数返回类型都必须显式声明。

---
*本类型系统文档基于对Cymbol EP19编译器实现的分析编写。*
