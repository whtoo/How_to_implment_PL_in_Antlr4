# SSA å½¢å¼æ„é€ ä¸ä¼˜åŒ–

## ğŸ“‹ æ–‡æ¡£ç›®çš„

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜é™æ€å•èµ‹å€¼ï¼ˆStatic Single Assignment, SSAï¼‰å½¢å¼çš„ç†è®ºåŸºç¡€ã€æ„é€ ç®—æ³•ã€ä¼˜åŒ–æœºä¼šå’Œé”€æ¯æµç¨‹ï¼Œä¸ºEP21æ¨¡å—æä¾›å®Œæ•´çš„æŠ€æœ¯å‚è€ƒå’Œå®ç°æŒ‡å—ã€‚

---

## ğŸ¯ SSA å½¢å¼æ¦‚è¿°

### å®šä¹‰

**é™æ€å•èµ‹å€¼ï¼ˆStatic Single Assignment, SSAï¼‰**ï¼šæ¯ä¸ªå˜é‡åªè¢«èµ‹å€¼ä¸€æ¬¡çš„æ§åˆ¶æµå›¾å½¢å¼ã€‚

**æ ¸å¿ƒç‰¹å¾**ï¼š
1. **å•æ¬¡èµ‹å€¼**ï¼šç¨‹åºä¸­æ¯ä¸ªå˜é‡åªè¢«èµ‹å€¼ä¸€æ¬¡ï¼ˆåŒ…æ‹¬æ‰€æœ‰è·¯å¾„ï¼‰
2. **æ˜¾å¼èµ‹å€¼**ï¼šä½¿ç”¨Î¦å‡½æ•°åœ¨æ±‡èšç‚¹åˆå¹¶ä¸åŒè·¯å¾„çš„å€¼
3. **ä¾¿äºåˆ†æ**ï¼šæ•°æ®æµåˆ†æå’Œä¼˜åŒ–åœ¨SSAå½¢å¼ä¸‹æ›´ç®€å•

### SSA å½¢å¼ç¤ºä¾‹

**åŸå§‹ä»£ç **ï¼š
```c
int test(int x) {
    int y = 0;
    if (x > 0) {
        y = x + 1;
    }
    return y;
}
```

**SSA å½¢å¼**ï¼š
```c
int test_ssa(int x) {
    int y_1;  // è·¯å¾„1çš„å€¼
    if (x > 0) {
        y_1 = x + 1;
    }
    else {
        y_1 = 0;  // è·¯å¾„2çš„å€¼
    }
    
    y = Ï†(y_1);  // Î¦å‡½æ•°åˆå¹¶ä¸¤ä¸ªè·¯å¾„çš„å€¼
    return y;
}
```

### SSA çš„ä¼˜åŠ¿

| ä¼˜åŠ¿ | è¯´æ˜ | å…¸å‹åº”ç”¨ |
|-------|--------|--------------|
| **ç®€åŒ–æ•°æ®æµåˆ†æ** | æ¯ä¸ªå˜é‡åªè¢«å®šä¹‰ä¸€æ¬¡ï¼Œåˆ°è¾¾å®šä¹‰å’Œæ´»è·ƒå˜é‡åˆ†ææ›´ç²¾ç¡® | å¸¸é‡ä¼ æ’­ã€æ´»è·ƒå˜é‡åˆ†æ |
| **ä¼˜åŒ–æœºä¼šå¢åŠ ** | ç®€åŒ–çš„æ•°æ®æµä½¿æ›´å¤šä¼˜åŒ–å˜å¾—å¯è¡Œ | æ­»ä»£ç æ¶ˆé™¤ã€å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ |
| **å¯„å­˜å™¨åˆ†é…ä¼˜åŒ–** | å•æ¬¡èµ‹å€¼ç‰¹æ€§å¯ç®€åŒ–å¹²æ‰°å›¾çš„æ„å»º | çº¿æ€§æ‰«æå¯„å­˜å™¨åˆ†é… |
| **å¹¶è¡ŒåŒ–ç¼–è¯‘** | å‡½æ•°å‚æ•°å¯å¹¶å‘å¤„ç†ï¼Œæ— æ•°æ®ä¾èµ– | å‡½æ•°å†…è”ã€å¾ªç¯å±•å¼€ |

---

## ğŸ”§ ç†è®ºåŸºç¡€

### æ”¯é…å…³ç³»ï¼ˆDominatorï¼‰

**å®šä¹‰**ï¼šèŠ‚ç‚¹dæ”¯é…èŠ‚ç‚¹nï¼ˆè®°ä½œd â‰» nï¼‰ï¼Œå½“ä¸”ä»…å½“ä»CFGå…¥å£åˆ°nçš„æ‰€æœ‰è·¯å¾„éƒ½ç»è¿‡dæ—¶ã€‚

**æ€§è´¨**ï¼š
1. **è‡ªåæ€§**ï¼šæ¯ä¸ªèŠ‚ç‚¹æ”¯é…è‡ªå·±
2. **ä¼ é€’æ€§**ï¼šå¦‚æœaæ”¯é…bä¸”bæ”¯é…cï¼Œåˆ™aæ”¯é…c
3. **ä¸å¯è¾¾æ€§**ï¼šå¦‚æœaæ”¯é…bï¼Œåˆ™ä¸å­˜åœ¨è·¯å¾„ä»aåˆ°bä¸ç»è¿‡a
4. **å”¯ä¸€æ”¯é…è€…**ï¼šå¯¹äºèŠ‚ç‚¹nï¼Œåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å…¶ç›´æ¥æ”¯é…è€…ï¼ˆç§°ä¸ºimmediate dominatoræˆ–idom[n]ï¼‰

**åº”ç”¨åœºæ™¯**ï¼š
- ç¡®å®šPhiå‡½æ•°æ’å…¥ä½ç½®ï¼ˆåœ¨æ”¯é…è¾¹ç•Œï¼‰
- ç®€åŒ–CFGç»“æ„
- åˆ†æå¾ªç¯å’ŒåµŒå¥—ç»“æ„

**å½“å‰å®ç°**ï¼š
```java
// ä½äºï¼šep21/src/main/java/org/teachfx/antlr4/ep21/analysis/ssa/DominatorAnalysis.java
public class DominatorAnalysis<I extends IRNode> {
    private Map<Integer, Set<Integer>> dom;  // èŠ‚ç‚¹ -> æ”¯é…èŠ‚ç‚¹é›†åˆ
    private Map<Integer, Integer> idom;         // èŠ‚ç‚¹ -> ç›´æ¥æ”¯é…è€…ID
    
    public void analyze() {
        computeDominators();      // è®¡ç®—æ”¯é…é›†åˆ
        computeDominatorTree();     // æ„å»ºæ”¯é…æ ‘
        computeDominanceFrontier(); // è®¡ç®—æ”¯é…è¾¹ç•Œ
    }
    
    public boolean dominates(int a, int b) {
        Set<Integer> domB = dom.get(b);
        return domB != null && domB.contains(a);
    }
}
```

### æ”¯é…è¾¹ç•Œï¼ˆDominance Frontierï¼‰

**å®šä¹‰**ï¼šèŠ‚ç‚¹nçš„æ”¯é…è¾¹ç•ŒDF[n] = {x | næ”¯é…xçš„æŸä¸ªå‰é©±ï¼Œä½†ä¸ä¸¥æ ¼æ”¯é…x}

**ç›´è§‚ç†è§£**ï¼š
- DF[n]åŒ…å«"è¾¹ç•Œ"ä¸Šçš„èŠ‚ç‚¹ï¼Œåœ¨è¿™äº›èŠ‚ç‚¹ä¸Šå¯ä»¥"çœ‹è§"ä»n"æ¼å‡º"çš„å€¼
- å¦‚æœæŸä¸ªèŠ‚ç‚¹xçš„æ‰€æœ‰å‰é©±éƒ½åœ¨DF[n]ä¸­ï¼Œé‚£ä¹ˆxæ— æ³•"åˆ°è¾¾"é‚£äº›å‰é©±ä¹‹åçš„ä»£ç 
- å› æ­¤ï¼Œåœ¨DF[n]å¤„éœ€è¦Phiå‡½æ•°æ¥"æ•è·"æ¥è‡ªä¸åŒè·¯å¾„çš„å€¼

**ç®—æ³•æ­¥éª¤**ï¼š

**ç¬¬1æ­¥ï¼šè®¡ç®—å±€éƒ¨æ”¯é…è¾¹ç•Œ**
```
å¯¹äºæ¯ä¸ªèŠ‚ç‚¹nï¼š
    DF_local[n] = âˆª {DF_local[p] | pæ˜¯nçš„åç»§}
```

**ç¬¬2æ­¥ï¼šè¿­ä»£ä¼ æ’­å…¨å±€æ”¯é…è¾¹ç•Œ**
```
åˆå§‹åŒ–ï¼šDF[n] = DF_local[n]
changed = true

while changed:
    for each node n (æŒ‰é€†ååºéå†):
        for each node c in successors(n):
            for each node d in dominators(c):
                if dä¸åœ¨DF[n]ä¸”dæ”¯é…c:
                    DF[n] = DF[n] âˆª {c}
                    changed = true
```

**å½“å‰å®ç°**ï¼š
```java
// DominatorAnalysis.computeDominanceFrontier() æ–¹æ³•
private void computeDominanceFrontier() {
    for (BasicBlock<I> block : cfg.nodes) {
        df.put(block.getId(), new HashSet<>());
    }
    
    boolean changed;
    do {
        changed = false;
        
        for (BasicBlock<I> block : cfg.nodes) {
            int n = block.getId();
            Set<Integer> currentDF = df.get(n);
            Set<Integer> newDF = new HashSet<>(currentDF);
            
            Set<Integer> successors = cfg.getSucceed(n);
            if (successors == null) continue;
            
            for (int s : successors) {
                Set<Integer> sDom = dom.get(s);
                if (sDom != null && idom.get(s) != n) {
                    newDF.add(s);
                }
            }
            
            if (!newDF.equals(currentDF)) {
                df.put(n, newDF);
                changed = true;
            }
        }
    } while (changed);
}
```

---

## ğŸ”§ SSA æ„é€ ç®—æ³•

### Cytron ç®—æ³•ï¼ˆä¸»æµSSAæ„é€ ç®—æ³•ï¼‰

**ç®—æ³•æ¦‚è§ˆ**ï¼š
- **è®ºæ–‡**ï¼š"Efficiently Computing Static Single Assignment Form" (Cytron, Ferrante, Rosen, Wegman, Zadeck, 1991)
- **å¤æ‚åº¦**ï¼šO(E log E) çš„è¿­ä»£æ¬¡æ•°ï¼Œå…¶ä¸­Eæ˜¯è¾¹æ•°
- **é€‚ç”¨æ€§**ï¼šé€‚ç”¨äºåŒ…å«å‡½æ•°è°ƒç”¨å’Œå¤æ‚æ§åˆ¶æµçš„ç¨‹åº

**ç®—æ³•æ­¥éª¤**ï¼š

#### æ­¥éª¤1ï¼šè®¡ç®—æ”¯é…è¾¹ç•Œ
ä½¿ç”¨æ”¯é…åˆ†æå™¨è®¡ç®—æ‰€æœ‰åŸºæœ¬å—çš„æ”¯é…è¾¹ç•Œã€‚

#### æ­¥éª¤2ï¼šè¯†åˆ«å˜é‡å®šä¹‰ç‚¹
æ”¶é›†æ¯ä¸ªå˜é‡çš„æ‰€æœ‰å®šä¹‰ä½ç½®ï¼ˆåŸºæœ¬å—ï¼‰ã€‚

#### æ­¥éª¤3ï¼šæ’å…¥Phiå‡½æ•°
ä½¿ç”¨å·¥ä½œåˆ—è¡¨ç®—æ³•åœ¨æ”¯é…è¾¹ç•Œæ’å…¥Phiå‡½æ•°ã€‚

**ç®—æ³•ä¼ªä»£ç **ï¼š
```
è¾“å…¥: CFG, å˜é‡å®šä¹‰ä½ç½®é›†åˆ

è¾“å‡º: SSAå½¢å¼çš„CFG

ç®—æ³•:
    1. for each variable v:
       2.   collect all blocks where v is defined: def_blocks[v]
       3.   collect the iteration frontier of def_blocks[v]: DF[def_blocks[v]]
       4.   for each block n in DF[def_blocks[v]]:
       5.       if n not in def_blocks[v]:
       6.           insert Ï†(v) at beginning of block n
       7.           update worklist with successors(n)
       8.   
    9.   process worklist until empty
```

**å…³é”®ç‚¹**ï¼š
- **Phiå‡½æ•°æ’å…¥ä½ç½®**ï¼šåœ¨åŸºæœ¬å—å¼€å¤´ï¼ˆç¬¬ä¸€æ¡æŒ‡ä»¤ä¹‹å‰ï¼‰
- **å·¥ä½œåˆ—è¡¨ç®—æ³•**ï¼šåªå¤„ç†å®šä¹‰å˜é‡å‘ç”Ÿå˜åŒ–çš„èŠ‚ç‚¹ï¼Œæé«˜æ•ˆç‡
- **è¿­ä»£ç»ˆæ­¢**ï¼šå½“å·¥ä½œåˆ—è¡¨ä¸ºç©ºæ—¶åœæ­¢

**å½“å‰å®ç°**ï¼š
```java
// ä½äºï¼šep21/src/main/java/org/teachfx/antlr4/ep21/analysis/ssa/SSAGraph.java
public class SSAGraph {
    private CFG<IRNode> originalCFG;
    private Map<String, Integer> versionMap;
    private Map<IRNode, IRNode> renamedNodes;
    private DominatorAnalysis<IRNode> dominatorAnalysis;
    
    public SSAGraph(CFG<IRNode> cfg) {
        this.dominatorAnalysis = new DominatorAnalysis<>(cfg);
        this.dominatorAnalysis.analyze();
        this.versionMap = new HashMap<>();
        this.renamedNodes = new HashMap<>();
    }
    
    public SSAGraph buildSSA() {
        insertPhiFunctions();  // æ’å…¥Î¦å‡½æ•°
        renameVariables();       // å˜é‡é‡å‘½å
        return this;
    }
    
    private void insertPhiFunctions() {
        // æ­¥éª¤1ï¼šæ”¶é›†å˜é‡å®šä¹‰ä½ç½®
        Map<String, Set<Integer>> varDefs = collectVariableDefinitions();
        
        // æ­¥éª¤2ï¼šä¸ºæ¯ä¸ªå˜é‡æ’å…¥Phiå‡½æ•°
        for (Map.Entry<String, Set<Integer>> entry : varDefs.entrySet()) {
            String varName = entry.getKey();
            Set<Integer> defBlocks = entry.getValue();
            insertPhiFunctionsForVariable(varName, defBlocks);
        }
    }
    
    private void renameVariables() {
        // åŸºäºæ”¯é…æ ‘çš„æ·±åº¦ä¼˜å…ˆéå†é‡å‘½å
        // æŒ‰ç…§Cytronç®—æ³•çš„å˜é‡é‡å‘½åè§„åˆ™
    }
}
```

### æœ€å°åŒ–SSAï¼ˆMinimal SSAï¼‰vs Pruned SSA

| ç‰¹æ€§ | Minimal SSA | Pruned SSA |
|-------|-------------|-------------|
| **Phiå‡½æ•°** | åœ¨æ¯ä¸ªæ±‡èšç‚¹æ’å…¥ | åªåœ¨å¿…è¦å¤„æ’å…¥ |
| **å˜é‡é‡å‘½å** | æ‰€æœ‰ä¸ªå˜é‡å”¯ä¸€ç‰ˆæœ¬ | æ­»ä»£ç çš„å˜é‡ä¸é‡å‘½å |
| **ä¼˜åŠ¿** | ç®€å•ã€æ˜“äºæ„é€  | æ›´ç®€æ´ã€æ›´é«˜æ•ˆ |
| **é€‚ç”¨åœºæ™¯** | åŸºç¡€ä¼˜åŒ– | é«˜çº§ä¼˜åŒ– |

**EP21 å®ç°é€‰æ‹©**ï¼šEP21é‡‡ç”¨**Pruned SSA**ç­–ç•¥ï¼Œä»¥æé«˜SSAæ„é€ æ•ˆç‡ã€‚

---

## ğŸ’¡ SSA ä¼˜åŒ–æœºä¼š

### 1. å¸¸é‡ä¼ æ’­ï¼ˆConstant Propagationï¼‰

**åŸç†**ï¼šåœ¨SSAå½¢å¼ä¸­ï¼Œå¦‚æœPhiå‡½æ•°çš„æ‰€æœ‰æ“ä½œæ•°éƒ½æ˜¯ç›¸åŒçš„å¸¸é‡ï¼Œåˆ™Phiå‡½æ•°å¯ä»¥æŠ˜å ä¸ºè¯¥å¸¸é‡ã€‚

**ç¤ºä¾‹**ï¼š
```
// ä¼˜åŒ–å‰
y = Ï†(5, 5, 5)  // æ‰€æœ‰å‚æ•°éƒ½æ˜¯5

// ä¼˜åŒ–å
y = 5  // ç›´æ¥ä½¿ç”¨å¸¸é‡
```

**EP21 å½“å‰å®ç°**ï¼šSSAGraphä¸åŒ…å«å¸¸é‡ä¼ æ’­é€»è¾‘ï¼ˆå¯åœ¨ConstantFoldingOptimizerä¸­å®ç°ï¼‰ã€‚

### 2. æ­»ä»£ç æ¶ˆé™¤ï¼ˆDead Code Eliminationï¼‰

**åŸç†**ï¼šSSAå½¢å¼ä¸­ï¼Œå¦‚æœä¸€ä¸ªå˜é‡çš„å®šä¹‰æ²¡æœ‰è¢«ä»»ä½•Phiå‡½æ•°ä½¿ç”¨ï¼Œåˆ™è¯¥å®šä¹‰æ˜¯æ­»ä»£ç ï¼Œå¯ä»¥åˆ é™¤ã€‚

**ç¤ºä¾‹**ï¼š
```
// æ­»ä»£ç ç¤ºä¾‹
x_1 = Ï†(y_1, z)  // x_1å®šä¹‰äº†y_1å’Œz
y = Ï†(5, 6)       // yè¢«é‡æ–°å®šä¹‰
z = 7               // x_1ä»æœªè¢«ä½¿ç”¨

// ä¼˜åŒ–å
x_1 = Ï†(y, z)        // åˆ é™¤x_1çš„å®šä¹‰ï¼ŒPhiå‡½æ•°çš„å‚æ•°ç®€åŒ–
```

**EP21 å½“å‰å®ç°**ï¼šDeadCodeEliminationOptimizerï¼ˆä½äº`ep21/pass/cfg/DeadCodeEliminationOptimizer.java`ï¼‰ã€‚

### 3. å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ï¼ˆCommon Subexpression Eliminationï¼‰

**åŸç†**ï¼šSSAå½¢å¼ä¸­ï¼Œç›¸åŒçš„å­è¡¨è¾¾å¼è¢«å¤šæ¬¡è®¡ç®—æ—¶ï¼Œå¯ä»¥å¤ç”¨è®¡ç®—ç»“æœã€‚

**ç¤ºä¾‹**ï¼š
```
// ä¼˜åŒ–å‰
x_1 = a + b
x_2 = a + b  // é‡å¤è®¡ç®—

// ä¼˜åŒ–å
temp = a + b
x_1 = temp
x_2 = temp
```

**EP21 å½“å‰å®ç°**ï¼šCommonSubexpressionEliminationOptimizerï¼ˆä½äº`ep21/pass/cfg/CommonSubexpressionEliminationOptimizer.java`ï¼‰ã€‚

### 4. å¤åˆ¶ä¼ æ’­ï¼ˆCopy Propagationï¼‰

**åŸç†**ï¼šå¦‚æœPhiå‡½æ•°çš„ç»“æœç›´æ¥æ¥è‡ªæŸä¸ªæ“ä½œæ•°ï¼ˆå¦‚`y = Ï†(x, x, z)`ä¸­xæ˜¯å”¯ä¸€å‚æ•°ï¼‰ï¼Œåˆ™å¯ä»¥ç®€åŒ–ä¸º`y = x`ï¼Œæ¶ˆé™¤ä¸å¿…è¦çš„å¤åˆ¶ã€‚

**ç¤ºä¾‹**ï¼š
```
// ä¼˜åŒ–å‰
y = Ï†(x, x, x)  // xæ˜¯å”¯ä¸€å‚æ•°

// ä¼˜åŒ–å
y = x  // æ¶ˆé™¤Phiå‡½æ•°ï¼Œç›´æ¥ä½¿ç”¨x
```

**EP21 å½“å‰å®ç°**ï¼šSSAGraphä¸åŒ…å«å¤åˆ¶ä¼ æ’­é€»è¾‘ï¼ˆå¯å•ç‹¬å®ç°ï¼‰ã€‚

### 5. ç±»å‹ä¼ æ’­ï¼ˆType Propagationï¼‰

**åŸç†**ï¼šä½¿ç”¨SSAçš„å½¢å¼ä¿¡æ¯è¿›è¡Œç±»å‹æ¨æ–­å’Œæ£€æŸ¥ï¼Œæ¶ˆé™¤ä¸å¿…è¦çš„ç±»å‹è½¬æ¢ã€‚

**EP21 å½“å‰å®ç°**ï¼šå½“å‰ä»£ç æœªåŒ…å«ç±»å‹ä¼ æ’­ï¼ˆå¯ä½œä¸ºæœªæ¥æ‰©å±•ï¼‰ã€‚

---

## ğŸ”¨ SSA é”€æ¯ï¼ˆSSA Destructionï¼‰

### é”€æ¯å¿…è¦æ€§

**ä¸ºä»€ä¹ˆéœ€è¦é”€æ¯SSA**ï¼š
1. **å¯„å­˜å™¨åˆ†é…é™åˆ¶**ï¼šå¤§å¤šæ•°ç¡¬ä»¶å¯„å­˜å™¨æ•°é‡æœ‰é™ï¼Œæ— æ³•ä¸ºæ‰€æœ‰å˜é‡åˆ†é…å¯„å­˜å™¨
2. **æŒ‡ä»¤é›†çº¦æŸ**ï¼šæŸäº›æŒ‡ä»¤é›†ä¸æ”¯æŒPhiæŒ‡ä»¤ï¼ˆå¦‚RISC-Vï¼‰
3. **ä»£ç ç”Ÿæˆéœ€æ±‚**ï¼šéœ€è¦å°†Phiå‡½æ•°è½¬æ¢ä¸ºå®é™…æœºå™¨æŒ‡ä»¤

### é”€æ¯ç®—æ³•

#### ç®—æ³•1ï¼šé€æ­¥æ›¿æ¢Phiå‡½æ•°

**æ­¥éª¤**ï¼š
1. ä»é€€å‡ºå—å¼€å§‹ï¼Œè‡ªåº•å‘ä¸Šå¤„ç†åŸºæœ¬å—
2. å¯¹äºæ¯ä¸ªPhiå‡½æ•°`y = Ï†(xâ‚, xâ‚‚, ..., xâ‚™)`ï¼š
   - åœ¨Phiå‡½æ•°æ‰€åœ¨åŸºæœ¬å—çš„**æ¯ä¸ªå‰é©±å—**æœ«å°¾æ’å…¥å¤åˆ¶æŒ‡ä»¤`y_i = x_i`
   - åˆ é™¤Phiå‡½æ•°
3. é‡å¤ç›´åˆ°æ‰€æœ‰Phiå‡½æ•°è¢«æ›¿æ¢

**ç¤ºä¾‹**ï¼š
```
// é”€æ¯å‰ï¼ˆSSAå½¢å¼ï¼‰
BB1:
    y = Ï†(x, y)  // Phiå‡½æ•°

BB2: (xçš„ç¬¬ä¸€ä¸ªå‰é©±)
    y = x          // å¤åˆ¶æŒ‡ä»¤

BB3: (xçš„ç¬¬äºŒä¸ªå‰é©±)
    y = x          // å¤åˆ¶æŒ‡ä»¤

// é”€æ¯å
BB1:
    y = x          // å¤åˆ¶æŒ‡ä»¤ï¼ˆå·²å­˜åœ¨ï¼‰
```

#### ç®—æ³•2ï¼šä¸´ç•Œè¾¹ï¼ˆCritical Edgeï¼‰ä¼˜åŒ–

**ä¸´ç•Œè¾¹å®šä¹‰**ï¼šè¿æ¥æ”¯é…æ ‘ä¸­ä¸¤ä¸ªèŠ‚ç‚¹çš„è¾¹ï¼Œä½¿å¾—è¿™äº›èŠ‚ç‚¹æ— æ³•åœ¨Phiå‡½æ•°ä¸­åˆå¹¶ã€‚

**ä¼˜åŒ–ç­–ç•¥**ï¼š
- è¯†åˆ«ä¸´ç•Œè¾¹
- å°†Phiå‡½æ•°åˆ†è£‚ä¸ºå¤šä¸ªPhiå‡½æ•°
- å‡å°‘å¤åˆ¶æŒ‡ä»¤æ•°é‡

**ç¤ºä¾‹**ï¼š
```
// ä¼˜åŒ–å‰
y = Ï†(a, b, c)  // ä¸‰ä¸ªå‰é©±åˆå¹¶

// ä¼˜åŒ–åï¼ˆä½¿ç”¨ä¸´ç•Œè¾¹ï¼‰
y_1 = Ï†(a, b)
y_2 = Ï†(y_1, c)  // åˆ†è£‚Phiå‡½æ•°
```

### å½“å‰å®ç°åˆ†æ

**EP21å½“å‰çŠ¶æ€**ï¼š
- âœ… SSAå›¾ç”Ÿæˆï¼šSSAGraphå®Œæ•´å®ç°Phiå‡½æ•°æ’å…¥å’Œå˜é‡é‡å‘½å
- âœ… SSAéªŒè¯å™¨ï¼šSSAValidatoréªŒè¯SSAæ­£ç¡®æ€§
- â¸ SSAé”€æ¯ï¼šæœªè‡ªåŠ¨å®ç°ï¼Œéœ€è¦åœ¨ä»£ç ç”Ÿæˆé˜¶æ®µæ‰‹åŠ¨å¤„ç†

**åŸå› **ï¼š
- EP21çš„ä»£ç ç”Ÿæˆç›®æ ‡ä¸ºEP18Rè™šæ‹Ÿæœºï¼ˆä¸åŸç”Ÿæ”¯æŒPhiæŒ‡ä»¤ï¼‰
- é”€æ¯é€»è¾‘é›†æˆåœ¨RegisterVMGeneratorä¸­

**å»ºè®®**ï¼š
1. **çŸ­æœŸ**ï¼šåœ¨RegisterVMGeneratorä¸­å®ç°Phiå‡½æ•°åˆ°å¤åˆ¶æŒ‡ä»¤çš„è½¬æ¢
2. **ä¸­æœŸ**ï¼šè®¾è®¡SSAåˆ°LIRçš„è½¬æ¢æ¥å£ï¼Œè‡ªåŠ¨å¤„ç†é”€æ¯
3. **é•¿æœŸ**ï¼šæ”¯æŒæŒ‡ä»¤é›†æ‰©å±•ï¼Œå…è®¸PhiæŒ‡ä»¤ç›´æ¥ç”Ÿæˆ

---

## ğŸ“Š å‚è€ƒèµ„æº

### å­¦æœ¯è®ºæ–‡

| è®ºæ–‡ | ä½œè€… | å¹´ä»½ | é“¾æ¥ | æ ¸å¿ƒè´¡çŒ® |
|------|--------|--------|--------|--------------|
| Efficiently Computing Static Single Assignment Form | Cytron et al. | 1991 | [DOI](https://doi.org/10.1145/109026.1991.139572) | SSAæ„é€ ç®—æ³•ã€Phiå‡½æ•°æ’å…¥ |
| A Simple, Fast Dominance Algorithm | Lengauer, Tarjan | 1979 | [PDF](https://dl.acm.org/doi/abs/10.1145/320197.39.513393) | O(n)æ—¶é—´å¤æ‚åº¦çš„æ”¯é…æ ‘ç®—æ³• |
| Register Allocation via Graph Coloring | Chaitin | 1982 | [PDF](https://dl.acm.org/doi/abs/10.1145/330249.330250) | å›¾ç€è‰²ç®—æ³•ï¼Œå¯„å­˜å™¨åˆ†é…ç†è®º |
| Efficiently Computing SSA Form and Its Use in Optimization | Brigham | 2002 | [PDF](https://dl.acm.org/doi/abs/10.1145/349568.124432) | SSAä¼˜åŒ–æœºä¼šåˆ†æ |
| Modern Compiler Implementation in Java | Muchnick | 2010 | [Book](https://www.amazon.com/Modern-Compiler-Implementation-Java/dp/0672372360) | ç¼–è¯‘å™¨å®ç°å®è·µ |

### æ•™ç¨‹ä¸è¯¾ç¨‹

| èµ„æº | æ¥æº | é“¾æ¥ | å†…å®¹ |
|--------|--------|--------|------|
| CMU 15-410 Introduction to Dataflow Analysis | CMU | [PDF](http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s18/www/lectures/L5-Intro-to-Dataflow-pre-class.pdf) | æ•°æ®æµåˆ†æç†è®ºåŸºç¡€ |
| CMU 15-412 SSA and Optimizations | CMU | [PDF](http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s18/www/lectures/) | SSAæ„é€ å’Œä¼˜åŒ– |
| CMU 15-723 Register Allocation | CMU | [PDF](http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s18/www/lectures/L12-Register-Allocation.pdf) | å¯„å­˜å™¨åˆ†é…ç®—æ³• |
| LLVM Tutorial on SSA | LLVM | [Guide](https://llvm.org/docs/SSAUpdate.html) | LLVM SSAUpdaterä½¿ç”¨æŒ‡å— |

### å¼€æºå®ç°

| é¡¹ç›® | é“¾æ¥ | æ ¸å¿ƒè´¡çŒ® |
|------|--------|--------|--------------|
| LLVM Project | GitHub | [SSAUpdater](https://github.com/llvm/llvm-project/blob/main/llvm/Transforms/Utils/SSAUpdater.h) | LLVM SSAæ›´æ–°å™¨å®ç° |
| GCC Project | GitHub | [GCC SSA](https://github.com/gcc-mirror/gcc/tree/master/gcc/tree-ssa.c) | GCC SSAæ„é€  |
| MLIR | GitHub | [SSA Analysis](https://github.com/llvm/llvm-project/tree/main/mlir/docs/SSA.md) | MLIR SSAåˆ†ææ¡†æ¶ |

---

## ğŸ’» å½“å‰ EP21 å®ç°åˆ†æ

### å·²å®ç°åŠŸèƒ½

| åŠŸèƒ½ | çŠ¶æ€ | ä½ç½® | è¯´æ˜ |
|------|--------|--------|------|
| **æ”¯é…åˆ†æ** | âœ… å·²å®ç° | `DominatorAnalysis.java` | å®Œæ•´çš„æ”¯é…é›†åˆã€æ”¯é…æ ‘å’Œæ”¯é…è¾¹ç•Œè®¡ç®— |
| **SSAå›¾ç”Ÿæˆ** | âœ… å·²å®ç° | `SSAGraph.java` | Phiå‡½æ•°æ’å…¥ã€å˜é‡é‡å‘½åã€DOT/Mermaidè¾“å‡º |
| **SSAéªŒè¯** | âœ… å·²å®ç° | `SSAValidator.java` | éªŒè¯å˜é‡ç‰ˆæœ¬ä¸€è‡´æ€§ã€Phiå‡½æ•°å‚æ•°æ­£ç¡®æ€§ |
| **å¸¸é‡ä¼ æ’­** | â¸ å¾…å®ç° | `ConstantFoldingOptimizer.java` | å¯ä¸SSAé›†æˆ |
| **æ­»ä»£ç æ¶ˆé™¤** | âœ… å·²å®ç° | `DeadCodeEliminationOptimizer.java` | å¯ä¸SSAé›†æˆ |
| **å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤** | âœ… å·²å®ç° | `CommonSubexpressionEliminationOptimizer.java` | å¯ä¸SSAé›†æˆ |

### å®ç°ç‰¹ç‚¹

**ä¼˜åŠ¿**ï¼š
1. **æ¸…æ™°çš„ç®—æ³•å®ç°**ï¼šSSAGraphä¸¥æ ¼æŒ‰ç…§Cytronç®—æ³•å®ç°
2. **å®Œæ•´çš„éªŒè¯æœºåˆ¶**ï¼šSSAValidatorç¡®ä¿SSAæ­£ç¡®æ€§
3. **ä¸°å¯Œçš„è¾“å‡ºæ ¼å¼**ï¼šæ”¯æŒDOTå’ŒMermaidå›¾å¯è§†åŒ–
4. **æ¨¡å—åŒ–è®¾è®¡**ï¼šæ”¯é…åˆ†æã€SSAæ„é€ ã€éªŒè¯åˆ†ç¦»

**é™åˆ¶**ï¼š
1. **æœªå®ç°SSAé”€æ¯**ï¼šä¾èµ–ä»£ç ç”Ÿæˆå™¨å¤„ç†
2. **å¸¸é‡ä¼ æ’­æœªé›†æˆ**ï¼šéœ€å•ç‹¬å®ç°æˆ–å¢å¼ºConstantFoldingOptimizer

---

## ğŸ¯ ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šåŸºç¡€SSAè½¬æ¢

**åŸå§‹ä»£ç **ï¼š
```c
int example(int a) {
    int x = 1;
    int y = a + x;
    int z = y * 2;
    return z;
}
```

**SSAè½¬æ¢å**ï¼ˆç®€åŒ–è¡¨ç¤ºï¼‰ï¼š
```
a_1 = 1;
x = a + a_1;
y = Ï†(x, a_1);
z = Ï†(y, 2) * 2;  // Ï†(y, 2)å®é™…ä¸Šå¯ç®€åŒ–ä¸ºy * 2
```

**EP21æ„å»ºç»“æœ**ï¼š
```java
// SSAGraph ä¼šç”Ÿæˆç±»ä¼¼ä»¥ä¸‹SSAå›¾
// åŸºæœ¬å—ç»“æ„æ˜ç¡®ï¼ŒPhiå‡½æ•°åœ¨æ±‡èšç‚¹
```

### ç¤ºä¾‹2ï¼šå¾ªç¯ä¸­çš„SSA

**åŸå§‹ä»£ç **ï¼š
```c
int sum(int n) {
    int result = 0;
    for (int i = 0; i < n; i++) {
        result = result + i;
    }
    return result;
}
```

**SSAè½¬æ¢å**ï¼š
```
result_0 = 0;
result_1 = Ï†(result_0, 1);
result_2 = Ï†(result_1, 2);
...
result_n = Ï†(result_{n-1}, n);
return = Ï†(result_n, n);
```

---

## ğŸš€ æœ€ä½³å®è·µ

### SSA æ„é€ å»ºè®®

1. **ä½¿ç”¨å·¥ä½œåˆ—è¡¨ç®—æ³•**ï¼šåªå¤„ç†å—å½±å“çš„èŠ‚ç‚¹ï¼Œæé«˜æ•ˆç‡
2. **å˜é‡é‡å‘½åç­–ç•¥**ï¼šåŸºäºæ”¯é…æ ‘çš„æ·±åº¦ä¼˜å…ˆéå†
3. **Phiå‡½æ•°ä¼˜åŒ–**ï¼šåœ¨æ’å…¥åç«‹å³è¿›è¡Œå¸¸é‡ä¼ æ’­ç­‰ä¼˜åŒ–
4. **éªŒè¯é©±åŠ¨å¼€å‘**ï¼šå…ˆç¼–å†™SSAéªŒè¯å™¨æµ‹è¯•ï¼Œå†å®ç°SSAæ„é€ 

### å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

| é—®é¢˜ | åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|--------|--------|----------|
| Phiå‡½æ•°è¿‡å¤š | åœ¨ä¸å¿…è¦çš„æ±‡èšç‚¹æ’å…¥ | Pruned SSAç­–ç•¥ï¼Œåªåœ¨å¿…è¦å¤„æ’å…¥ |
| å˜é‡åè¿‡é•¿ | å¤šæ¬¡é‡å‘½åå¯¼è‡´`x_1_2_3_4` | ç®€åŒ–é‡å‘½åé€»è¾‘ï¼Œä½¿ç”¨æ•´æ•°ç‰ˆæœ¬ |
| æ”¯é…è®¡ç®—ä¸æ”¶æ•› | CFGåŒ…å«ä¸å¯è¾¾èŠ‚ç‚¹æˆ–è‡ªç¯ | æ·»åŠ æœ€å¤§è¿­ä»£æ¬¡æ•°é™åˆ¶ï¼Œæå‰ç»ˆæ­¢ |
| ç±»å‹å®‰å…¨ | å˜é‡é‡å‘½ååç±»å‹ä¸¢å¤± | åœ¨é‡å‘½åè¿‡ç¨‹ä¸­ç»´æŠ¤ç±»å‹ä¿¡æ¯ |

### è°ƒè¯•æŠ€å·§

1. **DOTå›¾å¯è§†åŒ–**ï¼šä½¿ç”¨SSAGraph.toDOT()ç”Ÿæˆæ§åˆ¶æµå›¾
2. **éªŒè¯æŠ¥å‘Š**ï¼šä½¿ç”¨SSAValidatorç”Ÿæˆè¯¦ç»†é”™è¯¯åˆ—è¡¨
3. **æ—¥å¿—è¾“å‡º**ï¼šåœ¨å…³é”®ç®—æ³•æ­¥éª¤æ·»åŠ logger.debug()

---

## ğŸ“ åç»­ä¼˜åŒ–æ–¹å‘

### ä¸å…¶ä»–ä¼˜åŒ–Passçš„é›†æˆ

**ä¼˜å…ˆçº§**ï¼š
1. **é«˜ä¼˜å…ˆçº§**ï¼šå¸¸é‡ä¼ æ’­ã€æ­»ä»£ç æ¶ˆé™¤ä¸SSAçš„é›†æˆ
2. **ä¸­ä¼˜å…ˆçº§**ï¼šå…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ä¸SSAçš„é›†æˆ
3. **ä½ä¼˜å…ˆçº§**ï¼šå¤åˆ¶ä¼ æ’­ã€ç±»å‹ä¼ æ’­

### æœªæ¥æ‰©å±•

1. **å†…å­˜SSAï¼ˆMemory-SSAï¼‰**ï¼šæ”¯æŒç¨€ç–å­˜å‚¨çš„ä¼˜åŒ–
2. **æ¡ä»¶SSAï¼ˆCSSAï¼‰**ï¼šä½¿ç”¨æ¡ä»¶Phiå‡½æ•°ä¼˜åŒ–ä»£ç å¤§å°
3. **æ‰©å±•SSAï¼ˆExtended SSAï¼‰**ï¼šæ”¯æŒæ•°ç»„ã€ç»“æ„ä½“ç­‰é«˜çº§ç‰¹æ€§

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0-è‰ç¨¿
**åˆ›å»ºæ—¥æœŸ**: 2026-01-14
**é€‚ç”¨èŒƒå›´**: EP21æ¨¡å—SSAå½¢å¼æ„é€ ä¸ä¼˜åŒ–
**ç»´æŠ¤è€…**: EP21æ¨¡å—ç»´æŠ¤å›¢é˜Ÿ
**å®¡æ ¸è¦æ±‚**: éœ€è¦è¡¥å……ç®—æ³•ç»†èŠ‚ã€ä»£ç ç¤ºä¾‹å’Œæœ€ä½³å®è·µ
