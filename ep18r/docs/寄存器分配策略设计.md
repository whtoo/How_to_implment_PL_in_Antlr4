# 寄存器分配策略设计

## 概述
本文档详细描述 ep18r 寄存器虚拟机的寄存器分配策略，包括简单固定分配算法、调用约定、寄存器溢出处理机制以及未来优化方向。寄存器分配是编译器后端的关键技术，直接影响生成代码的性能。

## 设计目标
1. **简单性**：实现简单，易于理解和调试
2. **正确性**：确保语义正确，不引入错误
3. **可预测性**：分配结果确定，便于测试和验证
4. **可扩展性**：为未来优化预留接口
5. **寄存器效率**：最大化寄存器利用率，减少内存访问

## 寄存器资源

### 寄存器分类
| 类别 | 寄存器 | 数量 | 用途 | 保存责任 |
|------|--------|------|------|----------|
| 零寄存器 | r0 | 1 | 恒为零 | 系统 |
| 通用寄存器 | r1-r12 | 12 | 通用计算 | 混合 |
| 特殊寄存器 | r13-r15 | 3 | SP, FP, LR | 系统 |
| 参数寄存器 | r1-r4 | 4 | 参数传递 | 调用者 |
| 返回值寄存器 | r1 | 1 | 返回值 | 被调用者 |
| 调用者保存 | r1-r8 | 8 | 临时值 | 调用者 |
| 被调用者保存 | r9-r12 | 4 | 长期变量 | 被调用者 |

### 寄存器使用约束
1. **r0**：只读，硬连线到0，用于清零和比较
2. **r13 (SP)**：栈指针，只能通过专用指令修改
3. **r14 (FP)**：帧指针，函数调用时保存/恢复
4. **r15 (LR)**：链接寄存器，存储返回地址

## 简单固定分配算法

### 算法概述
简单固定分配是一种贪心算法，按变量声明顺序线性分配寄存器，当寄存器不足时报告错误。这是寄存器分配的最简形式，适合教育目的和初始实现。

### 分配规则
1. **局部变量分配**：按声明顺序分配 r1, r2, r3, ...
2. **临时值分配**：从下一个可用寄存器开始分配
3. **参数接收**：前4个参数存入 r1-r4，超出部分通过栈传递
4. **返回值分配**：返回值始终使用 r1

### 算法流程
```java
public class SimpleRegisterAllocator {
    private int nextReg = 1;  // 下一个可用寄存器 (r1开始)
    private Map<String, Integer> varToReg = new HashMap<>();
    private Map<String, Integer> varToStackOffset = new HashMap<>();
    private int stackOffset = 0;

    // 为局部变量分配寄存器
    public int allocateLocal(String varName) {
        if (nextReg <= 12) {  // r1-r12 可用
            int reg = nextReg++;
            varToReg.put(varName, reg);
            return reg;
        } else {
            // 寄存器不足，溢出到栈
            stackOffset -= 4;  // 每个变量4字节
            varToStackOffset.put(varName, stackOffset);
            return -1;  // 表示栈分配
        }
    }

    // 为临时表达式分配寄存器
    public int allocateTemp() {
        if (nextReg <= 12) {
            int reg = nextReg++;
            return reg;
        } else {
            throw new RuntimeException("寄存器不足，无法分配临时寄存器");
        }
    }

    // 释放临时寄存器（重置分配指针）
    public void resetTempAllocation() {
        nextReg = 1 + varToReg.size();  // 保留已分配的局部变量寄存器
    }
}
```

### 分配示例
```c
// Cymbol 代码示例
int main() {
    int a = 10;     // 分配 r1
    int b = 20;     // 分配 r2
    int c = a + b;  // 临时分配 r3
    return c;
}
```

对应寄存器分配：
- `a` → r1
- `b` → r2
- `c` → r3 (临时，可重用)
- 表达式 `a + b` 使用 r1 和 r2，结果存入 r3

## 调用约定

### 参数传递规则
1. **前4个参数**：通过寄存器 r1-r4 传递
2. **剩余参数**：通过栈传递，按从右到左顺序压栈
3. **结构体参数**：通过栈传递（传递指针或复制）

### 返回值规则
1. **基本类型**：通过寄存器 r1 返回
2. **结构体**：通过栈返回（调用者预留空间，传递指针）

### 寄存器保存责任
#### 调用者保存寄存器 (Caller-saved)：r1-r8
- 调用者负责在调用前保存这些寄存器的值（如果需要）
- 被调用者可以自由使用这些寄存器，无需保存
- 适用于存储临时值和中间结果

#### 被调用者保存寄存器 (Callee-saved)：r9-r12
- 被调用者负责在函数开头保存这些寄存器的值（如果使用）
- 在函数返回前必须恢复原始值
- 适用于存储跨函数调用的长期变量

### 函数调用序列
#### 调用者代码序列
```assembly
# 假设有3个参数：arg1, arg2, arg3
li r1, arg1        # 第一个参数 → r1
li r2, arg2        # 第二个参数 → r2
li r3, arg3        # 第三个参数 → r3
# 如果参数超过4个，多余参数压栈
# push arg5, arg4...
call function      # 调用函数
# 返回值在 r1 中
```

#### 被调用者序言 (Prologue)
```assembly
function:
    push fp         # 保存旧帧指针
    mov fp, sp      # 建立新帧指针
    # 保存被调用者保存寄存器（如果使用）
    push r9
    push r10
    push r11
    push r12
    # 为局部变量分配栈空间
    sub sp, sp, {local_size}
```

#### 被调用者尾声 (Epilogue)
```assembly
    # 返回值存入 r1
    mov r1, {return_value}
    # 释放局部变量空间
    mov sp, fp
    # 恢复被调用者保存寄存器
    pop r12
    pop r11
    pop r10
    pop r9
    # 恢复旧帧指针
    pop fp
    ret             # 返回调用者
```

## 寄存器溢出处理

### 溢出触发条件
1. **寄存器不足**：局部变量数量超过可用通用寄存器数量（12个）
2. **大结构体**：结构体变量无法放入单个寄存器
3. **复杂表达式**：表达式求值需要大量临时寄存器

### 溢出策略
#### 策略1：栈溢出 (Stack Spilling)
- 将寄存器值保存到栈内存
- 需要时从栈内存重新加载
- 适用于不频繁访问的变量

#### 策略2：内存变量 (Memory Variables)
- 直接将变量分配在栈上，不占用寄存器
- 通过 FP 相对寻址访问
- 适用于大数组或结构体

### 溢出实现
```java
public class SpillManager {
    // 将寄存器溢出到栈
    public void spillRegister(int reg, int stackOffset) {
        // 生成存储指令: sw reg, fp, offset
        emitStore(reg, RegisterFile.FP, stackOffset);
    }

    // 从栈加载到寄存器
    public void reloadRegister(int reg, int stackOffset) {
        // 生成加载指令: lw reg, fp, offset
        emitLoad(reg, RegisterFile.FP, stackOffset);
    }

    // 分配栈槽位
    public int allocateStackSlot() {
        currentOffset -= 4;  // 每个槽位4字节
        return currentOffset;
    }
}
```

### 溢出代价模型
| 操作 | 指令数 | 周期估计 | 说明 |
|------|--------|----------|------|
| 寄存器-寄存器 | 1 | 1 | 最佳情况 |
| 寄存器-栈存储 | 2 | 3 | sw 指令 + 地址计算 |
| 栈-寄存器加载 | 2 | 3 | lw 指令 + 地址计算 |
| 栈-栈移动 | 4 | 6 | 加载+存储组合 |

## 未来优化方向

### 线性扫描分配 (Linear Scan Allocation)
#### 算法概述
1. **计算生存区间**：确定每个变量的定义和使用范围
2. **区间排序**：按起始点排序所有生存区间
3. **分配寄存器**：扫描时间线，分配和释放寄存器
4. **处理溢出**：当寄存器不足时，溢出生存区间最长的变量

#### 优势
- 时间复杂度 O(n log n)，适合JIT编译
- 分配质量接近图着色，但更快
- 适合具有明确生存区间的SSA形式

### 图着色分配 (Graph Coloring Allocation)
#### 算法概述
1. **构建冲突图**：变量为节点，同时生存的变量间有边
2. **简化图**：移除低度节点，推入栈
3. **选择颜色**：从栈中弹出节点，分配可用颜色（寄存器）
4. **溢出处理**：当无法着色时，选择溢出代价最小的变量

#### 优势
- 分配质量最优
- 适用于优化编译器
- 能处理复杂干扰模式

### 区域分配 (Regional Allocation)
- **基本块内分配**：单个基本块内优化分配
- **循环优先分配**：为循环内变量分配专用寄存器
- **层次化分配**：函数级、循环级、块级多级分配

## 实现指导

### 分配器接口设计
```java
public interface RegisterAllocator {
    // 为函数分配寄存器
    AllocationResult allocate(Function function);

    // 获取变量位置（寄存器或栈偏移）
    Location getLocation(String variable);

    // 获取临时寄存器
    int allocateTemp();

    // 释放临时寄存器
    void freeTemp(int reg);
}

public class AllocationResult {
    Map<String, Location> variableLocations;  // 变量→位置映射
    List<Instruction> prologue;               // 函数序言指令
    List<Instruction> epilogue;               // 函数尾声指令
    int stackFrameSize;                       // 栈帧大小
}
```

### 集成到编译器流水线
```
前端 → 中间表示 → 寄存器分配 → 代码生成 → 目标代码
                (IR)         (本模块)      (机器码)
```

### 调试支持
- 分配结果可视化（变量→寄存器映射图）
- 冲突图可视化
- 分配统计信息（寄存器使用率、溢出次数）

## 测试策略

### 单元测试
1. **简单分配测试**：变量数量小于寄存器数量
2. **溢出测试**：变量数量超过寄存器数量
3. **调用约定测试**：参数传递和返回值
4. **临时寄存器测试**：表达式求值中的临时分配

### 集成测试
1. **完整函数测试**：包含多个基本块的函数
2. **递归测试**：递归函数的寄存器分配
3. **复杂表达式测试**：嵌套表达式的临时寄存器管理

### 性能测试
1. **分配速度测试**：测量分配算法执行时间
2. **生成代码质量测试**：对比不同分配策略的代码大小和执行速度
3. **溢出代价测试**：测量溢出对性能的影响

## 附录

### A. 寄存器分配术语表
- **生存区间 (Live Range)**：变量从定义到最后一次使用的时间范围
- **冲突 (Interference)**：两个变量的生存区间重叠，不能共享寄存器
- **溢出 (Spilling)**：将寄存器内容保存到内存，以释放寄存器
- **着色 (Coloring)**：为冲突图节点分配颜色（寄存器）的过程
- **度数 (Degree)**：冲突图中节点的邻居数量

### B. 相关研究工作
- **线性扫描分配**：Poletto & Sarkar, 1999
- **图着色分配**：Chaitin et al., 1981
- **SSA形式分配**：Hack et al., 2006

### C. 工具和库
- **Jasmin**：Java汇编器，可用于测试生成代码
- **ASM**：Java字节码操作框架，可用于实现分配器
- **Graphviz**：可视化冲突图