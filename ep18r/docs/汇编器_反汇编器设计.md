# 汇编器/反汇编器设计

## 概述
本文档详细描述 ep18r 寄存器虚拟机的汇编器和反汇编器设计。汇编器将人类可读的汇编代码转换为寄存器字节码，反汇编器将字节码转换回汇编代码。这两个工具是虚拟机开发和调试的关键组件。

## 设计目标
1. **正确性**：准确转换汇编代码和字节码
2. **完整性**：支持所有寄存器指令和汇编语法
3. **易用性**：提供清晰的错误信息和诊断
4. **可扩展性**：支持新指令和语法扩展
5. **性能**：快速处理大型汇编程序

## 实现状态

### 当前实现情况
ep18r 模块已实现基本的汇编器和反汇编器功能，但设计文档中的某些组件尚未完全实现：

#### 已实现组件
1. **RegisterByteCodeAssembler** - 寄存器虚拟机汇编器主类
   - 位置：`ep18r/src/main/java/org/teachfx/antlr4/ep18r/stackvm/RegisterByteCodeAssembler.java`
   - 功能：将汇编代码转换为寄存器字节码
   - 支持：42条寄存器指令、标签、函数声明、全局变量
   - 集成：词法分析、语法分析、语义检查、代码生成功能集成在一个类中

2. **DisAssembler** - 反汇编器类（当前使用栈式指令集）
   - 位置：`ep18r/src/main/java/org/teachfx/antlr4/ep18r/stackvm/DisAssembler.java`
   - 问题：当前使用 `BytecodeDefinition`（栈式虚拟机指令集），需要适配 `RegisterBytecodeDefinition`

3. **VMAssembler.g4** - ANTLR4 语法文件
   - 位置：`ep18r/src/main/antlr4/VMAssembler.g4`
   - 状态：完整支持寄存器汇编语法

4. **RegisterBytecodeDefinition** - 寄存器指令集定义
   - 位置：`ep18r/src/main/java/org/teachfx/antlr4/ep18r/stackvm/RegisterBytecodeDefinition.java`
   - 状态：完整定义42条寄存器指令

#### 待实现/待改进组件
1. **专用寄存器反汇编器** - 需要创建 `RegisterDisAssembler` 类
2. **分离的语义分析器** - 当前语义检查集成在 `RegisterByteCodeAssembler` 中
3. **专用代码生成器** - 当前代码生成集成在 `RegisterByteCodeAssembler` 中
4. **完整错误处理系统** - 需要增强错误报告和恢复机制

#### 架构调整说明
设计文档中描述的分离架构（独立 SemanticAnalyzer、CodeGenerator 等）是目标架构，当前实现采用集成架构以简化初始实现。未来可逐步重构为分离架构。

## 整体架构

### 组件关系（当前实现）
```
汇编代码 (.asm文件)
    ↓
汇编器 (RegisterByteCodeAssembler) - 集成式实现
    ├── 词法分析 (ANTLR4 VMAssemblerLexer)
    ├── 语法分析 (ANTLR4 VMAssemblerParser)
    ├── 语义检查（集成在汇编器内）
    ├── 代码生成（集成在汇编器内）
    └── 错误报告（基础错误检查）
    ↓
寄存器字节码 (.vm文件)
    ↓
反汇编器 (DisAssembler) - 当前使用栈式指令集
    ├── 指令解码（基于BytecodeDefinition）
    ├── 操作数格式化
    └── 输出生成
    ↓
反汇编代码 (.dis文件)
```

### 目标架构（未来扩展）
```
汇编代码 (.asm文件)
    ↓
汇编器 (RegisterByteCodeAssembler)
    ├── 词法分析 (VMAssemblerLexer)
    ├── 语法分析 (VMAssemblerParser)
    ├── 语义分析 (SemanticAnalyzer) - 独立组件
    ├── 代码生成 (CodeGenerator) - 独立组件
    └── 错误处理 (ErrorReporter) - 增强系统
    ↓
寄存器字节码 (.vm文件)
    ↓
反汇编器 (RegisterDisAssembler) - 专用寄存器反汇编器
    ├── 指令解码 (InstructionDecoder) - 基于RegisterBytecodeDefinition
    ├── 符号解析 (SymbolResolver)
    ├── 格式生成 (Formatter)
    └── 输出生成 (OutputWriter)
    ↓
反汇编代码 (.dis文件)
```

### 核心类职责（当前实现）
- **RegisterByteCodeAssembler**：汇编器主类，集成词法分析、语法分析、语义检查、代码生成功能
- **VMAssembler.g4**：ANTLR4 语法文件，定义寄存器汇编语言语法
- **DisAssembler**：反汇编器类，将字节码转换为文本（当前使用栈式指令集）
- **RegisterBytecodeDefinition**：寄存器指令集定义，包含42条寄存器指令的编码信息
- **SymbolTable**（集成）：符号管理功能集成在RegisterByteCodeAssembler中，管理标签、函数和全局变量

### 目标架构类职责（未来扩展）
- **SemanticAnalyzer**：独立的语义分析器，检查语义正确性
- **CodeGenerator**：独立的代码生成器，生成字节码
- **RegisterDisAssembler**：专用的寄存器反汇编器，基于RegisterBytecodeDefinition
- **InstructionDecoder**：指令解码器，解析寄存器字节码指令
- **ErrorReporter**：增强的错误报告和恢复系统

## 汇编语言语法

### 语法概述
ep18r 汇编语言是为寄存器虚拟机设计的独立汇编语言，不依赖栈式虚拟机架构。语法使用 ANTLR4 定义，支持寄存器指令、标签、函数声明和全局变量，专为寄存器架构优化。

### 语法文件结构
```antlr4
grammar VMAssembler;

program
    :   (globalVariable | globals)?
        (functionDeclaration | instr | label | NEWLINE)+
    ;

// 全局变量声明
globalVariable : '.global' type=ID name=ID NEWLINE;

// 全局数据空间声明
globals : NEWLINE* '.globals' intVal=INT NEWLINE;

// 函数声明
functionDeclaration
    :   '.def' name=ID ':' 'args' '=' a=INT ',' 'locals' '=' lo=INT NEWLINE
    ;

// 指令
instr
    :   op=ID NEWLINE
    |   op=ID a=temp NEWLINE
    |   op=ID a=temp ',' b=temp NEWLINE
    |   op=ID a=temp ',' b=temp ',' c=temp NEWLINE
    ;

// 操作数
temp
    :   ID      // 标签，如 "loop"
    |   REG     // 寄存器，如 "r1"
    |   FUNC    // 函数标签，如 "f()"
    |   INT     // 整数立即数，如 "10"
    |   BOOL    // 布尔值，如 "true"
    |   CHAR    // 字符，如 "'a'"
    |   STRING  // 字符串，如 '"hello"'
    |   FLOAT   // 浮点数，如 "3.14"
    ;

// 标签定义
label : name=ID ':' NEWLINE;

// 词法规则
REG : 'r' [0-9]+ ;
FUNC : ID '()' ;
INT : [0-9]+ ;
BOOL : 'true' | 'false' ;
CHAR : '\'' . '\'' ;
STRING : '"' .*? '"' ;
FLOAT : [0-9]+ '.' [0-9]+ ;
ID : [a-zA-Z_][a-zA-Z0-9_]* ;
NEWLINE : '\r'? '\n' ;
WS : [ \t]+ -> skip ;
COMMENT : '#' ~[\r\n]* -> skip ;
```

### 寄存器语法扩展
#### 寄存器操作数
- **寄存器引用**：`r0` - `r15`
- **寄存器间接**：`[r1]`（未来扩展）
- **寄存器偏移**：`[r1 + 8]`（未来扩展）

#### 寄存器指令格式
1. **无操作数指令**：`halt`, `ret`
2. **单操作数指令**：`print r1`, `null r2`
3. **双操作数指令**：`mov r1, r2`, `neg r3, r4`
4. **三操作数指令**：`add r1, r2, r3`, `lw r1, r14, 8`

### 汇编程序示例
```assembly
# 简单寄存器汇编程序示例
.globals 1024

.def main: args=0, locals=2
    li r1, 10          # 加载立即数 10 到 r1
    li r2, 20          # 加载立即数 20 到 r2
    add r3, r1, r2     # r3 = r1 + r2
    print r3           # 打印 r3 的值
    halt               # 停止执行

.def add_func: args=2, locals=0
    add r1, r1, r2     # r1 = r1 + r2 (参数在 r1, r2)
    ret                # 返回，结果在 r1
```

## 汇编器实现

### 汇编流程
#### 阶段1：词法分析和语法分析
- **输入**：汇编源代码
- **处理**：使用 ANTLR4 生成的词法分析器和语法分析器
- **输出**：解析树 (Parse Tree)

#### 阶段2：语义分析
- **符号解析**：解析标签、函数名、变量名
- **类型检查**：检查操作数类型匹配
- **范围检查**：检查寄存器编号、立即数范围
- **上下文检查**：检查函数声明、指令上下文

#### 阶段3：代码生成
- **指令编码**：将汇编指令转换为二进制编码
- **地址解析**：解析标签地址，生成跳转目标
- **常量处理**：处理浮点、字符串常量，构建常量池
- **符号表生成**：生成调试符号信息

#### 阶段4：输出生成
- **字节码生成**：生成最终的字节码数组
- **文件写入**：写入 `.vm` 文件
- **调试信息**：生成符号表文件（可选）

### 核心类设计
#### RegisterByteCodeAssembler（当前实现 - 简化版）

**实际实现**：`RegisterByteCodeAssembler` 继承自 `VMAssemblerBaseListener`，使用 ANTLR4 监听器模式遍历语法树生成代码。以下展示简化后的核心接口：

```java
public class RegisterByteCodeAssembler extends VMAssemblerBaseListener {
    protected byte[] code;          // 生成的字节码缓冲区
    protected int ip = 0;           // 当前指令指针
    protected Map<String, Integer> instructionOpcodeMapping; // 指令-操作码映射

    // 构造函数：初始化指令映射
    public RegisterByteCodeAssembler(RegisterBytecodeDefinition.Instruction[] instructions) {
        instructionOpcodeMapping = new HashMap<>();
        for (int i = 1; i < instructions.length; ++i) {
            if (instructions[i] != null) {
                String name = instructions[i].name.toLowerCase();
                instructionOpcodeMapping.put(name, i);
            }
        }
    }

    // 生成指令的核心方法（简化示例）
    protected void gen(Token instrToken) {
        String instructionName = instrToken.getText().toLowerCase();
        Integer opcode = instructionOpcodeMapping.get(instructionName);
        if (opcode != null) {
            ensureCapacity(ip + 1);
            code[ip++] = (byte)(opcode & 0xff);
        }
    }

    // 生成带操作数的指令
    protected void gen(Token instrToken, Token operandToken) {
        gen(instrToken);
        genOperand(operandToken);
    }

    // 获取生成的字节码
    public byte[] getMachineCode() {
        byte[] result = new byte[ip];
        System.arraycopy(code, 0, result, 0, ip);
        return result;
    }

    // 其他方法：genOperand(), ensureCapacity(), 符号管理方法等
}
```

#### 目标架构接口（未来扩展）

以下展示目标架构中的高层接口设计，当前实现的功能已集成在上述类中：

```java
public class RegisterByteCodeAssembler {
    // 汇编入口方法（目标接口）
    public byte[] assemble(String sourceCode) {
        // 1. 解析源代码
        ParseTree tree = parse(sourceCode);

        // 2. 语义分析（未来可分离为独立组件）
        SemanticAnalyzer analyzer = new SemanticAnalyzer();
        AnalysisResult analysis = analyzer.analyze(tree);

        // 3. 代码生成（未来可分离为独立组件）
        CodeGenerator generator = new CodeGenerator(analysis);
        BytecodeBuffer buffer = generator.generate();

        // 4. 返回字节码
        return buffer.toByteArray();
    }

    // 从文件汇编
    public byte[] assembleFile(File file) {
        String source = readFile(file);
        return assemble(source);
    }
}
```

#### SemanticAnalyzer（目标架构组件）

**说明**：当前实现中，语义检查功能集成在 `RegisterByteCodeAssembler` 中。以下展示目标架构中独立语义分析器的设计：
```java
public class SemanticAnalyzer {
    // 语义分析主方法
    public AnalysisResult analyze(ParseTree tree) {
        AnalysisResult result = new AnalysisResult();

        // 第一次遍历：收集符号
        collectSymbols(tree, result);

        // 第二次遍历：检查语义
        checkSemantics(tree, result);

        // 第三次遍历：计算地址
        resolveAddresses(tree, result);

        return result;
    }

    // 收集符号（标签、函数、变量）
    private void collectSymbols(ParseTree tree, AnalysisResult result) {
        // 遍历解析树，收集所有符号
    }

    // 检查语义（类型、范围、上下文）
    private void checkSemantics(ParseTree tree, AnalysisResult result) {
        // 检查指令操作数类型
        // 检查寄存器编号范围
        // 检查立即数范围
        // 检查函数声明一致性
    }

    // 解析地址（标签地址计算）
    private void resolveAddresses(ParseTree tree, AnalysisResult result) {
        // 计算标签的绝对地址
        // 解析跳转目标
        // 计算函数入口地址
    }
}
```

#### CodeGenerator
```java
public class CodeGenerator {
    // 代码生成主方法
    public BytecodeBuffer generate() {
        BytecodeBuffer buffer = new BytecodeBuffer();

        // 生成头部信息
        generateHeader(buffer);

        // 生成常量池
        generateConstantPool(buffer);

        // 生成代码段
        generateCodeSection(buffer);

        // 生成符号表（调试信息）
        generateSymbolTable(buffer);

        return buffer;
    }

    // 生成单个指令
    private void generateInstruction(InstructionInfo instr,
                                     BytecodeBuffer buffer) {
        // 根据指令类型生成编码
        switch (instr.getFormat()) {
            case FORMAT_R:
                generateRType(instr, buffer);
                break;
            case FORMAT_I:
                generateIType(instr, buffer);
                break;
            case FORMAT_J:
                generateJType(instr, buffer);
                break;
        }
    }

    // 生成 R 类型指令
    private void generateRType(InstructionInfo instr,
                               BytecodeBuffer buffer) {
        int opcode = instr.getOpcode();
        int rd = instr.getOperand(0).getRegisterIndex();
        int rs1 = instr.getOperand(1).getRegisterIndex();
        int rs2 = instr.getOperand(2).getRegisterIndex();

        int encoding = (opcode << 26) |
                       (rd << 21) |
                       (rs1 << 16) |
                       (rs2 << 11);
        buffer.writeInt(encoding);
    }

    // 生成 I 类型指令
    private void generateIType(InstructionInfo instr,
                               BytecodeBuffer buffer) {
        int opcode = instr.getOpcode();
        int rd = instr.getOperand(0).getRegisterIndex();
        int rs1 = instr.getOperand(1).getRegisterIndex();
        int immediate = instr.getOperand(2).getImmediateValue();

        // 立即数符号扩展和截断
        int imm16 = immediate & 0xFFFF;

        int encoding = (opcode << 26) |
                       (rd << 21) |
                       (rs1 << 16) |
                       imm16;
        buffer.writeInt(encoding);
    }
}
```

### 错误处理

#### 错误类型
| 错误码 | 错误类型 | 示例 | 恢复策略 |
|--------|----------|------|----------|
| 1001 | 语法错误 | `add r1, r2`（缺少操作数） | 报告错误，继续解析 |
| 1002 | 语义错误 | `add r1, r2, r16`（寄存器越界） | 报告错误，跳过指令 |
| 1003 | 符号错误 | `j undefined_label`（未定义标签） | 报告错误，标记为待修复 |
| 1004 | 类型错误 | `add r1, r2, "string"`（类型不匹配） | 报告错误，跳过指令 |
| 1005 | 范围错误 | `li r1, 1000000`（立即数超范围） | 报告错误，使用截断值 |

#### 错误报告格式
```java
public class AssemblerError {
    private int line;           // 错误行号
    private int column;         // 错误列号
    private String message;     // 错误消息
    private ErrorSeverity severity; // 错误严重程度
    private String context;     // 错误上下文代码

    // 格式化错误消息
    public String format() {
        return String.format("错误 %d:%d: %s\n  %s",
            line, column, message, context);
    }
}
```

## 反汇编器实现

### 反汇编流程
#### 阶段1：字节码解析
- **读取头部**：解析字节码文件头部信息
- **解析常量池**：读取常量池数据
- **解析代码段**：读取指令字节码

#### 阶段2：指令解码
- **指令识别**：根据操作码识别指令
- **操作数解码**：解码寄存器编号和立即数
- **符号解析**：将地址解析为符号名称（如果可用）

#### 阶段3：文本生成
- **指令格式化**：将解码结果格式化为汇编文本
- **标签生成**：为跳转目标生成标签
- **注释添加**：添加地址和编码注释

#### 阶段4：输出生成
- **文件写入**：写入 `.dis` 文件
- **格式美化**：优化缩进和布局
- **交叉引用**：生成符号交叉引用表

### 核心类设计
#### DisAssembler（当前实现）

**说明**：当前反汇编器使用栈式虚拟机指令集 (`BytecodeDefinition`)，需要适配寄存器指令集。以下是当前实现的简化展示：

```java
public class DisAssembler {
    protected Object[] constPool;  // 常量池
    protected byte[] code;         // 字节码
    protected int codeSize;        // 代码大小
    protected BytecodeDefinition def; // 指令定义（栈式）

    public DisAssembler(byte[] code, int codeSize, Object[] constPool) {
        this.code = code;
        this.codeSize = codeSize;
        this.constPool = constPool;
    }

    // 反汇编所有指令
    public void disassemble() {
        System.out.println("Disassembly:");
        int i = 0;
        while (i < codeSize) {
            i = disassembleInstruction(i);
            System.out.println();
        }
        System.out.println();
    }

    // 反汇编单个指令
    public int disassembleInstruction(int ip) {
        int opcode = code[ip];
        BytecodeDefinition.Instruction I = BytecodeDefinition.instructions[opcode];
        String instrName = I.name;
        System.out.printf("%04d:\t%-11s", ip, instrName);
        ip++;

        if (I.n == 0) {
            System.out.print("  ");
            return ip;
        }

        // 处理操作数...
        return ip;
    }
}
```

#### RegisterDisAssembler（目标架构组件）

**说明**：目标架构中的专用寄存器反汇编器，基于 `RegisterBytecodeDefinition`。以下是设计示例：

```java
public class RegisterDisAssembler {
    // 反汇编入口方法
    public String disassemble(byte[] bytecode) {
        StringBuilder output = new StringBuilder();

        // 1. 解析字节码结构
        BytecodeParser parser = new BytecodeParser(bytecode);
        BytecodeStructure structure = parser.parse();

        // 2. 反汇编指令
        InstructionDecoder decoder = new InstructionDecoder();
        for (Instruction instruction : structure.getInstructions()) {
            String asm = decoder.decode(instruction);
            output.append(asm).append("\n");
        }

        // 3. 添加头部和常量池信息
        addHeaderInfo(output, structure);
        addConstantPool(output, structure);

        return output.toString();
    }

    // 从文件反汇编
    public String disassembleFile(File file) {
        byte[] bytecode = readFile(file);
        return disassemble(bytecode);
    }
}
```

#### InstructionDecoder（目标架构组件）

**说明**：当前实现中，指令解码逻辑集成在 `DisAssembler` 类中。以下展示目标架构中独立指令解码器的设计：
```java
public class InstructionDecoder {
    // 解码单个指令
    public String decode(Instruction instruction) {
        int opcode = instruction.getOpcode();
        InstructionInfo info = RegisterBytecodeDefinition
            .getInstruction(opcode);

        if (info == null) {
            return String.format(".word 0x%08x  # 未知指令",
                instruction.getEncoding());
        }

        // 根据指令格式解码操作数
        switch (info.getFormat()) {
            case FORMAT_R:
                return decodeRType(instruction, info);
            case FORMAT_I:
                return decodeIType(instruction, info);
            case FORMAT_J:
                return decodeJType(instruction, info);
            default:
                return info.getName();
        }
    }

    // 解码 R 类型指令
    private String decodeRType(Instruction instruction,
                               InstructionInfo info) {
        int encoding = instruction.getEncoding();
        int rd = (encoding >> 21) & 0x1F;
        int rs1 = (encoding >> 16) & 0x1F;
        int rs2 = (encoding >> 11) & 0x1F;

        return String.format("%-8s r%d, r%d, r%d",
            info.getName(), rd, rs1, rs2);
    }

    // 解码 I 类型指令
    private String decodeIType(Instruction instruction,
                               InstructionInfo info) {
        int encoding = instruction.getEncoding();
        int rd = (encoding >> 21) & 0x1F;
        int rs1 = (encoding >> 16) & 0x1F;
        int imm = encoding & 0xFFFF;
        // 符号扩展
        if ((imm & 0x8000) != 0) {
            imm |= 0xFFFF0000;
        }

        // 根据指令类型调整格式
        if (info.getName().equals("li") || info.getName().equals("lc")) {
            return String.format("%-8s r%d, %d",
                info.getName(), rd, imm);
        } else if (info.getName().equals("lw") ||
                   info.getName().equals("sw")) {
            return String.format("%-8s r%d, r%d, %d",
                info.getName(), rd, rs1, imm);
        } else {
            return String.format("%-8s r%d, %d",
                info.getName(), rs1, imm);
        }
    }
}
```

### 反汇编输出示例
```assembly
# 反汇编输出示例
# 地址   | 编码        | 汇编指令
# -------|-------------|-----------
0x0000:  0x7040000a    li r1, 10
0x0004:  0x70800014    li r2, 20
0x0008:  0x01820800    add r3, r1, r2
0x000c:  0x70480000    print r3
0x0010:  0x6a000000    halt

# 常量池（偏移量 0x1000）
# 索引 | 类型 | 值
# ------|------|-----
0x1000: .float 3.14159
0x1004: .string "hello"

# 符号表
# 地址 | 符号
# ------|------
0x0000: main
0x0014: add_func
```

## 调试信息支持

### 符号表生成
#### 汇编时符号表
```java
public class SymbolTable {
    // 符号表条目
    public static class Symbol {
        String name;      // 符号名称
        int address;      // 符号地址
        SymbolType type;  // 符号类型（函数、标签、变量）
        int size;         // 符号大小（字节）
        int scope;        // 作用域
    }

    // 添加符号
    public void addSymbol(String name, int address,
                          SymbolType type, int size);

    // 查找符号
    public Symbol findSymbol(String name);

    // 根据地址查找符号
    public Symbol findSymbolByAddress(int address);
}
```

#### 调试信息格式
```json
{
  "version": "1.0",
  "symbols": [
    {
      "name": "main",
      "address": 0,
      "type": "function",
      "size": 20,
      "locals": [
        {"name": "a", "type": "int", "offset": -4},
        {"name": "b", "type": "int", "offset": -8}
      ]
    }
  ],
  "sourceMap": [
    {"address": 0, "line": 5, "file": "test.cymbol"},
    {"address": 4, "line": 6, "file": "test.cymbol"}
  ]
}
```

### 源码级调试
- **行号信息**：将字节码地址映射到源代码行号
- **变量信息**：记录局部变量名称和位置（寄存器或栈偏移）
- **类型信息**：记录变量和表达式的类型信息
- **作用域信息**：记录符号的作用域范围

## 工具集成

### 命令行接口
#### 汇编器命令行
```bash
# 基本用法
java RegisterByteCodeAssembler input.asm output.vm

# 选项
java RegisterByteCodeAssembler \
  -o output.vm \          # 输出文件
  -d symbols.json \       # 生成调试符号文件
  -v \                    # 详细模式
  input.asm
```

#### 反汇编器命令行
```bash
# 基本用法
java RegisterDisAssembler input.vm output.dis

# 选项
java RegisterDisAssembler \
  -o output.dis \         # 输出文件
  -s symbols.json \       # 使用符号文件
  -a \                    # 显示地址
  -c \                    # 显示编码
  input.vm
```

### IDE 集成
#### 语法高亮
- **寄存器**：`r0`-`r15` 特殊高亮
- **指令**：42条指令关键字高亮
- **立即数**：数字常量特殊颜色
- **标签**：标签定义和引用高亮

#### 代码补全
- **指令补全**：输入指令前缀，显示可用指令
- **寄存器补全**：输入 `r`，显示寄存器列表
- **标签补全**：输入标签前缀，显示定义标签

#### 实时错误检查
- **语法错误**：实时标记语法错误
- **语义错误**：检查寄存器范围、立即数范围
- **符号错误**：检查未定义标签和符号

## 测试策略

### 单元测试
#### 汇编器单元测试
```java
public class AssemblerTest {
    @Test
    public void testAddInstruction() {
        String asm = "add r1, r2, r3";
        byte[] bytecode = assembler.assemble(asm);
        // 验证编码是否正确
        assertEquals(0x01821800, bytecode[0]);
    }

    @Test
    public void testLabelResolution() {
        String asm = "loop:\nli r1, 10\nj loop";
        byte[] bytecode = assembler.assemble(asm);
        // 验证跳转地址是否正确解析
        assertJumpTarget(bytecode, 0);
    }
}
```

#### 反汇编器单元测试
```java
public class DisAssemblerTest {
    @Test
    public void testDisassembleAdd() {
        byte[] bytecode = {0x01, 0x82, 0x18, 0x00}; // add r1, r2, r3
        String asm = disassembler.disassemble(bytecode);
        assertEquals("add r1, r2, r3", asm.trim());
    }

    @Test
    public void testRoundTrip() {
        String originalAsm = "li r1, 10\nadd r2, r1, r1";
        byte[] bytecode = assembler.assemble(originalAsm);
        String disassembled = disassembler.disassemble(bytecode);
        // 验证往返转换的一致性
        assertAssemblyEquals(originalAsm, disassembled);
    }
}
```

### 集成测试
#### 完整程序测试
- **汇编-执行测试**：汇编程序并在虚拟机上执行，验证结果
- **反汇编-重汇编测试**：反汇编后重新汇编，验证字节码相同
- **调试信息测试**：验证调试符号信息的正确性

#### 边界条件测试
- **最大立即数测试**：测试立即数边界值
- **寄存器边界测试**：测试 r0 和 r15 的特殊行为
- **内存边界测试**：测试内存访问边界条件

### 性能测试
- **汇编速度测试**：测量大型程序的汇编时间
- **反汇编速度测试**：测量大型字节码文件的反汇编时间
- **内存使用测试**：测量汇编器/反汇编器的内存使用

## 扩展性设计

### 新指令支持
#### 步骤1：更新语法定义
```antlr4
// 在 instr 规则中添加新指令格式
instr
    :   // ... 现有规则
    |   op=ID a=temp ',' b=temp ',' c=temp ',' d=temp NEWLINE
    ;
```

#### 步骤2：更新指令定义
```java
// 在 RegisterBytecodeDefinition.java 中添加新指令
public static final short INSTR_NEW = 43;
instructions[43] = new Instruction("new", REG, REG, REG, REG);
```

#### 步骤3：更新汇编器和反汇编器
- **汇编器**：添加新指令的编码逻辑
- **反汇编器**：添加新指令的解码逻辑
- **测试**：添加新指令的测试用例

### 新语法特性支持
#### 宏汇编支持
```assembly
# 定义宏
.macro push reg
    sw reg, sp, 0
    sub sp, sp, 4
.endmacro

# 使用宏
push r1
push r2
```

#### 条件汇编支持
```assembly
.if DEBUG
    print r1
.endif
```

#### 包含文件支持
```assembly
.include "stdlib.asm"
```

## 附录

### A. 指令编码速查表
见 `寄存器指令集设计规范.md` 附录。

### B. 错误代码参考
见项目文档 `errors.md`。

### C. 性能优化建议
1. **使用指令缓存**：缓存常用指令的编码
2. **批量处理**：批量处理指令，减少函数调用开销
3. **内存池**：使用对象池减少内存分配
4. **并行处理**：多线程处理大型程序（未来扩展）