# Syntax Overview

## Lexical Structure

### Keywords
The Cymbol language defines a set of reserved keywords for control flow, data types, and program structure. Key keywords include:
- `int`, `float`, `void`: Basic data types
- `if`, `else`, `while`: Control flow statements
- `return`: Function return statement
- `null`: Null literal

### Identifiers
Identifiers in Cymbol follow standard C-style naming conventions. They must start with a letter or underscore, followed by letters, digits, or underscores. The lexer recognizes identifiers through the `ID` token rule.

### Literals
Cymbol supports several literal types:
- **Integer literals**: Represented by the `INT` token, matching sequences of digits.
- **Floating-point literals**: Represented by the `FLOAT` token, supporting decimal notation.
- **String literals**: Enclosed in double quotes, represented by the `STRING` token.
- **Character literals**: Enclosed in single quotes, represented by the `CHAR` token.
- **Boolean literals**: `true` and `false`, represented by the `BOOLEAN` token.
- **Null literal**: `null`, represented by the `NULL` token.

### Operators
The language includes a comprehensive set of operators:
- **Arithmetic**: `+`, `-`, `*`, `/`, `%`
- **Comparison**: `==`, `!=`, `<`, `<=`, `>`, `>=`
- **Logical**: `!`, `&&`
- **Assignment**: `=`
- **Unary**: `-`, `!`

## Syntactic Constructs

### Program Structure
A Cymbol program is structured as a compilation unit, represented by the `CompileUnit` AST node. The root grammar rule `file` defines the program structure, which can contain function declarations, variable declarations, and statements.

```ebnf
file : (functionDecl | varDecl | statetment)* ;
```

### Declarations
#### Variable Declarations
Variables are declared with a type followed by an identifier and optional initialization.

```ebnf
varDecl : type ID ('=' expr)? ';' ;
type : primaryType | ID ;
primaryType : 'int' | 'float' | 'void' ;
```

#### Function Declarations
Functions are declared with a return type, name, parameter list, and body block.

```ebnf
functionDecl : type ID '(' formalParameters? ')' block ;
formalParameters : formalParameter (',' formalParameter)* ;
formalParameter : type ID ;
```

### Statements
Cymbol supports various statement types:
- **Expression statements**: Expressions followed by semicolon
- **Variable declaration statements**: Local variable declarations
- **Block statements**: Groups of statements enclosed in braces
- **Control flow statements**: `if-else`, `while` loops
- **Return statements**: Function return with optional expression

```ebnf
statetment : statBlock
          | statVarDecl
          | statReturn
          | stateCondition
          | stateWhile
          | statAssign
          | stat ;
```

### Expressions
Expressions in Cymbol follow a precedence-based grammar with support for:
- **Primary expressions**: Identifiers, literals, parenthesized expressions
- **Unary operations**: Negation, logical NOT
- **Binary operations**: Arithmetic, comparison, logical operations
- **Function calls**: Function invocation with arguments

```ebnf
expr : expr ('*' | '/') expr
     | expr ('+' | '-') expr
     | expr ('==' | '!=' | '>' | '>=' | '<' | '<=') expr
     | expr '&&' expr
     | '-' expr
     | '!' expr
     | primary
     | ID '(' exprList? ')' ;
```

## CompileUnit: The Root AST Node

The `CompileUnit` serves as the root node of the Abstract Syntax Tree (AST) for a complete Cymbol program. It represents the top-level compilation unit that contains all global declarations and statements. This node is generated by the `file` rule in the parser and acts as the entry point for semantic analysis and code generation phases.

The `CompileUnit` node typically contains:
- A list of function declarations
- A list of global variable declarations
- A list of top-level statements (in some implementations)

This structure allows the compiler to process the entire program as a single unit, enabling global analysis and optimization.

## Evolution of the Grammar

The Cymbol grammar has evolved significantly through different implementation episodes:

### Early Episodes (ep16-ep17)
The initial grammar focused on basic procedural constructs:
- Support for fundamental data types (`int`, `float`)
- Function declarations with parameters
- Control flow statements (`if`, `while`)
- Simple expression evaluation

### Advanced Features (ep19-ep21)
Later episodes introduced more sophisticated language features:
- **Struct support**: Added `struct` declarations and instance creation
- **Array support**: Implemented array declarations, initialization, and access
- **Enhanced literals**: Added `bool`, `string`, and `object` types
- **Additional control flow**: Introduced `break` and `continue` statements
- **Method calls**: Added support for struct method invocation syntax

The grammar evolved from a simple calculator-like language to a full-featured procedural language with user-defined types and complex data structures.

## Non-Standard Syntactic Choices

Cymbol incorporates several non-standard syntactic choices compared to traditional C-like languages:

### Unified Expression-Statement Handling
Unlike C, where expressions and statements are distinct categories, Cymbol treats expressions as statements when followed by a semicolon. This simplifies the grammar by eliminating the need for separate expression-statement rules.

### Simplified Type System
The grammar uses a unified `type` rule that can reference both primitive types and user-defined types (via identifiers), rather than maintaining separate type specification mechanisms.

### Flexible Compilation Unit
The `file` rule allows top-level statements outside of functions, which is not permitted in standard C. This enables scripting-style programming where statements can be executed at global scope.

### Operator Precedence via Semantic Predicates
Instead of using multiple grammar levels for operator precedence, Cymbol employs semantic predicates (`sempred`) to enforce precedence rules during parsing, allowing a more compact grammar definition.

## Example Programs

### Simple Arithmetic
```cymbol
int main() {
    int a = 5;
    int b = 3;
    int c = a + b;
    return c;
}
```

### Function with Parameters
```cymbol
int add(int x, int y) {
    return x + y;
}

void main() {
    int result = add(10, 20);
}
```

### Control Flow
```cymbol
void main() {
    int i = 0;
    while (i < 10) {
        if (i % 2 == 0) {
            print(i);
        }
        i = i + 1;
    }
}
```

### Struct Usage
```cymbol
struct Point {
    int x;
    int y;
}

void main() {
    Point p;
    p.x = 10;
    p.y = 20;
}
```

### Array Operations
```cymbol
void main() {
    int numbers[5];
    numbers[0] = 1;
    numbers[1] = 2;
    int sum = numbers[0] + numbers[1];
}
```