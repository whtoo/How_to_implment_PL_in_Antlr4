# 调试与可视化

<cite>
**本文档引用文件**  
- [Dumper.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/debugger/ast/Dumper.java)
- [ASTNode.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/ast/ASTNode.java)
- [CymbolIRBuilder.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/ir/CymbolIRBuilder.java)
- [CFG.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFG.java)
- [graph_0_origin.md](file://ep20/src/main/resources/graph_0_origin.md)
- [graph_0_optimized.md](file://ep20/src/main/resources/graph_0_optimized.md)
</cite>

## 目录
1. [简介](#简介)
2. [AST可视化](#ast可视化)
3. [IR可视化](#ir可视化)
4. [CFG可视化](#cfg可视化)
5. [图形化输出文件生成机制](#图形化输出文件生成机制)
6. [编译器调试与教学演示应用](#编译器调试与教学演示应用)
7. [不同阶段IR与CFG对比分析](#不同阶段ir与cfg对比分析)
8. [初学者调试技巧](#初学者调试技巧)
9. [高级用户扩展方法](#高级用户扩展方法)
10. [结论](#结论)

## 简介
本文档详细介绍了编译器开发中的调试与可视化工具，重点涵盖抽象语法树（AST）、中间表示（IR）和控制流图（CFG）的可视化技术。通过Dumper类实现AST节点的递归遍历和可读文本生成，结合Mermaid格式的图形化输出，为编译器开发和教学提供了强大的调试支持。

## AST可视化

Dumper类是AST可视化的核心工具，通过递归遍历AST节点生成结构化的文本表示。该类采用访问者模式，支持对各种AST节点类型的格式化输出。

```mermaid
classDiagram
class Dumper {
-nIndent : int
-stream : PrintStream
+Dumper(PrintStream)
+printClass(Object, Location)
+printNodeList(String, Dumpable[])
+printMember(String, String)
+printMember(String, Dumpable)
+indent()
+unindent()
-printIndent()
}
class Dumpable {
<<interface>>
+dump(Dumper)
}
class ASTNode {
+ctx : ParserRuleContext
+getLocation() : Location
+accept(ASTVisitor)
+dump(PrintStream)
+dump(Dumper)
_dump(Dumper)
}
Dumper --> Dumpable : "调用"
Dumpable <|-- ASTNode : "实现"
ASTNode --> Dumper : "使用"
```

**图示来源**  
- [Dumper.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/debugger/ast/Dumper.java#L9-L94)
- [ASTNode.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/ast/ASTNode.java#L1-L48)

**本节来源**  
- [Dumper.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/debugger/ast/Dumper.java#L9-L94)
- [ASTNode.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/ast/ASTNode.java#L1-L48)

## IR可视化

中间表示（IR）可视化通过CymbolIRBuilder类实现，将AST转换为三地址码形式的线性IR指令序列。这种表示便于后续优化和分析，支持虚拟寄存器和栈帧位置的地址化表示。

```mermaid
classDiagram
class CymbolIRBuilder {
-prog : Prog
-currentBlock : LinearIRBlock
-breakStack : Stack~LinearIRBlock~
-continueStack : Stack~LinearIRBlock~
-evalExprStack : Stack~VarSlot~
+visit(CompileUnit) : Void
+visit(FuncDeclNode) : Void
+visit(BinaryExprNode) : VarSlot
+visit(WhileStmtNode) : Void
+addInstr(IRNode) : Optional~VarSlot~
+jump(LinearIRBlock) : void
+jumpIf(VarSlot, LinearIRBlock, LinearIRBlock) : void
}
class Prog {
-blocks : LinearIRBlock[]
+addBlock(LinearIRBlock) : void
}
class LinearIRBlock {
-stmts : IRNode[]
-scope : Scope
-link : LinearIRBlock
+addStmt(IRNode) : void
+setScope(Scope) : void
}
class IRNode {
<<abstract>>
}
CymbolIRBuilder --> Prog : "生成"
CymbolIRBuilder --> LinearIRBlock : "操作"
LinearIRBlock --> IRNode : "包含"
Prog --> LinearIRBlock : "管理"
```

**图示来源**  
- [CymbolIRBuilder.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/ir/CymbolIRBuilder.java#L1-L473)
- [Prog.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/ir/Prog.java)
- [LinearIRBlock.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/LinearIRBlock.java)

**本节来源**  
- [CymbolIRBuilder.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/ir/CymbolIRBuilder.java#L1-L473)

## CFG可视化

控制流图（CFG）可视化通过CFG类实现，将线性IR块转换为基本块并建立控制流边。CFG支持Mermaid格式的图形化输出，便于分析程序的控制流结构。

```mermaid
classDiagram
class CFG {
-nodes : BasicBlock[]
-edges : Triple[]
-links : Pair[]
+CFG(BasicBlock[], Triple[])
+getFrontier(int) : Set~Integer~
+getSucceed(int) : Set~Integer~
+getInDegree(int) : int
+getOutDegree(int) : int
+toString() : String
+removeEdge(Triple) : void
+removeNode(BasicBlock) : void
}
class BasicBlock {
-id : int
-irNodes : IRNode[]
-label : String
+getIRNodes() : IRNode[]
+getLabel() : String
+getId() : int
}
class CFGBuilder {
-startBlock : LinearIRBlock
+CFGBuilder(LinearIRBlock)
+getCFG() : CFG~IRNode~
}
CFG --> BasicBlock : "包含"
CFGBuilder --> CFG : "构建"
CFGBuilder --> LinearIRBlock : "输入"
```

**图示来源**  
- [CFG.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFG.java#L1-L158)
- [BasicBlock.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/BasicBlock.java)
- [CFGBuilder.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFGBuilder.java)

**本节来源**  
- [CFG.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFG.java#L1-L158)

## 图形化输出文件生成机制

图形化输出文件（如graph_0_origin.md）的生成机制基于CFG类的toString方法，该方法将控制流图转换为Mermaid格式的文本表示。这种机制支持原始和优化后CFG的对比分析。

```mermaid
flowchart TD
A[线性IR块] --> B[基本块划分]
B --> C[控制流边建立]
C --> D[CFG对象构建]
D --> E[Mermaid格式转换]
E --> F[Markdown文件输出]
F --> G[graph_0_origin.md]
G --> H[可视化渲染]
```

**图示来源**  
- [CFG.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFG.java#L142-L158)
- [graph_0_origin.md](file://ep20/src/main/resources/graph_0_origin.md)

**本节来源**  
- [CFG.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFG.java#L142-L158)
- [graph_0_origin.md](file://ep20/src/main/resources/graph_0_origin.md)

## 编译器调试与教学演示应用

这些可视化工具在编译器调试和教学演示中具有重要应用价值。通过AST、IR和CFG的可视化，开发者可以直观地理解编译器的各个阶段，快速定位和修复问题。

```mermaid
graph TD
A[源代码] --> B[词法分析]
B --> C[语法分析]
C --> D[AST可视化]
D --> E[符号解析]
E --> F[类型检查]
F --> G[IR生成]
G --> H[IR可视化]
H --> I[CFG构建]
I --> J[CFG可视化]
J --> K[优化]
K --> L[代码生成]
```

**图示来源**  
- [Compiler.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/Compiler.java)
- [CymbolIRBuilder.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/ir/CymbolIRBuilder.java)
- [CFGBuilder.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFGBuilder.java)

**本节来源**  
- [Compiler.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/Compiler.java)
- [CymbolIRBuilder.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/ir/CymbolIRBuilder.java)

## 不同阶段IR与CFG对比分析

通过对比原始和优化后的IR与CFG，可以直观地观察编译器优化的效果。以下示例展示了函数dec1的优化前后对比。

```mermaid
graph TD
subgraph "优化前 (graph_0_origin.md)"
Q0["ret;"]
end
subgraph "优化前 (graph_0_origin.md)"
Q1[".def dec1: args=1 ,locals=1;"]
Q2["t0 = @0;"]
Q3["t1 = 1 ;"]
Q4["t0 SUB t1;"]
Q5["jmp L1;"]
end
L0 --> L1
L0 --> L1
```

```mermaid
graph TD
subgraph "优化后 (graph_0_optimized.md)"
Q0[".def dec1: args=1 ,locals=1;"]
Q1["t0 = @0;"]
Q2["t1 = 1 ;"]
Q3["t0 SUB t1;"]
Q4["ret;"]
end
```

**图示来源**  
- [graph_0_origin.md](file://ep20/src/main/resources/graph_0_origin.md)
- [graph_0_optimized.md](file://ep20/src/main/resources/graph_0_optimized.md)

**本节来源**  
- [graph_0_origin.md](file://ep20/src/main/resources/graph_0_origin.md)
- [graph_0_optimized.md](file://ep20/src/main/resources/graph_0_optimized.md)

## 初学者调试技巧

对于初学者，建议从以下方面入手进行调试：
1. 使用Dumper类输出AST结构，理解语法树的构建过程
2. 查看IR生成结果，理解表达式如何转换为三地址码
3. 分析CFG图形，理解程序的控制流结构
4. 对比优化前后的IR和CFG，理解优化算法的效果

```mermaid
flowchart LR
A[学习AST结构] --> B[理解IR生成]
B --> C[分析CFG]
C --> D[观察优化效果]
D --> E[掌握调试技巧]
```

**本节来源**  
- [Dumper.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/debugger/ast/Dumper.java)
- [CymbolIRBuilder.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/ir/CymbolIRBuilder.java)
- [CFG.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFG.java)

## 高级用户扩展方法

高级用户可以通过以下方式扩展可视化功能：
1. 自定义Dumper类的输出格式，添加更多调试信息
2. 扩展CFG类的功能，支持更多类型的控制流分析
3. 实现新的可视化格式，如DOT或SVG
4. 集成外部可视化工具，提供更丰富的图形界面

```mermaid
classDiagram
class CustomDumper {
+printCustomInfo(String, Object)
+setCustomFormat(boolean)
}
class ExtendedCFG {
+analyzeDataFlow() : void
+generateDotOutput() : String
}
Dumper <|-- CustomDumper : "继承"
CFG <|-- ExtendedCFG : "继承"
```

**本节来源**  
- [Dumper.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/debugger/ast/Dumper.java)
- [CFG.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/pass/cfg/CFG.java)

## 结论

本文档详细介绍了编译器开发中的调试与可视化工具，包括AST、IR和CFG的可视化技术。通过Dumper类和CFG类的实现，提供了强大的调试支持，既适用于初学者的学习理解，也支持高级用户的深度扩展。这些工具在编译器开发和教学中具有重要价值，能够显著提高开发效率和教学质量。