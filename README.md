# How to implement PL in ANTLR4

[![Java](https://img.shields.io/badge/java-21+-blue)](https://www.oracle.com/java/technologies/downloads/)
[![ANTLR4](https://img.shields.io/badge/ANTLR4-4.13.2-orange)](https://www.antlr.org/)
[![Maven](https://img.shields.io/badge/maven-3.6+-brightgreen)](https://maven.apache.org/)
[![Build Status](https://img.shields.io/badge/build-passing-brightgreen)](.github/workflows/maven.yml)

## 项目简介

**How to implement PL in ANTLR4** 是一个系统性的编译原理教学项目，通过21个渐进式章节（EP1-EP21），完整展示了如何从零开始构建一个现代编译器。项目基于ANTLR4和Java开发，为编译原理学习者提供了从理论到实践的完整学习路径。

### 项目价值

本项目专门为以下四类用户设计：

- **📚 编译原理学习者**：提供清晰的演进路径和详细说明
- **👥 项目贡献者**：提供完整的架构设计和测试标准  
- **🎓 课程教学**：提供分阶段的教学大纲
- **🔍 代码审查**：提供明确的测试和质量标准

## 学习路径概览

```
第一阶段：基础构建 (EP1-EP10)
├── EP1-EP5：词法语法分析基础
├── EP6-EP10：解释器和AST构建

第二阶段：编译器核心 (EP11-EP20)  
├── EP11-EP15：类型系统和语义分析
├── EP16-EP18：中间表示和虚拟机
└── EP19-EP20：完整编译流程

第三阶段：高级优化 (EP21)
└── EP21：数据流分析和SSA形式
```

## 项目结构

```
How_to_implment_PL_in_Antlr4/
├── ep1-ep10/              # 基础阶段：词法语法分析、AST构建、解释器
├── ep11-ep17/             # 编译器阶段：类型系统、语义分析、符号表
├── ep18/                  # 虚拟机实现：栈式虚拟机和字节码
├── ep19/                  # 编译器前端：完整的前端架构
├── ep20/                  # 编译器完整版：IR、CFG、代码生成
├── ep21/                  # 高级优化：数据流分析、SSA形式
├── docs/                  # 项目整体文档和设计规范
├── scripts/               # 构建脚本和开发工具
├── logs/                  # 开发日志和测试记录
└── pom.xml                # Maven多模块配置
```

## 核心特性

### 📚 渐进式学习设计
- **EP1-EP5**：基础词法语法分析，ANTLR4入门
- **EP6-EP10**：AST构建、访问者模式、基础解释器
- **EP11-EP15**：类型系统、符号表、语义分析
- **EP16-EP18**：中间表示、控制流图、虚拟机
- **EP19-EP20**：完整编译管道和代码生成
- **EP21**：高级优化技术：数据流分析、SSA形式

### 🏗️ 完整编译器架构
- **前端**：词法分析、语法分析、AST构建
- **中端**：符号表、类型检查、语义分析
- **优化**：中间表示生成、控制流分析、数据流分析
- **后端**：代码生成、虚拟机执行

### 🧪 严格测试标准
- **单元测试**：每个模块的详细测试
- **集成测试**：模块间协作验证
- **端到端测试**：完整编译流程验证
- **性能测试**：编译效率和执行性能

### 📊 可视化支持
- **AST可视化**：语法树结构展示
- **控制流图**：CFG图形化输出
- **数据流分析**：活跃变量等分析结果
- **编译过程追踪**：详细的执行日志

## 演进阶段详解

### EP1-EP10：基础构建阶段

#### EP1 - 词法分析器（Lexer）
**目标**：将源代码转换为词法单元流
- 构建基于ANTLR4的词法分析器
- 识别关键字、标识符、字面量、运算符
- 处理注释和空白字符
- **核心实现**：`Hello.g4`

#### EP2 - 语法分析器（Parser）
**目标**：将词法单元流转换为解析树
- 定义语法规则（数组初始化语法）
- 处理语法优先级和结合性
- 错误恢复机制
- **核心实现**：`ArrayInit.g4`

#### EP3 - AST构建（Abstract Syntax Tree）
**目标**：将解析树转换为抽象语法树
- 构建访问者模式实现
- 表达式求值器
- 基本数学运算支持
- **核心实现**：`LibExpr.g4`, `ExprJoyRide.java`

#### EP4 - 访问者模式（Visitor Pattern）
**目标**：实现AST的遍历和处理
- 定义访问者接口
- 实现AST节点的accept方法
- 支持双分派机制
- **核心实现**：所有ASTNode的子类

#### EP5 - 工具构建（Tool Building）
**目标**：实现Java接口提取工具
- Java语法分析器
- 接口提取算法
- 代码重构工具
- **核心实现**：`Java.g4`, `ExtractInterfaceTool.java`

#### EP6 - CSV处理器（CSV Processor）
**目标**：构建CSV文件解析器
- CSV语法定义
- 数据读取和验证
- 格式化输出
- **核心实现**：`CSV.g4`, `CSVReader.java`

#### EP7 - JSON处理器（JSON Processor）
**目标**：构建JSON解析器
- JSON语法标准
- 嵌套数据结构处理
- 验证和格式化
- **核心实现**：`JSON.g4`

#### EP8 - AST节点设计（AST Node Design）
**目标**：设计完整的AST节点体系
- 表达式节点层次结构
- 算术操作节点
- 访问者模式实现
- **核心实现**：`VecMath.g4`系列节点类

### EP11-EP15：编译器核心阶段

#### EP11-EP14：类型系统和符号表
**目标**：实现静态类型检查和作用域管理
- 类型系统设计（int, float, string, bool）
- 符号表数据结构
- 作用域链管理
- 类型兼容性检查

#### EP15 - 错误处理（Error Handling）
**目标**：构建统一的错误报告机制
- 语法错误恢复
- 语义错误报告
- 错误位置和上下文信息
- 错误处理器和异常类

### EP16-EP18：中间表示和虚拟机

#### EP16-EP17：中间表示设计
**目标**：设计三地址代码中间表示
- IR指令设计（算术、逻辑、控制流）
- 虚拟寄存器分配
- IR指令格式和语义

#### EP18 - 栈式虚拟机（Stack VM）
**目标**：实现栈式虚拟机
**架构设计**：
```
+-------------------+
|   虚拟机运行时     |
|-------------------|
|   字节码解释器     |
|   栈帧管理        |
|   内存分配        |
+-------------------+
|   字节码格式      |
|   指令集架构       |
+-------------------+
```

**核心组件**：
- **StackVM**：虚拟机主类
- **BytecodeDefinition**：字节码定义
- **StackFrame**：栈帧管理
- **VMRunner**：虚拟机执行器

**指令集**：
- 加载/存储指令：`LOAD`, `STORE`, `PUSH`
- 算术指令：`ADD`, `SUB`, `MUL`, `DIV`
- 控制流：`JMP`, `JZ`, `CALL`, `RET`
- 函数调用：`CALL`, `RET`, `ENTER`, `LEAVE`

### EP19-EP20：完整编译流程

#### EP19 - 编译器前端（Full Frontend）
**目标**：实现完整的前端编译器
- Cymbol语言完整支持
- 类型系统和作用域管理
- 语义分析和错误处理
- 93个测试用例全部通过

#### EP20 - 完整编译器（Full Compiler）
**目标**：整合所有组件，构建完整编译流程

**编译流程架构**：
```
╔════════════════════════════════════════════════════════════╗
║                  编译器前端（Frontend）                      ║
╠════════════════════════════════════════════════════════════╣
║  1. 词法分析 → 2. 语法分析 → 3. AST构建 → 4. 语义分析        ║
║     (Lexer)       (Parser)      (AST)      (TypeChecker)   ║
╚════════════════════════════════════════════════════════════╝
                              ↓
╔════════════════════════════════════════════════════════════╗
║                  编译器中端（Middle）                       ║
╠════════════════════════════════════════════════════════════╣
║  5. IR生成 → 6. CFG构建 → 7. 优化（跳转+死代码）              ║
║    (IRBuilder)  (CFGBuilder)   (Optimizer)                 ║
╚════════════════════════════════════════════════════════════╝
                              ↓
╔════════════════════════════════════════════════════════════╗
║                  编译器后端（Backend）                       ║
╠════════════════════════════════════════════════════════════╣
║  8. 代码生成 → 9. 虚拟机执行                                 ║
║   (Assembler)   (StackVM)                                   ║
╚════════════════════════════════════════════════════════════╝
```

**核心模块**：
- **Compiler.java**：主驱动程序
- **CymbolASTBuilder**：AST构建器
- **CymbolIRBuilder**：IR生成器
- **ControlFlowAnalysis**：控制流分析
- **CymbolAssembler**：代码生成器

### EP21 - 高级优化（Advanced Optimization）
**目标**：实现现代编译器优化技术
**架构设计**：
```
+-----------------------+
|   编译器前端（共享）    |
|-----------------------|
|   AST构建 + 符号表     |
|   类型检查 + IR生成    |
+-----------------------+
|   优化框架（共享）     |
|-----------------------|
|   运行时编译器          |
|   • 字节码生成         |
|   • 模板编译           |
|   • 元编程支持         |
+-----------------------+
|   运行时执行引擎       |
|   • 动态加载           |
|   • 性能监控           |
|   • 优化决策           |
+-----------------------+
```

**技术特性**：
- **分层IR架构**：MIR/LIR分层中间表示体系
- **数据流分析框架**：活跃变量分析、前向/后向分析
- **SSA形式**：Φ函数自动生成和SSA图构建
- **增强可视化**：Mermaid和DOT格式的CFG可视化

## 四大使用场景详解

### 1. 📚 编译原理学习者
**学习目标**：理解编译器的完整工作原理

**学习路径**：
```
阶段1：基础认知（第1-4周）
├── EP1-EP2：理解词法和语法分析概念
├── EP3-EP4：掌握AST构建和访问者模式
└── EP5-EP8：实践简单的语言处理器

阶段2：核心理解（第5-10周）
├── EP11-EP14：学习类型系统和符号表
├── EP15：掌握错误处理机制
├── EP16-EP18：理解中间表示和虚拟机
└── EP19-EP20：整合完整的编译流程

阶段3：高级应用（第11-16周）
└── EP21：掌握现代优化技术
```

**学习成果**：
- 掌握ANTLR4的使用和语法定义
- 理解编译器的各个阶段及其作用
- 具备独立实现简单语言的能力
- 理解现代编译器优化技术

### 2. 👥 项目贡献者
**贡献目标**：为项目贡献高质量代码

**贡献流程**：
```
1. Fork项目 → 2. 创建分支 → 3. 编写测试 → 4. 实现功能 → 5. 提交PR
```

**代码质量标准**：

**编码规范（100%强制）**：
- 遵循Google Java Style Guide
- 使用CheckStyle进行代码格式检查
- SpotBugs静态代码分析无严重问题
- 完整的Javadoc注释

**测试要求（必须）**：
- 每个新功能必须包含对应的测试用例
- 测试命名遵循规范：`test[功能]_[场景]_[预期]`
- 单元测试覆盖率保持≥80%
- 关键算法测试覆盖率≥95%

**架构一致性**：
- 遵循项目的模块化设计
- 不破坏现有的公共接口
- 新增模块要与现有架构兼容

### 3. 🎓 课程教学
**教学目标**：为编译原理课程提供完整的实践平台

**分阶段教学大纲**：

**第1-4周：编译基础**
```
周1：ANTLR4入门和词法分析
├── 理论：编译原理概述，词法分析概念
├── 实践：EP1词法分析器实现
├── 作业：自定义一个简单语言的词法分析器

周2：语法分析和AST构建
├── 理论：LL(k)文法，自顶向下分析
├── 实践：EP2语法分析器和EP3 AST构建
├── 作业：实现一个小型计算器的语法分析

周3：访问者模式和解释器
├── 理论：访问者设计模式，解释器模式
├── 实践：EP4访问者模式实现
├── 作业：基于AST构建一个简单解释器

周4：工具构建和实际应用
├── 理论：代码分析工具的设计
├── 实践：EP5-EP8工具类实现
├── 作业：设计一个配置解析器
```

**第5-8周：编译器核心**
```
周5-6：类型系统和符号表
├── 理论：类型系统设计，作用域管理
├── 实践：EP11-EP14类型系统实现
├── 作业：为自定义语言添加类型检查

周7：错误处理和语义分析
├── 理论：语义分析，错误恢复策略
├── 实践：EP15错误处理机制
├── 作业：设计错误报告和恢复机制

周8：中间表示和虚拟机基础
├── 理论：三地址码，虚拟机设计
├── 实践：EP16-EP18 IR和虚拟机
├── 作业：实现一个简单虚拟机的指令集
```

**第9-12周：完整编译流程**
```
周9-10：控制流图和优化
├── 理论：控制流分析，基本块划分
├── 实践：EP19控制流分析实现
├── 作业：实现一个简单的数据流分析

周11-12：代码生成和集成
├── 理论：代码生成，寄存器分配
├── 实践：EP20完整编译器集成
├── 作业：优化一个实际的编译流程
```

**第13-16周：高级优化**
```
周13-14：现代优化技术
├── 理论：数据流分析，SSA形式
├── 实践：EP21高级优化实现
├── 作业：实现一个优化Pass

周15-16：项目实践和展示
├── 项目：实现一个完整的语言编译器
├── 展示：编译器架构和优化技术分享
└── 评估：功能正确性和性能对比
```

### 4. 🔍 代码审查
**审查目标**：确保代码质量和项目一致性

**审查流程**：
```
1. 提交代码 → 2. 自动检查 → 3. 人工审查 → 4. 反馈修改 → 5. 最终合并
```

**审查标准**：

**功能正确性（权重：30%）**
- [ ] 实现符合需求规格
- [ ] 边界条件处理正确
- [ ] 错误处理机制完善
- [ ] 性能影响可接受

**代码质量（权重：25%）**
- [ ] 代码风格符合规范
- [ ] 函数和类的复杂度适中
- [ ] 命名清晰有意义
- [ ] 注释充分且准确

**测试覆盖（权重：25%）**
- [ ] 单元测试完整性≥80%
- [ ] 关键路径100%覆盖
- [ ] 集成测试验证通过
- [ ] 性能测试达标

**文档维护（权重：20%）**
- [ ] Javadoc注释完整
- [ ] 设计文档及时更新
- [ ] 示例代码正确
- [ ] README保持最新

**审查清单**：

**代码质量检查**：
```bash
# 代码格式检查
mvn checkstyle:check

# 静态代码分析
mvn spotbugs:check

# 测试覆盖率
mvn jacoco:report
```

**架构一致性检查**：
- 新增代码是否遵循现有架构模式
- 是否引入了不必要的依赖
- 是否破坏了向后兼容性
- 模块间耦合度是否合理

## 快速开始

### 环境要求
- **Java 21** 或更高版本
- **Maven 3.6** 或更高版本
- **Git**

### 基础学习路径

**推荐顺序**：
1. **初学者**：从EP1开始，逐步学习每个阶段
2. **有经验者**：从EP12开始，重点学习编译器核心
3. **高级用户**：直接跳到EP20-EP21，学习高级特性

**基础示例**：
```bash
# 1. 克隆项目
git clone https://github.com/your-org/How_to_implement_PL_in_Antlr4.git
cd How_to_implement_PL_in_Antlr4

# 2. 编译整个项目
mvn clean compile

# 3. 运行测试（验证安装）
mvn test

# 4. 从EP1开始学习
cd ep1
mvn exec:java -Dexec.mainClass="org.teachfx.antlr4.Hello"
```

### 第一个程序示例

创建一个简单的Cymbol程序：
```cymbol
// 简单计算程序
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(5, 3);
    print("5 + 3 = ");
    print(result);
    return result;
}
```

编译和运行：
```bash
# 进入学习阶段（推荐EP20）
cd ep20
mvn compile

# 编译程序
mvn exec:java -Dexec.mainClass="org.teachfx.antlr4.ep20.Compiler" -Dexec.args="program.cymbol"

# 运行生成的字节码
mvn exec:java -Dexec.mainClass="org.teachfx.antlr4.ep18.VMRunner" -Dexec.args="program.vm"
```

## 开发指南

### 项目构建命令

```bash
# 清理项目
mvn clean

# 编译项目（包含ANTLR代码生成）
mvn compile

# 运行测试
mvn test

# 生成测试覆盖率报告
mvn jacoco:report

# 代码质量检查
mvn checkstyle:check spotbugs:check

# 打包特定模块
mvn package -pl ep20 -am
```

### 调试技巧

**启用详细日志**：
```bash
# 使用log4j2配置
mvn exec:java -Dlog4j.configurationFile=src/main/resources/log4j2.xml

# 调试特定阶段
mvn exec:java -Dexec.args="--debug-ast program.cymbol"
```

**可视化输出**：
```bash
# AST可视化
mvn exec:java -Dexec.args="--visualize-ast program.cymbol"

# CFG可视化
mvn exec:java -Dexec.args="--visualize-cfg program.cymbol"

# 生成Mermaid图表
mvn exec:java -Dexec.args="--mermaid-output program.cymbol"
```

## 测试标准

### 测试架构

```
         集成测试
            ^
            |
      编译器管道测试
            ^
            |
       组件测试
            ^
            |
        单元测试  (基础)
```

### 测试覆盖率要求

- **整体覆盖率**：≥ 85%
- **核心模块**（IR、CFG、优化器）：≥ 90%
- **新功能模块**：100%

### 测试执行

```bash
# 运行所有测试
mvn test

# 运行特定模块测试
mvn test -pl ep21

# 生成覆盖率报告
mvn jacoco:report
open target/site/jacoco/index.html
```

## 文档资源

### 项目级文档
- [项目总体介绍](docs/README.md)
- [测试策略和最佳实践](docs/测试策略.md)
- [设计要素和架构](docs/设计要素.md)
- [与传统编译过程对比](docs/与传统编译过程的对比.md)

### 各阶段文档
- **EP20**：[完整编译器实现](ep20/)
- **EP21**：[高级优化技术](ep21/docs/)

## 贡献指南

我们欢迎各种形式的贡献！

### 贡献类型
- 🐛 **Bug修复**：修复现有功能的问题
- ✨ **新功能**：添加新的语言特性或优化
- 📚 **文档**：改进文档和教程
- 🧪 **测试**：增加测试用例或改进测试质量

### 贡献流程
1. Fork项目
2. 创建特性分支 (`git checkout -b feature/AmazingFeature`)
3. 编写测试用例（TDD要求）
4. 实现功能代码
5. 确保所有测试通过 (`mvn test`)
6. 更新相关文档
7. 提交Pull Request

### 贡献要求
- 遵循项目的编码规范
- 新功能必须包含完整的测试用例
- 保持或提高代码覆盖率
- 更新相关文档和示例
- 确保通过所有CI检查

## 许可证

本项目采用BSD 3-Clause许可证，详见[LICENSE](LICENSE)文件。

## 联系方式

如有问题或建议：
- 提交GitHub Issue
- 查看[项目Wiki](https://github.com/whtoo/How_to_implment_PL_in_Antlr4/wiki)
- 参与[讨论](https://github.com/whtoo/How_to_implement_PL_in_Antlr4/discussions)

## 致谢

感谢所有为这个项目做出贡献的开发者和研究人员：
- ANTLR4团队提供的强大解析工具
- 编译原理领域的先驱研究者们
- 所有参与测试和反馈的用户
- 开源社区的支持和建议

---

**最后更新**：2025-11-30  
**项目状态**：活跃开发中  
**主要版本**：v1.0 (EP1-EP21完整版)