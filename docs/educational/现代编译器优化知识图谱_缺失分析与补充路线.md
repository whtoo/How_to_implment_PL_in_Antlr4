# ç°ä»£ç¼–è¯‘å™¨ä¼˜åŒ–çŸ¥è¯†å›¾è°± - ç¼ºå¤±åˆ†æä¸è¡¥å……è·¯çº¿

**å¯¹æ¯”åŸºå‡†**: ã€Šç¼–è¯‘åŸç†ã€‹ï¼ˆé¾™ä¹¦ç¬¬äºŒç‰ˆï¼Œ2007ï¼‰+ LLVM/GCC/V8ç°ä»£å®è·µ

---

## ğŸ“Š ç°çŠ¶åˆ†æ

### âœ… å·²è¦†ç›–çš„ä¼˜åŒ–æŠ€æœ¯ï¼ˆEP21ï¼‰

| ä¼˜åŒ–ç±»å‹ | å®ç°ä½ç½® | è¦†ç›–ç¨‹åº¦ | è¯´æ˜ |
|---------|---------|---------|------|
| **æ•°æ®æµåˆ†ææ¡†æ¶** | EP13, EP21 | â­â­â­â­ | åŸºç¡€æ¡†æ¶å®Œæ•´ |
| **SSAæ„å»º** | EP12 | â­â­â­â­ | æ”¯é…è¾¹ç•Œç®—æ³• |
| **æ´»è·ƒå˜é‡åˆ†æ** | EP14 | â­â­â­â­ | å‰å‘/åå‘åˆ†æ |
| **å¸¸é‡ä¼ æ’­** | EP15 | â­â­â­ | å±€éƒ¨å¸¸é‡ä¼ æ’­ |
| **æ­»ä»£ç æ¶ˆé™¤** | EP21 | â­â­â­ | åŸºç¡€DCE |
| **æ§åˆ¶æµåˆ†æ** | EP17 | â­â­â­â­â­ | CFGã€æ”¯é…æ ‘ |
| **çª¥å­”ä¼˜åŒ–** | EP20 | â­â­â­ | ç®€å•çª¥å­” |

---

## âŒ ç¼ºå¤±çš„å…³é”®ä¼˜åŒ–æŠ€æœ¯

### 1. è¿‡ç¨‹é—´ä¼˜åŒ–ï¼ˆInterprocedural Optimizationï¼‰

**é‡è¦ç¨‹åº¦**: â­â­â­â­â­
**å·¥ä¸šåº”ç”¨**: LLVM (IPO Pass), GCC (LTO), Java JIT

#### ç¼ºå¤±å†…å®¹

```
å½“å‰çŠ¶æ€:
â”œâ”€â”€ EP17: æœ‰è°ƒç”¨å›¾åˆ†æï¼ˆCallGraphVisitorï¼‰
â”œâ”€â”€ EP18: å‡½æ•°è°ƒç”¨æœºåˆ¶å®ç°
â””â”€â”€ âŒ ç¼ºå°‘: è¿‡ç¨‹é—´ä¼˜åŒ–Pass

ç¼ºå¤±çš„å…³é”®æŠ€æœ¯:
â”œâ”€â”€ å‡½æ•°å†…è”ï¼ˆInliningï¼‰
â”‚   â”œâ”€â”€ å†…è”å†³ç­–å¯å‘å¼
â”‚   â”œâ”€â”€ é€’å½’å‡½æ•°å†…è”
â”‚   â”œâ”€â”€ éƒ¨åˆ†å†…è”ï¼ˆPartial Inliningï¼‰
â”‚   â””â”€â”€ å†…è”åä¼˜åŒ–
â”‚
â”œâ”€â”€ è¿‡ç¨‹é—´å¸¸é‡ä¼ æ’­ï¼ˆInterprocedural Constant Propagationï¼‰
â”‚   â”œâ”€â”€ è¿‡ç¨‹é—´æ•°æ®æµåˆ†æ
â”‚   â”œâ”€â”€ è°ƒç”¨ä¸Šä¸‹æ–‡æ•æ„Ÿåˆ†æ
â”‚   â””â”€â”€ è‡ªé¡¶å‘ä¸‹ä¼ æ’­
â”‚
â”œâ”€â”€ è¿‡ç¨‹é—´åˆ«ååˆ†æï¼ˆInterprocedural Alias Analysisï¼‰
â”‚   â”œâ”€â”€ æŒ‡é’ˆåˆ†æ
â”‚   â”œâ”€â”€ å†…å­˜å¯¹è±¡å»ºæ¨¡
â”‚   â””â”€â”€ é€ƒé€¸åˆ†æï¼ˆEscape Analysisï¼‰
â”‚
â”œâ”€â”€ å‡½æ•°ç‰¹åŒ–ï¼ˆFunction Specializationï¼‰
â”‚   â”œâ”€â”€ åŸºäºå¸¸é‡å‚æ•°çš„ç‰¹åŒ–
â”‚   â””â”€â”€ åŸºäºç±»å‹å‚æ•°çš„ç‰¹åŒ–
â”‚
â””â”€â”€ é“¾æ¥æ—¶ä¼˜åŒ–ï¼ˆLink-Time Optimization, LTOï¼‰
    â”œâ”€â”€ è·¨æ¨¡å—ä¼˜åŒ–
    â”œâ”€â”€ å…¨å±€ç¬¦å·å¯è§æ€§åˆ†æ
    â””â”€â”€ å¢é‡LTO
```

#### é¾™ä¹¦è¦†ç›–æƒ…å†µ
- âš ï¸ **ç®€ç•¥è¦†ç›–**: ç¬¬9ç« ç®€è¦æåŠï¼Œæ— è¯¦ç»†ç®—æ³•
- âŒ **ç¼ºå¤±**: ç°ä»£LTOæŠ€æœ¯ï¼ˆ2007å¹´åå‘å±•ï¼‰

#### å®ç°è·¯çº¿

**EP22: è¿‡ç¨‹é—´ä¼˜åŒ–**
```java
// 1. å†…è”å†³ç­–å™¨
public class InlineDecision {
    public boolean shouldInline(FunctionCall call, FunctionDefinition target) {
        // å¯å‘å¼è§„åˆ™
        if (target.getSize() < INLINE_SIZE_LIMIT) return true;
        if (target.isHot() && target.getSize() < HOT_INLINE_LIMIT) return true;
        if (target.isLeaf()) return true;
        return false;
    }
}

// 2. å†…è”Pass
public class InliningPass implements OptimizationPass {
    @Override
    public void optimize(IRProgram program) {
        for (FunctionCall call : program.getFunctionCalls()) {
            if (shouldInline(call)) {
                inlineFunction(call);
            }
        }
    }
}

// 3. é€ƒé€¸åˆ†æ
public class EscapeAnalysis {
    public EscapeState analyze(ObjectAllocation alloc) {
        // NoEscape: å¯¹è±¡ä¸é€ƒé€¸å½“å‰å‡½æ•°
        // ArgEscape: å¯¹è±¡ä½œä¸ºå‚æ•°ä¼ é€’
        // GlobalEscape: å¯¹è±¡é€ƒé€¸åˆ°å…¨å±€
        // ReturnEscape: å¯¹è±¡ä½œä¸ºè¿”å›å€¼
    }
}
```

**é¢„è®¡å·¥ä½œé‡**: 3-4å‘¨
**å‚è€ƒèµ„æ–™**:
- LLVM Inline Cost Analysis
- "Inlining Algorithms for Declarative Programs" (CHI 1993)
- "Escape Analysis for Java" (OOPSLA 1999)

---

### 2. å¾ªç¯ä¼˜åŒ–è¿›é˜¶ï¼ˆAdvanced Loop Optimizationsï¼‰

**é‡è¦ç¨‹åº¦**: â­â­â­â­â­
**å·¥ä¸šåº”ç”¨**: LLVM (LoopPassManager), GCC (-O3 loopä¼˜åŒ–)

#### ç¼ºå¤±å†…å®¹

```
å½“å‰çŠ¶æ€:
â”œâ”€â”€ EP17: æœ‰å¾ªç¯è¯†åˆ«ï¼ˆé€šè¿‡CFGï¼‰
â”œâ”€â”€ EP21: åŸºç¡€æ•°æ®æµåˆ†æ
â””â”€â”€ âŒ ç¼ºå°‘: ä¸“é—¨çš„å¾ªç¯ä¼˜åŒ–Pass

ç¼ºå¤±çš„å…³é”®æŠ€æœ¯:
â”œâ”€â”€ å¾ªç¯ä¸å˜ä»£ç å¤–æï¼ˆLoop-Invariant Code Motion, LICMï¼‰
â”‚   â”œâ”€â”€ è¯†åˆ«å¾ªç¯ä¸å˜è¯­å¥
â”‚   â”œâ”€â”€ å‰ç½®é¦–èŠ‚ç‚¹ï¼ˆPreheaderï¼‰
â”‚   â””â”€â”€ å®‰å…¨æ€§æ£€æŸ¥ï¼ˆå¼‚å¸¸ã€å‰¯ä½œç”¨ï¼‰
â”‚
â”œâ”€â”€ å¾ªç¯å±•å¼€ï¼ˆLoop Unrollingï¼‰
â”‚   â”œâ”€â”€ å®Œå…¨å±•å¼€
â”‚   â”œâ”€â”€ éƒ¨åˆ†å±•å¼€ï¼ˆPartial Unrollingï¼‰
â”‚   â”œâ”€â”€ è¿­ä»£æ¬¡æ•°é¢„æµ‹
â”‚   â””â”€â”€ å±•å¼€åçš„å¯„å­˜å™¨å‹åŠ›
â”‚
â”œâ”€â”€ å¾ªç¯å‘é‡åŒ–ï¼ˆLoop Vectorizationï¼‰
â”‚   â”œâ”€â”€ SIMDæŒ‡ä»¤ç”Ÿæˆ
â”‚   â”œâ”€â”€ ä¾èµ–åˆ†æï¼ˆMemory Dependence Analysisï¼‰
â”‚   â”œâ”€â”€ å¯¹é½å‡è®¾ï¼ˆAlignment Assumptionï¼‰
â”‚   â””â”€â”€ Maskå‘é‡ï¼ˆå¤„ç†å°¾å¾ªç¯ï¼‰
â”‚
â”œâ”€â”€ å¾ªç¯äº¤æ¢ï¼ˆLoop Interchangeï¼‰
â”‚   â”œâ”€â”€ ä¾èµ–å…³ç³»åˆ†æ
â”‚   â”œâ”€â”€ ç¼“å­˜å±€éƒ¨æ€§ä¼˜åŒ–
â”‚   â””â”€â”€ å®Œç¾åµŒå¥—å¾ªç¯è¯†åˆ«
â”‚
â”œâ”€â”€ å¾ªç¯åˆ†å—ï¼ˆLoop Tiling/Blockingï¼‰
â”‚   â”œâ”€â”€ ç¼“å­˜å—å¤§å°è®¡ç®—
â”‚   â”œâ”€â”€ åˆ†å—è¾¹ç•Œå¤„ç†
â”‚   â””â”€â”€ å¤šçº§ç¼“å­˜ä¼˜åŒ–
â”‚
â”œâ”€â”€ å½’çº¦å˜é‡è¯†åˆ«ä¸æ¶ˆé™¤
â”‚   â”œâ”€â”€ å½’çº¦å˜é‡è¯†åˆ«
â”‚   â”œâ”€â”€ å¼ºåº¦å‰Šå¼±ï¼ˆStrength Reductionï¼‰
â”‚   â””â”€â”€ å½’çº¦å˜é‡æ¶ˆé™¤
â”‚
â””â”€â”€ å¾ªç¯ä¸å˜é‡ä¼ æ’­
    â”œâ”€â”€ å¾ªç¯ä¸å˜é‡è¯†åˆ«
    â””â”€â”€ å¾ªç¯é—´å¸¸é‡ä¼ æ’­
```

#### é¾™ä¹¦è¦†ç›–æƒ…å†µ
- â­â­â­ **éƒ¨åˆ†è¦†ç›–**: ç¬¬9.5èŠ‚è¦†ç›–åŸºç¡€å¾ªç¯ä¼˜åŒ–
- âŒ **ç¼ºå¤±**: å‘é‡åŒ–ã€SIMDç”Ÿæˆï¼ˆç°ä»£æŠ€æœ¯ï¼‰

#### å®ç°è·¯çº¿

**EP23: å¾ªç¯ä¼˜åŒ–**
```java
// 1. å¾ªç¯è¯†åˆ«
public class LoopInfo {
    private BasicBlock header;
    private Set<BasicBlock> blocks;
    private Set<BasicBlock> exits;
    private int depth;  // åµŒå¥—æ·±åº¦
}

public class LoopIdentificationPass {
    public List<LoopInfo> identifyLoops(ControlFlowGraph cfg) {
        // ä½¿ç”¨æ”¯é…æ ‘è¯†åˆ«è‡ªç„¶å¾ªç¯
        // å›è¾¹ï¼ˆback edgeï¼‰çš„dest = loop header
    }
}

// 2. LICMå®ç°
public class LICMPass implements OptimizationPass {
    @Override
    public void optimize(IRFunction function) {
        for (LoopInfo loop : function.getLoops()) {
            // ç¬¬1æ­¥: è¯†åˆ«å¾ªç¯ä¸å˜è¯­å¥
            Set<IRInstruction> invariants = identifyInvariants(loop);

            // ç¬¬2æ­¥: æ£€æŸ¥å®‰å…¨æ€§ï¼ˆæ˜¯å¦å¯ä»¥å¤–æï¼‰
            Set<IRInstruction> safeToHoist = checkSafety(invariants);

            // ç¬¬3æ­¥: å¤–æåˆ°preheader
            BasicBlock preheader = createPreheader(loop);
            for (IRInstruction inst : safeToHoist) {
                inst.moveTo(preheader);
            }
        }
    }
}

// 3. å¾ªç¯å±•å¼€
public class LoopUnrollingPass {
    public void unrollLoop(LoopInfo loop, int factor) {
        if (loop.getIterationCount() % factor != 0) {
            // éœ€è¦å¤„ç†å‰©ä½™è¿­ä»£
            createEpilogueLoop(loop, factor);
        }

        // å¤åˆ¶å¾ªç¯ä½“
        for (int i = 1; i < factor; i++) {
            duplicateLoopBody(loop);
        }
    }
}

// 4. ç®€å•å‘é‡åŒ–ï¼ˆ2-wide SIMDï¼‰
public class LoopVectorizationPass {
    public void vectorizeLoop(LoopInfo loop) {
        // æ£€æŸ¥ä¾èµ–
        if (!hasSafeDependencies(loop)) {
            return;
        }

        // ç”Ÿæˆå‘é‡æŒ‡ä»¤
        for (IRInstruction inst : loop.getBody()) {
            if (canVectorize(inst)) {
                // 2ä¸ªæ ‡é‡æ“ä½œ â†’ 1ä¸ªå‘é‡æ“ä½œ
                IRInstruction vectorInst = createVectorInstruction(inst);
                replaceWithVector(inst, vectorInst);
            }
        }
    }
}
```

**é¢„è®¡å·¥ä½œé‡**: 4-5å‘¨
**å‚è€ƒèµ„æ–™**:
- LLVM Loop Optimization Passes
- "Automatic Vectorization of Free-Form SIMD Loops" (PLDI 2004)
- "The Loop Vectorizer in LLVM 3.0" (LLVM DevMeeting 2011)

---

### 3. å†…å­˜ä¼˜åŒ–ï¼ˆMemory Optimizationï¼‰

**é‡è¦ç¨‹åº¦**: â­â­â­â­â­
**å·¥ä¸šåº”ç”¨**: LLVM (MemorySSA), GCC (Alias Analysis)

#### ç¼ºå¤±å†…å®¹

```
å½“å‰çŠ¶æ€:
â”œâ”€â”€ EP18: åŸºç¡€å†…å­˜æ“ä½œï¼ˆIALOAD, IASTOREï¼‰
â”œâ”€â”€ EP21: åŸºç¡€æ•°æ®æµåˆ†æ
â””â”€â”€ âŒ ç¼ºå°‘: ç²¾ç¡®çš„å†…å­˜åˆ†æ

ç¼ºå¤±çš„å…³é”®æŠ€æœ¯:
â”œâ”€â”€ æŒ‡é’ˆåˆ«ååˆ†æï¼ˆPointer Alias Analysisï¼‰
â”‚   â”œâ”€â”€ Andersenç®—æ³•ï¼ˆæµæ•æ„Ÿã€ä¸Šä¸‹æ–‡æ•æ„Ÿï¼‰
â”‚   â”œâ”€â”€ Steensgaardç®—æ³•ï¼ˆæµä¸æ•æ„Ÿã€çº¿æ€§æ—¶é—´ï¼‰
â”‚   â”œâ”€â”€ ç±»å‹å±‚æ¬¡åˆ†æï¼ˆç”¨äºJavaç±»å±‚æ¬¡ï¼‰
â”‚   â””â”€â”€ åœ°å€ç®—å­å»ºæ¨¡
â”‚
â”œâ”€â”€ å†…å­˜ä¾èµ–åˆ†æï¼ˆMemory Dependence Analysisï¼‰
â”‚   â”œâ”€â”€ æ•°ç»„ä¾èµ–åˆ†æ
â”‚   â”‚   â”œâ”€â”€ GCDæµ‹è¯•ï¼ˆBanerjeeä¸ç­‰å¼ï¼‰
â”‚   â”‚   â”œâ”€â”€ æ–¹å‘å‘é‡æµ‹è¯•
â”‚   â”‚   â””â”€â”€ Omegaæµ‹è¯•ï¼ˆç²¾ç¡®ä¾èµ–ï¼‰
â”‚   â”œâ”€â”€ ç»“æ„ä½“å­—æ®µæ•æ„Ÿåˆ†æ
â”‚   â””â”€â”€ è·¨è¯­å¥ä¾èµ–
â”‚
â”œâ”€â”€ MemorySSA
â”‚   â”œâ”€â”€ å†…å­˜ç‰ˆæœ¬ï¼ˆMemory Phiï¼‰
â”‚   â”œâ”€â”€ å†…å­˜ä½¿ç”¨/å®šä¹‰é“¾
â”‚   â””â”€â”€ åŸºäºMemorySSAçš„ä¼˜åŒ–
â”‚
â”œâ”€â”€ æ•°ç»„è®¿é—®ä¼˜åŒ–
â”‚   â”œâ”€â”€ æ•°ç»„æ ‡é‡æ›¿æ¢ï¼ˆScalar Replacement of Arraysï¼‰
â”‚   â”œâ”€â”€ æ•°ç»„åˆå¹¶
â”‚   â””â”€â”€ å¾ªç¯å†…æ•°ç»„å±•å¼€
â”‚
â”œâ”€â”€ ç¼“å­˜æ•æ„Ÿä¼˜åŒ–
â”‚   â”œâ”€â”€ ç¼“å­˜é˜»å¡ï¼ˆCache Blockingï¼‰
â”‚   â”œâ”€â”€ æ•°æ®å¸ƒå±€ä¼˜åŒ–ï¼ˆStructure Splittingï¼‰
â”‚   â”œâ”€â”€ æ•°ç»„åˆå¹¶
â”‚   â””â”€â”€ é¢„å–ä¼˜åŒ–ï¼ˆPrefetchingï¼‰
â”‚
â””â”€â”€ æ­»å­˜å‚¨æ¶ˆé™¤ï¼ˆDead Store Eliminationï¼‰
    â”œâ”€â”€ å®Œå…¨æ­»å­˜å‚¨
    â”œâ”€â”€ éƒ¨åˆ†æ­»å­˜å‚¨
    â””â”€â”€ æ­»å­—æ®µæ¶ˆé™¤
```

#### é¾™ä¹¦è¦†ç›–æƒ…å†µ
- â­â­ **åŸºç¡€è¦†ç›–**: ç¬¬9ç« æåŠæ•°æ®æµåˆ†æ
- âŒ **ä¸¥é‡ç¼ºå¤±**: ç°ä»£åˆ«ååˆ†æã€MemorySSA

#### å®ç°è·¯çº¿

**EP24: å†…å­˜ä¼˜åŒ–**
```java
// 1. ç®€åŒ–çš„åˆ«ååˆ†æ
public class AliasAnalysis {
    public enum AliasResult {
        NoAlias,        // ä¸å¯èƒ½åˆ«å
        MayAlias,       // å¯èƒ½åˆ«å
        MustAlias       // å¿…å®šåˆ«å
    }

    public AliasResult query(MemoryLocation loc1, MemoryLocation loc2) {
        // ç®€å•çš„åŸºäºç±»å‹çš„åˆ†æ
        if (loc1.type != loc2.type) return AliasResult.NoAlias;
        if (loc1.isStack() && loc2.isHeap()) return AliasResult.NoAlias;
        // ...
    }
}

// 2. MemorySSAæ„å»º
public class MemorySSA {
    // ä¸ºæ¯ä¸ªå†…å­˜æ“ä½œæ’å…¥Phi
    public void build(IRFunction function) {
        for (BasicBlock bb : function.getCFG().getBlocks()) {
            if (hasMultipleMemoryPreds(bb)) {
                // æ’å…¥MemoryPhi
                MemoryPhi phi = new MemoryPhi(bb);
                bb.prepend(phi);
            }
        }

        // ä¸ºæ¯ä¸ªå†…å­˜æ“ä½œå‘½å
        for (IRInstruction inst : function.getMemoryInstructions()) {
            inst.setMemoryDef(getReachingDef(inst));
        }
    }
}

// 3. æ•°ç»„ä¾èµ–åˆ†æ
public class ArrayDependenceAnalysis {
    public DependenceResult analyze(ArrayAccess access1, ArrayAccess access2) {
        // æå–è®¿é—®å‡½æ•°: a[i] = f(i) = i
        AccessFunction f1 = extractAccessFunction(access1);  // i
        AccessFunction f2 = extractAccessFunction(access2);  // i+1

        // GCDæµ‹è¯•
        int gcd = gcd(f1.getCoeff(), f2.getCoeff());
        if ((f2.getConst() - f1.getConst()) % gcd != 0) {
            return DependenceResult.NoDependence;
        }

        // æ–¹å‘å‘é‡æµ‹è¯•
        DirectionVector dir = computeDirection(f1, f2);
        return new DependenceResult(true, dir);
    }
}
```

**é¢„è®¡å·¥ä½œé‡**: 4-5å‘¨
**å‚è€ƒèµ„æ–™**:
- LLVM Memory Dep Analysis
- "Memory Alias Analysis using Type Lattices" (PLDI 2001)
- "The Omega Test: a fast and practical integer programming algorithm" (TOPLAS 1992)

---

### 4. å¯„å­˜å™¨åˆ†é…è¿›é˜¶ï¼ˆAdvanced Register Allocationï¼‰

**é‡è¦ç¨‹åº¦**: â­â­â­â­
**å·¥ä¸šåº”ç”¨**: LLVM (Greedy RA), GCC (IRA)

#### ç¼ºå¤±å†…å®¹

```
å½“å‰çŠ¶æ€:
â”œâ”€â”€ EP18R: å¯„å­˜å™¨VMï¼ˆç®€å•è™šæ‹Ÿå¯„å­˜å™¨ï¼‰
â”œâ”€â”€ EP21: æ´»è·ƒå˜é‡åˆ†æ
â””â”€â”€ âŒ ç¼ºå°‘: çœŸå®çš„å¯„å­˜å™¨åˆ†é…ç®—æ³•

ç¼ºå¤±çš„å…³é”®æŠ€æœ¯:
â”œâ”€â”€ å›¾ç€è‰²å¯„å­˜å™¨åˆ†é…ï¼ˆGraph Coloring Register Allocationï¼‰
â”‚   â”œâ”€â”€ å¯„å­˜å™¨å¹²æ‰°å›¾æ„å»ºï¼ˆInterference Graphï¼‰
â”‚   â”œâ”€â”€ å›¾ç€è‰²ç®—æ³•
â”‚   â”‚   â”œâ”€â”€ ç®€åŒ–ï¼ˆSimplificationï¼‰
â”‚   â”‚   â”œâ”€â”€ å†’é™©ï¼ˆSpillï¼‰
â”‚   â”‚   â”œâ”€â”€ é€‰æ‹©ï¼ˆSelectï¼‰
â”‚   â”‚   â””â”€â”€ é‡æ–°ç€è‰²ï¼ˆCoalescingï¼‰
â”‚   â”œâ”€â”€ è¿­ä»£åˆå¹¶ï¼ˆIterative Coalescingï¼‰
â”‚   â””â”€â”€ ä¼˜å…ˆç€è‰²ï¼ˆPriority Coloringï¼‰
â”‚
â”œâ”€â”€ çº¿æ€§æ‰«æå¯„å­˜å™¨åˆ†é…ï¼ˆLinear Scan Register Allocationï¼‰
â”‚   â”œâ”€â”€ å¿«é€Ÿåˆ†é…ï¼ˆO(n log n)ï¼‰
â”‚   â”œâ”€â”€ é€‚åˆJITç¼–è¯‘å™¨
â”‚   â””â”€â”€ æ´»è·ƒåŒºé—´ï¼ˆLive Intervalsï¼‰
â”‚
â”œâ”€â”€ å¯„å­˜å™¨å‹åŠ›ä¼°è®¡
â”‚   â”œâ”€â”€ è®¡ç®—å¯„å­˜å™¨éœ€æ±‚
â”‚   â”œâ”€â”€ æº¢å‡ºä»£ä»·ä¼°è®¡
â”‚   â””â”€â”€ é‡æ’åºæŒ‡ä»¤é™ä½å‹åŠ›
â”‚
â””â”€â”€ ç‰¹æ®Šå¯„å­˜å™¨å¤„ç†
    â”œâ”€â”€ ç‰©ç†å¯„å­˜å™¨çº¦æŸï¼ˆx86: RAX, RBX, ...ï¼‰
    â”œâ”€â”€ è°ƒç”¨çº¦å®šï¼ˆCaller-save vs Callee-saveï¼‰
    â””â”€â”€ å¯„å­˜å™¨ç±»ï¼ˆRegister Classï¼‰
```

#### é¾™ä¹¦è¦†ç›–æƒ…å†µ
- â­â­â­ **æœ‰è¦†ç›–**: ç¬¬8ç« æœ‰å›¾ç€è‰²ç®—æ³•
- âš ï¸ **è¿‡æ—¶**: ç¼ºå°‘ç°ä»£ç®—æ³•ï¼ˆè¿­ä»£åˆå¹¶ã€çº¿æ€§æ‰«æï¼‰

#### å®ç°è·¯çº¿

**EP25: å¯„å­˜å™¨åˆ†é…**
```java
// 1. å¹²æ‰°å›¾æ„å»º
public class InterferenceGraph {
    private Map<VirtualRegister, Set<VirtualRegister>> edges;

    public void build(IRFunction function) {
        LivenessAnalysis live = new LivenessAnalysis();
        LiveVariableInfo liveness = live.analyze(function);

        // ä¸ºæ¯ä¸ªæŒ‡ä»¤æ·»åŠ è¾¹
        for (IRInstruction inst : function.getInstructions()) {
            Set<VirtualRegister> liveVars = liveness.getLiveAfter(inst);

            // æ‰€æœ‰liveçš„å¯„å­˜å™¨äº’ç›¸å¹²æ‰°
            for (VirtualRegister r1 : liveVars) {
                for (VirtualRegister r2 : liveVars) {
                    if (r1 != r2) {
                        addEdge(r1, r2);
                    }
                }
            }
        }
    }
}

// 2. å›¾ç€è‰²åˆ†é…
public class GraphColoringAllocator {
    public void allocate(InterferenceGraph ig, int k) {
        // k = å¯ç”¨ç‰©ç†å¯„å­˜å™¨æ•°é‡

        Stack<VirtualRegister> stack = new Stack<>();

        // ç®€åŒ–é˜¶æ®µ
        while (ig.hasNodes()) {
            VirtualRegister reg = ig.findNodeWithDegreeLessThan(k);
            if (reg != null) {
                // å¯ä»¥ç§»é™¤
                ig.removeNode(reg);
                stack.push(reg);
            } else {
                // éœ€è¦æº¢å‡º
                VirtualRegister spill = selectSpillCandidate(ig);
                ig.removeNode(spill);
                stack.push(spill);
            }
        }

        // é€‰æ‹©é˜¶æ®µ
        while (!stack.isEmpty()) {
            VirtualRegister reg = stack.pop();
            ig.addNode(reg);

            PhysicalRegister color = selectColor(ig, reg, k);
            if (color != null) {
                reg.assignPhysicalRegister(color);
            } else {
                // æº¢å‡ºåˆ°æ ˆ
                spillRegister(reg);
            }
        }
    }
}

// 3. çº¿æ€§æ‰«æåˆ†é…ï¼ˆJITå‹å¥½ï¼‰
public class LinearScanAllocator {
    public void allocate(List<LiveInterval> intervals, int k) {
        // æŒ‰èµ·å§‹æ—¶é—´æ’åº
        intervals.sort(Comparator.comparing(LiveInterval::getStart));

        Set<PhysicalRegister> free = new HashSet<>();
        List<LiveInterval> active = new ArrayList<>();

        for (LiveInterval interval : intervals) {
            // ç»“æŸçš„åŒºé—´é‡Šæ”¾å¯„å­˜å™¨
            active.removeIf(i -> i.getEnd() < interval.getStart());
            free.addAll(getReleasedRegisters(active));

            if (free.size() > 0) {
                // åˆ†é…å¯„å­˜å™¨
                interval.assignRegister(free.iterator().next());
                active.add(interval);
            } else {
                // éœ€è¦æº¢å‡º
                LiveInterval toSpill = findSpillCandidate(active, interval);
                if (toSpill != null) {
                    spillInterval(toSpill);
                    active.remove(toSpill);
                    interval.assignRegister(toSpill.getRegister());
                    active.add(interval);
                } else {
                    spillInterval(interval);
                }
            }
        }
    }
}
```

**é¢„è®¡å·¥ä½œé‡**: 3-4å‘¨
**å‚è€ƒèµ„æ–™**:
- "Register Allocation for Irregular Architectures" (MIT 2002)
- "Linear Scan Register Allocation" (PLDI 1999)
- "Iterated Register Coalescing" (TOPLAS 1996)

---

### 5. SSAé«˜çº§ä¼˜åŒ–ï¼ˆAdvanced SSA Optimizationsï¼‰

**é‡è¦ç¨‹åº¦**: â­â­â­â­
**å·¥ä¸šåº”ç”¨**: LLVM (SSA-based optimizations), GCC (Tree SSA)

#### ç¼ºå¤±å†…å®¹

```
å½“å‰çŠ¶æ€:
â”œâ”€â”€ EP12: SSAæ„å»ºï¼ˆCytronç®—æ³•ï¼‰
â”œâ”€â”€ EP21: åŸºç¡€ä¼˜åŒ–
â””â”€â”€ âŒ ç¼ºå°‘: SSAç‰¹æœ‰ä¼˜åŒ–

ç¼ºå¤±çš„å…³é”®æŠ€æœ¯:
â”œâ”€â”€ ç¨€ç–æ¡ä»¶å¸¸é‡ä¼ æ’­ï¼ˆSparse Conditional Constant Propagation, SCCPï¼‰
â”‚   â”œâ”€â”€ å·¥è¡¨åˆ—è¡¨ç®—æ³•ï¼ˆWorklist Algorithmï¼‰
â”‚   â”œâ”€â”€ æ¡ä»¶åˆ†æ”¯å¸¸é‡åŒ–
â”‚   â”œâ”€â”€ æ­»ä»£ç æ£€æµ‹
â”‚   â””â”€â”€ SSAä¸Šçš„ç¨€ç–ä¼ æ’­
â”‚
â”œâ”€â”€ å…¨å±€å€¼ç¼–å·ï¼ˆGlobal Value Numbering, GVNï¼‰
â”‚   â”œâ”€â”€ å€¼ç¼–å·ï¼ˆValue Numberingï¼‰
â”‚   â”œâ”€â”€ å¯ç”¨è¡¨è¾¾å¼è®¡ç®—
â”‚   â”œâ”€â”€ å†—ä½™æ¶ˆé™¤
â”‚   â””â”€â”€ å†…å­˜SSAä¸Šçš„GVN
â”‚
â”œâ”€â”€ æ­»å­˜å‚¨æ¶ˆé™¤å¢å¼ºï¼ˆEnhanced Dead Store Eliminationï¼‰
â”‚   â”œâ”€â”€ éƒ¨åˆ†å†—ä½™æ¶ˆé™¤ï¼ˆPartial Redundancy Eliminationï¼‰
â”‚   â”œâ”€â”€ æ‡’æƒ°ä»£ç è¿åŠ¨ï¼ˆLazy Code Motion, LCMï¼‰
â”‚   â””â”€â”€ éå¸¸é‡ä¼ æ’­çš„æ¶ˆé™¤
â”‚
â”œâ”€â”€ ååºå‡å°‘ï¼ˆPartial Redundancy Elimination, PREï¼‰
â”‚   â”œâ”€â”€ å®Œå…¨å†—ä½™æ¶ˆé™¤
â”‚   â”œâ”€â”€ éƒ¨åˆ†å†—ä½™æ¶ˆé™¤
â”‚   â””â”€â”€ æ‡’æƒ°ä»£ç è¿åŠ¨
â”‚
â””â”€â”€ å¼ºåº¦å‰Šå¼±ï¼ˆStrength Reductionï¼‰
    â”œâ”€â”€ å½’çº³å˜é‡è¯†åˆ«
    â”œâ”€â”€ å¼ºåº¦å‰Šå¼±è§„åˆ™
    â”œâ”€â”€ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  x * 2  â†’  x << 1          â”‚
    â”‚  x * 4  â†’  x << 2          â”‚
    â”‚  x ^ 2  â†’  x * x           â”‚
    â”‚  x / 2  â†’  x >> 1          â”‚
    â”‚  x % 2  â†’  x & 1           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### é¾™ä¹¦è¦†ç›–æƒ…å†µ
- â­â­ **éƒ¨åˆ†è¦†ç›–**: ç¬¬9.3èŠ‚å¸¸é‡ä¼ æ’­
- âŒ **ä¸¥é‡ç¼ºå¤±**: SCCPã€GVNã€PRE

#### å®ç°è·¯çº¿

**EP26: SSAé«˜çº§ä¼˜åŒ–**
```java
// 1. ç¨€ç–æ¡ä»¶å¸¸é‡ä¼ æ’­
public class SCCP implements OptimizationPass {
    @Override
    public void optimize(IRFunction function) {
        // åˆå§‹åŒ–ï¼šæ‰€æœ‰å€¼æœªå®šä¹‰
        Map<SSAValue, LatticeElement> lattice = new HashMap<>();

        // å·¥è¡¨ç®—æ³•
        Worklist worklist = new Worklist();
        worklist.addAll(function.getSSAInstructions());

        while (!worklist.isEmpty()) {
            SSAInstruction inst = worklist.take();

            // è¯„ä¼°æŒ‡ä»¤
            LatticeElement oldValue = lattice.get(inst.getDef());
            LatticeElement newValue = evaluate(inst, lattice);

            // å¦‚æœå€¼æ”¹å˜ï¼ŒåŠ å…¥ä½¿ç”¨è€…çš„å·¥è¡¨
            if (!newValue.equals(oldValue)) {
                lattice.put(inst.getDef(), newValue);
                for (SSAInstruction use : inst.getUses()) {
                    worklist.add(use);
                }
            }
        }

        // æ›¿æ¢å¸¸é‡
        replaceConstants(function, lattice);

        // åˆ é™¤ä¸å¯è¾¾ä»£ç 
        removeUnreachableCode(function, lattice);
    }
}

// 2. å…¨å±€å€¼ç¼–å·
public class GVN implements OptimizationPass {
    @Override
    public void optimize(IRFunction function) {
        // ä¸ºæ¯ä¸ªè®¡ç®—å€¼åˆ†é…ç¼–å·
        Map<Object, Integer> valueNumbers = new HashMap<>();
        int nextNumber = 1;

        for (SSAInstruction inst : function.getSSAInstructions()) {
            if (inst.isComputation()) {
                // è®¡ç®—å€¼çš„å“ˆå¸Œ
                ValueHash hash = computeValueHash(inst, valueNumbers);

                // æŸ¥æ‰¾å·²æœ‰ç¼–å·
                if (valueNumbers.containsKey(hash)) {
                    int number = valueNumbers.get(hash);

                    // ç”¨å·²æœ‰çš„å€¼æ›¿æ¢
                    SSAValue replacement = findValueByNumber(number);
                    inst.getDef().replaceWith(replacement);
                } else {
                    // åˆ†é…æ–°ç¼–å·
                    valueNumbers.put(hash, nextNumber);
                    inst.getDef().setValueNumber(nextNumber);
                    nextNumber++;
                }
            }
        }
    }
}

// 3. å¼ºåº¦å‰Šå¼±
public class StrengthReductionPass {
    private static final Map<OpCode, OpCode> STRENGTH_RULES = Map.of(
        OpCode.IMUL, OpCode.SHL,  // *2 â†’ <<1
        OpCode.IDIV, OpCode.SHR,  // /2 â†’ >>1
        OpCode.IMOD, OpCode.AND   // %2 â†’ &1
    );

    @Override
    public void optimize(IRFunction function) {
        for (IRInstruction inst : function.getInstructions()) {
            if (isMultiplicationByPowerOfTwo(inst)) {
                // x * 2^n â†’ x << n
                transformToShift(inst);
            } else if (isDivisionByPowerOfTwo(inst)) {
                // x / 2^n â†’ x >> n
                transformToRightShift(inst);
            } else if (isModuloByPowerOfTwo(inst)) {
                // x % 2^n â†’ x & (2^n - 1)
                transformToAnd(inst);
            }
        }
    }
}
```

**é¢„è®¡å·¥ä½œé‡**: 3-4å‘¨
**å‚è€ƒèµ„æ–™**:
- "Sparse Conditional Constant Propagation" (TOPLAS 1988)
- "Global Value Numbering: A New Framework" (2003)
- "Lazy Code Motion" (PLDI 1992)

---

### 6. ç‰¹å®šé¢†åŸŸä¼˜åŒ–ï¼ˆDomain-Specific Optimizationsï¼‰

**é‡è¦ç¨‹åº¦**: â­â­â­
**å·¥ä¸šåº”ç”¨**: GCC (vectorization), LLVM (Auto-vectorization)

#### ç¼ºå¤±å†…å®¹

```
å½“å‰çŠ¶æ€:
â”œâ”€â”€ EP21: é€šç”¨ä¼˜åŒ–Pass
â””â”€â”€ âŒ ç¼ºå°‘: ç‰¹å®šè¯­è¨€çš„ä¼˜åŒ–

ç¼ºå¤±çš„å…³é”®æŠ€æœ¯:
â”œâ”€â”€ SIMDå‘é‡åŒ–
â”‚   â”œâ”€â”€ SLPçŸ¢é‡åŒ–ï¼ˆSuperword Level Parallelismï¼‰
â”‚   â”œâ”€â”€ å¾ªç¯å‘é‡åŒ–
â”‚   â”œâ”€â”€ å‘é‡é•¿åº¦é€‰æ‹©
â”‚   â””â”€â”€ SIMDæŒ‡ä»¤ç”Ÿæˆ
â”‚
â”œâ”€â”€ GPU/HWåŠ é€Ÿå™¨ä¼˜åŒ–
â”‚   â”œâ”€â”€ OpenCLä»£ç ç”Ÿæˆ
â”‚   â”œâ”€â”€ CUDAä»£ç ç”Ÿæˆ
â”‚   â””â”€â”€ å¼‚æ„è®¡ç®—
â”‚
â”œâ”€â”€ å­—ç¬¦ä¸²ä¼˜åŒ–
â”‚   â”œâ”€â”€ å­—ç¬¦ä¸²è¿æ¥ä¼˜åŒ–
â”‚   â”œâ”€â”€ æ­£åˆ™è¡¨è¾¾å¼ä¼˜åŒ–
â”‚   â””â”€â”€ å­—ç¬¦ä¸²å­—é¢é‡æ± åŒ–
â”‚
â””â”€â”€ å®¹å™¨ä¼˜åŒ–
    â”œâ”€â”€ List/Arrayä¼˜åŒ–
    â”œâ”€â”€ Map/Setä¼˜åŒ–
    â””â”€â”€ è¿­ä»£å™¨ä¼˜åŒ–
```

#### é¾™ä¹¦è¦†ç›–æƒ…å†µ
- âŒ **å®Œå…¨ç¼ºå¤±**: ç‰¹å®šé¢†åŸŸä¼˜åŒ–

#### å®ç°è·¯çº¿

**EP27: ç‰¹å®šé¢†åŸŸä¼˜åŒ–**
```java
// 1. SLPå‘é‡åŒ–
public class SLPVectorizer {
    public void vectorizeBasicBlock(BasicBlock bb) {
        // å¯»æ‰¾è¿ç»­çš„ç›¸ä¼¼æ“ä½œ
        List<List<IRInstruction>> bundles = bundleSimilarInstructions(bb);

        for (List<IRInstruction> bundle : bundles) {
            if (bundle.size() >= VECTOR_WIDTH) {
                // ç”Ÿæˆå‘é‡æ“ä½œ
                IRInstruction vectorInst = createVectorInstruction(bundle);
                replaceWithVector(bundle, vectorInst);
            }
        }
    }
}

// 2. å­—ç¬¦ä¸²è¿æ¥ä¼˜åŒ–
public class StringConcatenationOptimizer {
    public void optimize(IRFunction function) {
        for (IRInstruction inst : function.getInstructions()) {
            if (isStringConcat(inst)) {
                // s1 + s2 + s3 â†’ StringBuilder.append(s1).append(s2).append(s3)
                transformToStringBuilder(inst);
            }
        }
    }
}
```

**é¢„è®¡å·¥ä½œé‡**: 2-3å‘¨ï¼ˆç‰¹å®šé¢†åŸŸï¼‰

---

### 7. è‡ªé€‚åº”ä¼˜åŒ–ä¸åŠ¨æ€ç¼–è¯‘ï¼ˆAdaptive Optimization & JITï¼‰

**é‡è¦ç¨‹åº¦**: â­â­â­â­
**å·¥ä¸šåº”ç”¨**: V8 (TurboFan), HotSpot JVM (C2), LuaJIT

#### ç¼ºå¤±å†…å®¹

```
å½“å‰çŠ¶æ€:
â”œâ”€â”€ EP18: æ ˆå¼VMè§£é‡Šå™¨
â”œâ”€â”€ EP20: é™æ€ç¼–è¯‘å™¨
â””â”€â”€ âŒ ç¼ºå°‘: JITç¼–è¯‘å™¨

ç¼ºå¤±çš„å…³é”®æŠ€æœ¯:
â”œâ”€â”€ è§£é‡Šå™¨â†’JITåˆ‡æ¢æœºåˆ¶
â”‚   â”œâ”€â”€ çƒ­ç‚¹æ£€æµ‹ï¼ˆHot Spot Detectionï¼‰
â”‚   â”œâ”€â”€ OSRï¼ˆOn-Stack Replacementï¼‰
â”‚   â””â”€â”€ å»ä¼˜åŒ–ï¼ˆDeoptimizationï¼‰
â”‚
â”œâ”€â”€ åˆ†å±‚ç¼–è¯‘ï¼ˆTiered Compilationï¼‰
â”‚   â”œâ”€â”€ è§£é‡Šå™¨
â”‚   â”œâ”€â”€ ä½çº§JITï¼ˆå¿«é€Ÿç”Ÿæˆï¼‰
â”‚   â”œâ”€â”€ é«˜çº§JITï¼ˆä¼˜åŒ–ï¼‰
â”‚   â””â”€â”€ ç¼–è¯‘é˜ˆå€¼ç®¡ç†
â”‚
â”œâ”€â”€ åŠ¨æ€ç±»å‹ç‰¹åŒ–
â”‚   â”œâ”€â”€ ç±»å‹åé¦ˆï¼ˆType Feedbackï¼‰
â”‚   â”œâ”€â”€ ç±»å‹æ¨æµ‹ï¼ˆType Speculationï¼‰
â”‚   â”œâ”€â”€ å®ˆå«ï¼ˆGuardï¼‰
â”‚   â””â”€â”€ å»ä¼˜åŒ–è·¯å¾„
â”‚
â”œâ”€â”€ å†…è”ç¼“å­˜ï¼ˆInline Cache, ICï¼‰
â”‚   â”œâ”€â”€ å•æ€å†…è”ç¼“å­˜ï¼ˆMonomorphic ICï¼‰
â”‚   â”œâ”€â”€ å¤šæ€å†…è”ç¼“å­˜ï¼ˆPolymorphic ICï¼‰
â”‚   â”œâ”€â”€ è¶…æ€å†…è”ç¼“å­˜ï¼ˆMegamorphic ICï¼‰
â”‚   â””â”€â”€ ICæ›´æ–°
â”‚
â”œâ”€â”€ æ¦‚ç‡profiling
â”‚   â”œâ”€â”€ è¾¹profilingï¼ˆEdge Profilingï¼‰
â”‚   â”œâ”€â”€ åŸºæœ¬å—è®¡æ•°
â”‚   â””â”€â”€ ç±»å‹profiling
â”‚
â””â”€â”€ é€ƒé€¸åˆ†æ+æ ‡é‡æ›¿æ¢
    â”œâ”€â”€ å¯¹è±¡åˆ†é…é€ƒé€¸åˆ†æ
    â”œâ”€â”€ æ ‡é‡æ›¿æ¢ï¼ˆScalar Replacementï¼‰
    â””â”€â”€ æ ˆåˆ†é…ä¼˜åŒ–
```

#### é¾™ä¹¦è¦†ç›–æƒ…å†µ
- âŒ **å®Œå…¨ç¼ºå¤±**: JITå’Œè‡ªé€‚åº”ä¼˜åŒ–ï¼ˆ2007å¹´åæˆç†Ÿï¼‰

#### å®ç°è·¯çº¿

**EP28: JITç¼–è¯‘å™¨**
```java
// 1. çƒ­ç‚¹æ£€æµ‹
public class HotSpotDetector {
    private Map<IRFunction, Integer> executionCount = new HashMap<>();
    private static final int COMPILATION_THRESHOLD = 10000;

    public void recordExecution(IRFunction function) {
        int count = executionCount.getOrDefault(function, 0) + 1;
        executionCount.put(function, count);

        if (count >= COMPILATION_THRESHOLD) {
            triggerJITCompilation(function);
        }
    }
}

// 2. ç®€å•çš„JITç¼–è¯‘å™¨
public class JITCompiler {
    public NativeCode compile(IRFunction function) {
        // ç¬¬1æ­¥: ç±»å‹ç‰¹åŒ–
        TypeSpecialization types = collectTypeFeedback(function);
        IRFunction specialized = specializeForTypes(function, types);

        // ç¬¬2æ­¥: å†…è”çƒ­ç‚¹å‡½æ•°
        InliningPass inliner = new InliningPass();
        inliner.optimize(specialized);

        // ç¬¬3æ­¥: ä¼˜åŒ–
        OptimizationPipeline pipeline = new OptimizationPipeline();
        pipeline.addPass(new SCCP());
        pipeline.addPass(new GVN());
        pipeline.addPass(new LICM());
        pipeline.optimize(specialized);

        // ç¬¬4æ­¥: ç”Ÿæˆæœ¬æœºä»£ç 
        CodeGenerator codegen = new CodeGenerator();
        return codegen.generate(specialized);
    }
}

// 3. å†…è”ç¼“å­˜
public class InlineCache {
    private static final int IC_SIZE = 3;
    private Entry[] cache = new Entry[IC_SIZE];

    public Object dispatch(Object receiver, String methodName) {
        // æŸ¥æ‰¾ç¼“å­˜
        for (int i = 0; i < IC_SIZE; i++) {
            Entry entry = cache[i];
            if (entry != null && entry.type == receiver.getClass()) {
                // ç¼“å­˜å‘½ä¸­
                return entry.method.invoke(receiver);
            }
        }

        // ç¼“å­˜æœªå‘½ä¸­
        Method method = receiver.getClass().getMethod(methodName);
        updateCache(receiver.getClass(), method);
        return method.invoke(receiver);
    }
}

// 4. OSRï¼ˆOn-Stack Replacementï¼‰
public class OnStackReplacement {
    public void replaceStack(Frame interpretedFrame, CompiledFunction compiled) {
        // ä»è§£é‡Šå™¨æ ˆè¿ç§»åˆ°ç¼–è¯‘ä»£ç æ ˆ
        Map<SSAValue, Object> values = extractLiveValues(interpretedFrame);

        // åˆ›å»ºç¼–è¯‘ç‰ˆæœ¬çš„æ ˆå¸§
        Frame compiledFrame = compiled.createFrame();
        transferValues(values, compiledFrame);

        // åˆ‡æ¢æ‰§è¡Œ
        compiledFrame.execute();
    }
}
```

**é¢„è®¡å·¥ä½œé‡**: 5-6å‘¨ï¼ˆJITæ˜¯ç‹¬ç«‹å¤§é¡¹ç›®ï¼‰
**å‚è€ƒèµ„æ–™**:
- "HotSpot JVM Architecture" (Oracle)
- "V8 TurboFan Optimizing Compiler" (V8 blog)
- "LuaJIT 2.0 Architecture" (LuaJIT wiki)

---

### 8. ç°ä»£å…ƒå¾ªç¯ä¼˜åŒ–ï¼ˆModern Meta-Circular Optimizationsï¼‰

**é‡è¦ç¨‹åº¦**: â­â­â­
**å·¥ä¸šåº”ç”¨**: PyPy, Truffle, GraalVM

#### ç¼ºå¤±å†…å®¹

```
å½“å‰çŠ¶æ€:
â”œâ”€â”€ EP18: è™šæ‹Ÿæœºå®ç°
â””â”€â”€ âŒ ç¼ºå°‘: å…ƒå¾ªç¯å’ŒTruffleæ¡†æ¶

ç¼ºå¤±çš„å…³é”®æŠ€æœ¯:
â”œâ”€â”€ éƒ¨åˆ†æ±‚å€¼ï¼ˆPartial Evaluationï¼‰
â”‚   â”œâ”€â”€ ç¦»çº¿éƒ¨åˆ†æ±‚å€¼
â”‚   â”œâ”€â”€ åœ¨çº¿éƒ¨åˆ†æ±‚å€¼
â”‚   â”œâ”€â”€ ç»‘å®šæ—¶é—´åˆ†æï¼ˆBTAï¼‰
â”‚   â””â”€â”€ FutamuraæŠ•å½±ï¼ˆSelf-Applicable Partial Evaluationï¼‰
â”‚
â”œâ”€â”€ Truffleæ¡†æ¶
â”‚   â”œâ”€â”€ ASTè§£é‡Šå™¨
â”‚   â”œâ”€â”€ èŠ‚ç‚¹é‡å†™ï¼ˆNode Rewritingï¼‰
â”‚   â”œâ”€â”€ èŠ‚ç‚¹å†…è”ï¼ˆNode Inliningï¼‰
â”‚   â””â”€â”€ è°ƒç”¨è¾¹è®¡æ•°
â”‚
â””â”€â”€ GraalVMç¼–è¯‘å™¨æ¥å£
    â”œâ”€â”€ Truffleåˆ°Graalçš„æ¥å£
    â”œâ”€â”€ å¤šè¯­è¨€äº’æ“ä½œ
    â””â”€â”€ Polyglotè¿è¡Œæ—¶
```

#### é¾™ä¹¦è¦†ç›–æƒ…å†µ
- âŒ **å®Œå…¨ç¼ºå¤±**: å…ƒå¾ªç¯ä¼˜åŒ–

#### å®ç°è·¯çº¿

**EP29: å…ƒå¾ªç¯ä¼˜åŒ–ï¼ˆé«˜é˜¶è¿›é˜¶ï¼‰**
```java
// 1. ç®€å•çš„éƒ¨åˆ†æ±‚å€¼å™¨
public class PartialEvaluator {
    public IRFunction specialize(IRFunction function, Map<String, Constant> knownValues) {
        for (IRInstruction inst : function.getInstructions()) {
            if (isStatic(inst, knownValues)) {
                // å¯ä»¥é™æ€æ±‚å€¼
                Constant result = evaluateStatic(inst, knownValues);
                replaceWithConstant(inst, result);
            } else if (isPartiallyStatic(inst, knownValues)) {
                // éƒ¨åˆ†æ±‚å€¼
                IRInstruction specialized = specializePartial(inst, knownValues);
                inst.replaceWith(specialized);
            }
            // å¦åˆ™ä¿æŒåŠ¨æ€
        }

        return function;
    }
}

// 2. Truffleé£æ ¼çš„èŠ‚ç‚¹
public abstract class TruffleNode {
    // æ‰§è¡ŒèŠ‚ç‚¹
    public abstract Object execute(VirtualFrame frame);

    // èŠ‚ç‚¹ç‰¹åŒ–
    public void specialize(Class<?> type) {
        // èŠ‚ç‚¹é‡å†™
    }
}

// åŠ æ³•èŠ‚ç‚¹çš„ç‰¹åŒ–
public class AddNode extends TruffleNode {
    private Object left;
    private Object right;

    @Override
    public Object execute(VirtualFrame frame) {
        Object l = left.execute(frame);
        Object r = right.execute(frame);

        // æ ¹æ®ç±»å‹ç‰¹åŒ–
        if (l instanceof Integer && r instanceof Integer) {
            replace(new IntAddNode());  // èŠ‚ç‚¹é‡å†™
            return ((Integer) l) + ((Integer) r);
        }

        // é€šç”¨è·¯å¾„
        return genericAdd(l, r);
    }
}
```

**é¢„è®¡å·¥ä½œé‡**: 4-5å‘¨
**å‚è€ƒèµ„æ–™**:
- "Self-Applicable Partial Evaluation" (1993)
- "Truffle: A Simple Approach to Implementing Languages" (2013)
- GraalVM Documentation

---

## ğŸ“Š ä¼˜å…ˆçº§ä¸æ—¶é—´è§„åˆ’

### é«˜ä¼˜å…ˆçº§ï¼ˆå¿…å­¦ï¼Œå·¥ä¸šå¿…å¤‡ï¼‰

| ä¼˜åŒ–æŠ€æœ¯ | é‡è¦åº¦ | å·¥ä½œé‡ | EPç¼–å· | ç†è®ºæ¥æº |
|---------|--------|--------|--------|---------|
| **è¿‡ç¨‹é—´ä¼˜åŒ–** | â­â­â­â­â­ | 3-4å‘¨ | EP22 | LLVM IPOè®ºæ–‡ |
| **å¾ªç¯ä¼˜åŒ–** | â­â­â­â­â­ | 4-5å‘¨ | EP23 | ä¼ ç»Ÿä¼˜åŒ–æ–‡çŒ® |
| **å†…å­˜ä¼˜åŒ–** | â­â­â­â­â­ | 4-5å‘¨ | EP24 | LLVM MemSSA |
| **å¯„å­˜å™¨åˆ†é…** | â­â­â­â­ | 3-4å‘¨ | EP25 | é¾™ä¹¦Ch8+ç°ä»£è®ºæ–‡ |

### ä¸­ä¼˜å…ˆçº§ï¼ˆé«˜é˜¶è¿›é˜¶ï¼‰

| ä¼˜åŒ–æŠ€æœ¯ | é‡è¦åº¦ | å·¥ä½œé‡ | EPç¼–å· | ç†è®ºæ¥æº |
|---------|--------|--------|--------|---------|
| **SSAé«˜çº§ä¼˜åŒ–** | â­â­â­â­ | 3-4å‘¨ | EP26 | SCCP/GVNè®ºæ–‡ |
| **ç‰¹å®šé¢†åŸŸä¼˜åŒ–** | â­â­â­ | 2-3å‘¨ | EP27 | SIMDæ–‡çŒ® |

### ä½ä¼˜å…ˆçº§ï¼ˆç ”ç©¶å‰æ²¿ï¼‰

| ä¼˜åŒ–æŠ€æœ¯ | é‡è¦åº¦ | å·¥ä½œé‡ | EPç¼–å· | ç†è®ºæ¥æº |
|---------|--------|--------|--------|---------|
| **JITç¼–è¯‘** | â­â­â­â­ | 5-6å‘¨ | EP28 | V8/HotSpotæ–‡æ¡£ |
| **å…ƒå¾ªç¯ä¼˜åŒ–** | â­â­â­ | 4-5å‘¨ | EP29 | Truffleè®ºæ–‡ |

---

## ğŸ“š æ¨èè¡¥å……é˜…è¯»

### è¶…è¶Šé¾™ä¹¦çš„ç°ä»£èµ„æº

| ä¸»é¢˜ | è¶…è¶Šé¾™ä¹¦çš„å†…å®¹ | æ¨èèµ„æº |
|------|---------------|---------|
| **è¿‡ç¨‹é—´ä¼˜åŒ–** | ç°ä»£LTOã€ä¸Šä¸‹æ–‡æ•æ„Ÿåˆ†æ | LLVM IPOæ–‡æ¡£ã€GCC LTO |
| **SSA** | å†…å­˜SSAã€SSAé«˜çº§ä¼˜åŒ– | "SSA-based Compiler Design" |
| **å¾ªç¯ä¼˜åŒ–** | å‘é‡åŒ–ã€å¤šé¢ä½“æ¨¡å‹ | "Polyhedral Compilation" |
| **å†…å­˜åˆ†æ** | é€ƒé€¸åˆ†æã€åˆ«ååˆ†æ | "Alias Analysis for Object-Oriented Languages" |
| **JIT** | åˆ†å±‚ç¼–è¯‘ã€è‡ªé€‚åº”ä¼˜åŒ– | V8 TurboFanã€HotSpot C2 |
| **Truffle** | å…ƒå¾ªç¯ã€éƒ¨åˆ†æ±‚å€¼ | GraalVMæ–‡æ¡£ |

### å…³é”®è®ºæ–‡ï¼ˆå¿…è¯»ï¼‰

1. **SSA**:
   - Cytron et al. 1991: "Efficiently Computing Static Single Assignment Form"
   - Briggs et al. 1998: "Practical Improvements to the Construction and Destruction of SSA Form"

2. **å¯„å­˜å™¨åˆ†é…**:
   - Briggs et al. 1994: "Register Allocation via Graph Coloring"
   - Poletto & Sarkar 1999: "Linear Scan Register Allocation"

3. **æ•°æ®æµåˆ†æ**:
   - Cytron et al. 1989: "Efficiently Computing SSA"
   - Wegman & Zadeck 1991: "Constant Propagation with Conditional Branches"

4. **JIT**:
   - Aycock 2003: "A Brief History of Just-In-Time"
   - Holzle et al. 1992: "Adaptive Optimization for Self"

---

## ğŸ¯ å»ºè®®çš„æ‰©å±•è·¯çº¿

### è·¯å¾„Aï¼šå·¥ä¸šçº§ç¼–è¯‘å™¨è·¯çº¿ï¼ˆæ¨èå·¥ç¨‹å¸ˆï¼‰

```
EP21ï¼ˆç°æœ‰ï¼‰
    â†“
EP22: è¿‡ç¨‹é—´ä¼˜åŒ–ï¼ˆ3-4å‘¨ï¼‰
    â”œâ”€â”€ å‡½æ•°å†…è”
    â”œâ”€â”€ é€ƒé€¸åˆ†æ
    â””â”€â”€ LTOåŸºç¡€
    â†“
EP23: å¾ªç¯ä¼˜åŒ–ï¼ˆ4-5å‘¨ï¼‰
    â”œâ”€â”€ LICM
    â”œâ”€â”€ å¾ªç¯å±•å¼€
    â””â”€â”€ ç®€å•å‘é‡åŒ–
    â†“
EP24: å†…å­˜ä¼˜åŒ–ï¼ˆ4-5å‘¨ï¼‰
    â”œâ”€â”€ åˆ«ååˆ†æ
    â”œâ”€â”€ MemorySSA
    â””â”€â”€ æ•°ç»„ä¾èµ–åˆ†æ
    â†“
EP25: å¯„å­˜å™¨åˆ†é…ï¼ˆ3-4å‘¨ï¼‰
    â”œâ”€â”€ å›¾ç€è‰²
    â”œâ”€â”€ çº¿æ€§æ‰«æ
    â””â”€â”€ æº¢å‡ºä»£ç ç”Ÿæˆ
```

**æ€»è®¡**: 14-18å‘¨ï¼ˆ3.5-4.5ä¸ªæœˆï¼‰

### è·¯å¾„Bï¼šJITç¼–è¯‘å™¨è·¯çº¿ï¼ˆæ¨èé«˜çº§å·¥ç¨‹å¸ˆ/ç ”ç©¶è€…ï¼‰

```
EP21ï¼ˆç°æœ‰ï¼‰
    â†“
EP26: SSAé«˜çº§ä¼˜åŒ–ï¼ˆ3-4å‘¨ï¼‰
    â”œâ”€â”€ SCCP
    â”œâ”€â”€ GVN
    â””â”€â”€ PRE
    â†“
EP28: JITç¼–è¯‘å™¨ï¼ˆ5-6å‘¨ï¼‰
    â”œâ”€â”€ çƒ­ç‚¹æ£€æµ‹
    â”œâ”€â”€ åˆ†å±‚ç¼–è¯‘
    â””â”€â”€ å†…è”ç¼“å­˜
    â†“
EP29: å…ƒå¾ªç¯ä¼˜åŒ–ï¼ˆ4-5å‘¨ï¼‰
    â”œâ”€â”€ Truffleæ¡†æ¶
    â”œâ”€â”€ éƒ¨åˆ†æ±‚å€¼
    â””â”€â”€ GraalVMæ¥å£
```

**æ€»è®¡**: 12-15å‘¨ï¼ˆ3-4ä¸ªæœˆï¼‰

---

**ç‰ˆæœ¬**: v1.0 | **æ—¥æœŸ**: 2025-12-27 | **ä½œè€…**: Claude Code

**ä½¿ç”¨å»ºè®®**: æœ¬æ–‡æ¡£ä¸ºEP21+çš„æ‰©å±•æä¾›è·¯çº¿å›¾ï¼Œå»ºè®®æ ¹æ®å­¦ä¹ /å·¥ä½œç›®æ ‡é€‰æ‹©åˆé€‚çš„è·¯å¾„ã€‚
