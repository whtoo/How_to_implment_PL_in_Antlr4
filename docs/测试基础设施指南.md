# æµ‹è¯•åŸºç¡€è®¾æ–½æŒ‡å—

**ç‰ˆæœ¬**: v1.0 | **æ—¥æœŸ**: 2026-01-08 | **çŠ¶æ€**: åˆç¨¿å®Œæˆ
**ç›®çš„**: æä¾›EP18Rå’ŒEP21çš„å…±äº«æµ‹è¯•å·¥å…·ã€æµ‹è¯•æ¨¡å¼å’Œæœ€ä½³å®è·µ
**ç›¸å…³æ–‡æ¡£**: [EP18Ræ”¹è¿›è®¡åˆ’](../ep18r/docs/æ”¹è¿›è®¡åˆ’.md) | [EP21æ”¹è¿›è®¡åˆ’](../ep21/docs/æ”¹è¿›è®¡åˆ’.md) | [æµ‹è¯•æ¨¡æ¿](../ep21/docs/æµ‹è¯•æ¨¡æ¿.md)

---

## 1. æµ‹è¯•åŸºç¡€è®¾æ–½æ¦‚è¿°

### 1.1 EP18Rä¸EP21æµ‹è¯•å¯¹æ¯”

| ç‰¹æ€§ | EP18R | EP21 | èåˆç­–ç•¥ |
|------|--------|-------|---------|
| **åŸºç¡€æµ‹è¯•ç±»** | `RegisterVMTestBase` | æ— å…±äº«åŸºç±» | åˆ›å»ºå…±äº«æµ‹è¯•åŸºç±» |
| **æµ‹è¯•æ–‡ä»¶æ•°** | 12ä¸ª | 33ä¸ª | ä¿æŒç‹¬ç«‹æ¨¡å— |
| **æµ‹è¯•æ¨¡å¼** | ç¨‹åºå­—ç¬¦ä¸²æµ‹è¯• | JUnit5ç‰¹æ€§ï¼ˆ@Nested, @Parameterizedï¼‰ | ç»“åˆä¸¤è€…ä¼˜ç‚¹ |
| **è·¨æ¨¡å—å·¥å…·** | æ—  | æ—  | åˆ›å»ºå…±äº«æµ‹è¯•å·¥å…· |
| **è¦†ç›–ç‡** | 79/79æµ‹è¯•ï¼ˆ100%ï¼‰ | 563/563æµ‹è¯•ï¼ˆ100%ï¼‰ | ä¿æŒâ‰¥85% |
| **é›†æˆæµ‹è¯•** | æ—  | æ— ï¼ˆEP21â†’EP18Rï¼‰ | åˆ›å»ºç«¯åˆ°ç«¯æµ‹è¯• |

### 1.2 æµ‹è¯•é‡‘å­—å¡”ç­–ç•¥

```
         é›†æˆæµ‹è¯• (20%)
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  EP21â†’EP18R  â”‚
         â”‚  ç«¯åˆ°ç«¯æµ‹è¯•  â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†‘
        ç»„ä»¶æµ‹è¯• (30%)
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ RegisterVM  â”‚
         â”‚ Generator   â”‚
         â”‚ LinearScan  â”‚
         â”‚ Allocator   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†‘
      å•å…ƒæµ‹è¯• (50%)
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ RegisterOperand   â”‚
    â”‚ Extractor         â”‚
    â”‚ AbstractInstr     â”‚
    â”‚ Executor          â”‚
    â”‚ StackFrameManager â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç›®æ ‡**ï¼š
- å•å…ƒæµ‹è¯•ï¼š50%ï¼ˆå¿«é€Ÿåé¦ˆã€ç‹¬ç«‹éªŒè¯ï¼‰
- ç»„ä»¶æµ‹è¯•ï¼š30%ï¼ˆæ¨¡å—é—´åä½œéªŒè¯ï¼‰
- é›†æˆæµ‹è¯•ï¼š20%ï¼ˆç«¯åˆ°ç«¯å®Œæ•´æµç¨‹ï¼‰

---

## 2. å…±äº«æµ‹è¯•å·¥å…·

### 2.1 RegisterVMTestBaseï¼ˆEP18RåŸºç±»ï¼‰

**ä½ç½®**ï¼š`ep18r/src/test/java/org/teachfx/antlr4/ep18/`

**åŠŸèƒ½**ï¼šæä¾›å¯„å­˜å™¨VMæµ‹è¯•çš„åŸºç¡€å·¥å…·æ–¹æ³•

```java
/**
 * å¯„å­˜å™¨VMæµ‹è¯•åŸºç±»
 * æä¾›é€šç”¨çš„æµ‹è¯•å·¥å…·æ–¹æ³•
 */
public abstract class RegisterVMTestBase {

    /**
     * åˆ›å»ºè™šæ‹Ÿæœºå®ä¾‹
     */
    protected RegisterVMInterpreter createVM() {
        RegisterVMConfig config = new RegisterVMConfig.Builder()
            .heapSize(1024)
            .maxCallStackDepth(100)
            .build();
        return new RegisterVMInterpreter(config);
    }

    /**
     * æ‰§è¡Œå­—èŠ‚ç å¹¶è¿”å›ç»“æœ
     */
    protected int executeAndReturnResult(String bytecode) throws Exception {
        RegisterVMInterpreter vm = createVM();
        vm.load(new ByteArrayInputStream(bytecode.getBytes()));
        vm.execute();
        return vm.getRegister(Register.R10); // R10ä¸ºè¿”å›å€¼å¯„å­˜å™¨
    }

    /**
     * æ‰§è¡Œç¨‹åºå­—ç¬¦ä¸²å¹¶éªŒè¯ç»“æœ
     * ç¨‹åºå­—ç¬¦ä¸²æ ¼å¼ï¼šæ¯è¡Œä¸€æ¡æŒ‡ä»¤
     */
    protected void executeAndVerify(String program, int expected) throws Exception {
        RegisterVMInterpreter vm = createVM();
        List<Instruction> instructions = parseProgram(program);
        vm.loadInstructions(instructions);
        vm.execute();

        int result = vm.getRegister(Register.R10);
        assertThat(result).isEqualTo(expected);
    }

    /**
     * è§£æç¨‹åºå­—ç¬¦ä¸²ä¸ºæŒ‡ä»¤åˆ—è¡¨
     */
    protected List<Instruction> parseProgram(String program) {
        return Arrays.stream(program.split("\n"))
            .filter(line -> !line.trim().isEmpty() && !line.startsWith("//"))
            .map(this::parseInstruction)
            .collect(Collectors.toList());
    }

    /**
     * è§£æå•æ¡æŒ‡ä»¤
     */
    protected abstract Instruction parseInstruction(String line);
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```java
@Test
@DisplayName("åº”è¯¥æ­£ç¡®æ‰§è¡ŒåŠ æ³•æŒ‡ä»¤")
void testAddInstruction() throws Exception {
    // Arrange
    String program = """
        ADD r0, r1, r2    // r0 = r1 + r2
        SET r1, 5
        SET r2, 3
        HALT
        """;

    // Act & Assert
    executeAndVerify(program, 8);
}
```

### 2.2 SharedTestUtilsï¼ˆæ–°å»ºå…±äº«å·¥å…·ï¼‰

**ä½ç½®**ï¼š`ep-test-common/src/test/java/org/teachfx/antlr4/test/`

**åŠŸèƒ½**ï¼šè·¨æ¨¡å—å…±äº«çš„æµ‹è¯•å·¥å…·

```java
/**
 * å…±äº«æµ‹è¯•å·¥å…·ç±»
 * æä¾›è·¨æ¨¡å—æµ‹è¯•çš„é€šç”¨æ–¹æ³•
 */
public final class SharedTestUtils {

    private SharedTestUtils() { /* å·¥å…·ç±»ï¼Œç¦æ­¢å®ä¾‹åŒ– */ }

    /**
     * åˆ›å»ºASTèŠ‚ç‚¹
     */
    public static ASTNode createASTNode(String sourceCode) throws Exception {
        CymbolLexer lexer = new CymbolLexer(CharStreams.fromString(sourceCode));
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        CymbolParser parser = new CymbolParser(tokens);
        return new CymbolASTBuilder().visit(parser.program());
    }

    /**
     * ç¼–è¯‘Cymbolæºä»£ç ä¸ºå­—èŠ‚ç 
     */
    public static byte[] compileCymbol(String sourceCode) throws Exception {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        Compiler compiler = new Compiler();
        compiler.compile(new ByteArrayInputStream(sourceCode.getBytes()), output);
        return output.toByteArray();
    }

    /**
     * æ‰§è¡Œå­—èŠ‚ç å¹¶æ•è·è¾“å‡º
     */
    public static String executeAndCaptureOutput(byte[] bytecode, IVirtualMachine vm) throws Exception {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        vm.setOutput(out);
        vm.load(new ByteArrayInputStream(bytecode));
        vm.execute();
        return out.toString();
    }

    /**
     * åˆ›å»ºä¸´æ—¶æ–‡ä»¶
     */
    public static File createTempFile(String content) throws IOException {
        File tempFile = File.createTempFile("test-", ".cym");
        tempFile.deleteOnExit();
        Files.write(tempFile.toPath(), content.getBytes(StandardCharsets.UTF_8));
        return tempFile;
    }

    /**
     * è¯»å–èµ„æºæ–‡ä»¶
     */
    public static String readResource(String path) throws IOException {
        try (InputStream is = SharedTestUtils.class.getClassLoader().getResourceAsStream(path)) {
            if (is == null) {
                throw new FileNotFoundException("Resource not found: " + path);
            }
            return new String(is.readAllBytes(), StandardCharsets.UTF_8);
        }
    }
}
```

### 2.3 VMPerformanceUtilsï¼ˆæ€§èƒ½æµ‹è¯•å·¥å…·ï¼‰

**åŠŸèƒ½**ï¼šæä¾›VMæ€§èƒ½æµ‹è¯•çš„å·¥å…·æ–¹æ³•

```java
/**
 * VMæ€§èƒ½æµ‹è¯•å·¥å…·
 */
public final class VMPerformanceUtils {

    private VMPerformanceUtils() { }

    /**
     * æµ‹é‡æ‰§è¡Œæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
     */
    public static long measureExecutionTime(Runnable runnable) {
        long start = System.nanoTime();
        runnable.run();
        long end = System.nanoTime();
        return (end - start) / 1_000_000; // è½¬æ¢ä¸ºæ¯«ç§’
    }

    /**
     * æµ‹é‡å†…å­˜ä½¿ç”¨ï¼ˆå­—èŠ‚ï¼‰
     */
    public static long measureMemoryUsage(Runnable runnable) {
        Runtime runtime = Runtime.getRuntime();
        long before = runtime.totalMemory() - runtime.freeMemory();
        runnable.run();
        long after = runtime.totalMemory() - runtime.freeMemory();
        return after - before;
    }

    /**
     * æ‰§è¡Œå¤šæ¬¡å¹¶è®¡ç®—å¹³å‡æ—¶é—´
     */
    public static double averageExecutionTime(Runnable runnable, int iterations) {
        long totalTime = 0;
        for (int i = 0; i < iterations; i++) {
            totalTime += measureExecutionTime(runnable);
        }
        return (double) totalTime / iterations;
    }
}
```

---

## 3. æµ‹è¯•æ¨¡å¼

### 3.1 ç¨‹åºå­—ç¬¦ä¸²æµ‹è¯•ï¼ˆEP18Ré£æ ¼ï¼‰

**é€‚ç”¨åœºæ™¯**ï¼šæµ‹è¯•VMæŒ‡ä»¤æ‰§è¡Œã€å¯„å­˜å™¨æ“ä½œã€å†…å­˜è®¿é—®

**ç‰¹ç‚¹**ï¼š
- ç®€å•ç›´è§‚ï¼Œæ˜“äºç¼–å†™
- é€‚åˆå•å…ƒæµ‹è¯•
- å¿«é€Ÿåé¦ˆ

**ç¤ºä¾‹**ï¼š

```java
@Test
@DisplayName("åº”è¯¥æ­£ç¡®å¤„ç†ç®—æœ¯è¿ç®—")
void testArithmeticOperations() throws Exception {
    String program = """
        SET r1, 10
        SET r2, 5
        ADD r3, r1, r2    // r3 = 10 + 5 = 15
        SUB r4, r1, r2    // r4 = 10 - 5 = 5
        MUL r5, r3, r2    // r5 = 15 * 5 = 75
        DIV r6, r3, r2    // r6 = 15 / 5 = 3
        HALT
        """;

    RegisterVMInterpreter vm = createVM();
    List<Instruction> instructions = parseProgram(program);
    vm.loadInstructions(instructions);
    vm.execute();

    assertThat(vm.getRegister(Register.R3)).isEqualTo(15);
    assertThat(vm.getRegister(Register.R4)).isEqualTo(5);
    assertThat(vm.getRegister(Register.R5)).isEqualTo(75);
    assertThat(vm.getRegister(Register.R6)).isEqualTo(3);
}
```

### 3.2 ç®¡é“æµ‹è¯•ï¼ˆEP21é£æ ¼ï¼‰

**é€‚ç”¨åœºæ™¯**ï¼šæµ‹è¯•å®Œæ•´ç¼–è¯‘ç®¡é“ï¼ˆASTâ†’IRâ†’å­—èŠ‚ç ï¼‰

**ç‰¹ç‚¹**ï¼š
- æµ‹è¯•å¤šä¸ªç»„ä»¶çš„åä½œ
- éªŒè¯æ•°æ®æµæ­£ç¡®æ€§
- ä½¿ç”¨JUnit5ç‰¹æ€§

**ç¤ºä¾‹**ï¼š

```java
@Test
@DisplayName("åº”è¯¥æ­£ç¡®ç¼–è¯‘ç®€å•ç®—æœ¯è¡¨è¾¾å¼")
void testSimpleArithmeticCompilation() throws Exception {
    // Arrange
    String cymbolSource = """
        int main() {
            int x = 5 + 3;
            return x;
        }
        """;

    // Act
    Compiler compiler = new Compiler();
    byte[] bytecode = compiler.compile(cymbolSource);

    // Assert
    assertThat(bytecode).isNotNull();
    assertThat(bytecode.length).isGreaterThan(0);

    // æ‰§è¡ŒéªŒè¯
    RegisterVMInterpreter vm = createVM();
    vm.load(new ByteArrayInputStream(bytecode));
    vm.execute();
    assertThat(vm.getRegister(Register.R10)).isEqualTo(8);
}
```

### 3.3 é›†æˆæµ‹è¯•æ¨¡å¼ï¼ˆEP21â†’EP18Rï¼‰

**é€‚ç”¨åœºæ™¯**ï¼šæµ‹è¯•EP21ç¼–è¯‘å™¨ä¸EP18Rè™šæ‹Ÿæœºçš„é›†æˆ

**ç‰¹ç‚¹**ï¼š
- ç«¯åˆ°ç«¯æµ‹è¯•
- éªŒè¯è·¨æ¨¡å—åä½œ
- è¯­ä¹‰ç­‰ä»·æ€§éªŒè¯

**ç¤ºä¾‹**ï¼š

```java
/**
 * EP21â†’EP18Ré›†æˆæµ‹è¯•
 */
class EP21ToEP18RIntegrationTest {

    @Test
    @DisplayName("EP21ç¼–è¯‘çš„ä»£ç åœ¨EP18Rä¸Šåº”è¯¥æ­£ç¡®æ‰§è¡Œ")
    void testCompileAndRunOnEP18R() throws Exception {
        // Arrange
        String cymbolSource = """
            int fib(int n) {
                if (n <= 1) return n;
                return fib(n-1) + fib(n-2);
            }
            int main() {
                return fib(10);
            }
            """;

        // Act
        byte[] stackVMBytecode = compileToStackVM(cymbolSource);
        byte[] registerVMBytecode = compileToRegisterVM(cymbolSource);

        int stackResult = executeOnStackVM(stackVMBytecode);
        int registerResult = executeOnRegisterVM(registerVMBytecode);

        // Assert
        assertThat(stackResult).isEqualTo(55);
        assertThat(registerResult).isEqualTo(55);
        assertThat(stackResult).isEqualTo(registerResult); // è¯­ä¹‰ç­‰ä»·æ€§
    }

    @Test
    @DisplayName("æ€§èƒ½å¯¹æ¯”ï¼šEP18Råº”è¯¥æ¯”EP18å¿«â‰¥10%")
    void testPerformanceComparison() throws Exception {
        // Arrange
        String cymbolSource = """
            int fibonacci(int n) {
                if (n <= 1) return n;
                int a = 0;
                int b = 1;
                int i = 2;
                while (i <= n) {
                    int temp = a + b;
                    a = b;
                    b = temp;
                    i = i + 1;
                }
                return b;
            }
            int main() {
                return fibonacci(10000);
            }
            """;

        byte[] stackVMBytecode = compileToStackVM(cymbolSource);
        byte[] registerVMBytecode = compileToRegisterVM(cymbolSource);

        // Act
        long stackTime = averageExecutionTime(() -> executeOnStackVM(stackVMBytecode), 10);
        long registerTime = averageExecutionTime(() -> executeOnRegisterVM(registerVMBytecode), 10);

        double improvement = ((double) (stackTime - registerTime) / stackTime) * 100;

        // Assert
        assertThat(improvement).isGreaterThanOrEqualTo(10.0); // EP18Ræ¯”EP18å¿«â‰¥10%
    }
}
```

---

## 4. æœ€ä½³å®è·µ

### 4.1 TDDï¼ˆæµ‹è¯•é©±åŠ¨å¼€å‘ï¼‰åŸåˆ™

**é»„é‡‘æ³•åˆ™**ï¼šå…ˆå†™æµ‹è¯•ï¼Œå†å†™å®ç°

**TDDæµç¨‹**ï¼š
1. **çº¢**ï¼šç¼–å†™ä¸€ä¸ªå¤±è´¥çš„æµ‹è¯•
2. **ç»¿**ï¼šç¼–å†™æœ€å°‘é‡çš„ä»£ç ä½¿æµ‹è¯•é€šè¿‡
3. **é‡æ„**ï¼šä¼˜åŒ–ä»£ç ï¼Œä¿æŒæµ‹è¯•é€šè¿‡

**ç¤ºä¾‹**ï¼š

```java
// 1. çº¢ï¼šç¼–å†™å¤±è´¥çš„æµ‹è¯•
@Test
void testRegisterOperandExtractor_extractRd() {
    int operand = 0b00000000_00000000_00001111_00000000; // rd = 15
    int rd = RegisterOperandExtractor.extractRd(operand);
    assertThat(rd).isEqualTo(15); // å¤±è´¥ï¼šæ–¹æ³•ä¸å­˜åœ¨
}

// 2. ç»¿ï¼šç¼–å†™æœ€å°‘é‡çš„ä»£ç 
public static int extractRd(int operand) {
    return (operand >> 8) & 0xF; // æœ€ç®€å•çš„å®ç°
}

// 3. é‡æ„ï¼šä¼˜åŒ–ä»£ç ï¼ˆå¦‚æœéœ€è¦ï¼‰
public static int extractRd(int operand) {
    return (operand >>> 8) & 0xF; // ä½¿ç”¨æ— ç¬¦å·å³ç§»
}
```

### 4.2 æµ‹è¯•å‘½åè§„èŒƒ

**åŸåˆ™**ï¼šæµ‹è¯•åç§°åº”è¯¥æè¿°æµ‹è¯•çš„åœºæ™¯å’Œé¢„æœŸ

**å‘½åæ ¼å¼**ï¼š`test[åŠŸèƒ½]_[åœºæ™¯]_[é¢„æœŸ]`

**ç¤ºä¾‹**ï¼š

```java
// âœ… å¥½çš„å‘½å
@Test
void testAddition_WithPositiveNumbers_ReturnsSum() { }

@Test
void testDivision_ByZero_ThrowsException() { }

@Test
void testRegisterAllocation_WithMoreVariablesThanRegisters_SpillsToStack() { }

// âŒ å·®çš„å‘½å
@Test
void test1() { }

@Test
void testAdd() { }

@Test
void testMethod() { }
```

**JUnit5 @DisplayNameæ³¨è§£**ï¼š

```java
@Test
@DisplayName("åº”è¯¥æ­£ç¡®æ‰§è¡Œæ•´æ•°åŠ æ³•")
void testIntegerAddition() { }

@Test
@DisplayName("é™¤ä»¥é›¶åº”è¯¥æŠ›å‡ºDivisionByZeroException")
void testDivisionByZero_ShouldThrowException() { }
```

### 4.3 æ–­è¨€é€‰æ‹©ï¼ˆJUnit vs AssertJï¼‰

**JUnitæ–­è¨€**ï¼šç®€å•åœºæ™¯
```java
assertEquals(expected, actual);
assertTrue(condition);
assertNull(object);
```

**AssertJæ–­è¨€**ï¼šå¤æ‚åœºæ™¯ï¼ˆæ¨èï¼‰
```java
assertThat(actual).isEqualTo(expected);
assertThat(object).hasFieldOrProperty("name", "value");
assertThat(list).hasSize(5).containsExactly(1, 2, 3, 4, 5);
assertThat(exception).isInstanceOf(MyException.class)
                 .hasMessage("error message");
```

**æ¨è**ï¼š
- ç®€å•æ–­è¨€ï¼šä½¿ç”¨JUnit
- å¤æ‚æ–­è¨€ï¼šä½¿ç”¨AssertJ
- æµå¼APIï¼šAssertJæ›´å¯è¯»

**ç¤ºä¾‹å¯¹æ¯”**ï¼š

```java
// JUnitæ–¹å¼
assertEquals(5, result);
assertTrue(list.size() == 5);
assertTrue(list.contains(1) && list.contains(2) && list.contains(3));
assertFalse(map.isEmpty());

// AssertJæ–¹å¼ï¼ˆæ›´å¯è¯»ï¼‰
assertThat(result).isEqualTo(5);
assertThat(list).hasSize(5).containsExactly(1, 2, 3, 4, 5);
assertThat(map).isNotEmpty();
```

### 4.4 æµ‹è¯•ç»„ç»‡ç»“æ„

**æ¨èç»“æ„**ï¼š

```
src/test/java/
â”œâ”€â”€ integration/              # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ EP21ToEP18RIntegrationTest.java
â”‚   â””â”€â”€ EndToEndTest.java
â”œâ”€â”€ pass/                     # Passå•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ ir/
â”‚   â”‚   â”œâ”€â”€ MIRBuilderTest.java
â”‚   â”‚   â””â”€â”€ LIRBuilderTest.java
â”‚   â””â”€â”€ codegen/
â”‚       â”œâ”€â”€ StackVMGeneratorTest.java
â”‚       â””â”€â”€ RegisterVMGeneratorTest.java
â”œâ”€â”€ stackvm/                  # EP18Rå•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ instruction/
â”‚   â”‚   â””â”€â”€ InstructionExecutorTest.java
â”‚   â””â”€â”€ memory/
â”‚       â””â”€â”€ MemoryManagerTest.java
â””â”€â”€ test/                     # æµ‹è¯•å·¥å…·
    â”œâ”€â”€ RegisterVMTestBase.java
    â”œâ”€â”€ SharedTestUtils.java
    â””â”€â”€ VMPerformanceUtils.java
```

### 4.5 å‚æ•°åŒ–æµ‹è¯•

**é€‚ç”¨åœºæ™¯**ï¼šæµ‹è¯•å¤šç»„è¾“å…¥è¾“å‡º

**JUnit5 @ParameterizedTest**ï¼š

```java
@ParameterizedTest
@MethodSource("arithmeticOperationProvider")
@DisplayName("ç®—æœ¯è¿ç®—æµ‹è¯•")
void testArithmeticOperations(String operation, int a, int b, int expected) {
    String program = String.format("%s r3, r1, r2\nSET r1, %d\nSET r2, %d\nHALT",
                                  operation, a, b);

    RegisterVMInterpreter vm = createVM();
    vm.loadInstructions(parseProgram(program));
    vm.execute();

    assertThat(vm.getRegister(Register.R3)).isEqualTo(expected);
}

static Stream<Arguments> arithmeticOperationProvider() {
    return Stream.of(
        Arguments.of("ADD", 5, 3, 8),
        Arguments.of("SUB", 5, 3, 2),
        Arguments.of("MUL", 5, 3, 15),
        Arguments.of("DIV", 6, 3, 2),
        Arguments.of("MOD", 7, 3, 1)
    );
}
```

### 4.6 åµŒå¥—æµ‹è¯•

**é€‚ç”¨åœºæ™¯**ï¼šæµ‹è¯•æœ‰å±‚æ¬¡å…³ç³»çš„åœºæ™¯

**JUnit5 @Nested**ï¼š

```java
@Test
@DisplayName("å¯„å­˜å™¨åˆ†é…å™¨æµ‹è¯•")
class LinearScanAllocatorTest {

    @Nested
    @DisplayName("ç®€å•åœºæ™¯")
    class SimpleCases {

        @Test
        @DisplayName("å½“å˜é‡æ•°â‰¤å¯„å­˜å™¨æ•°æ—¶ï¼Œæ‰€æœ‰å˜é‡åº”è¯¥åˆ†é…åˆ°å¯„å­˜å™¨")
        void whenVariablesLessThanRegisters_ShouldAllocateAllToRegisters() {
            // æµ‹è¯•ä»£ç 
        }

        @Test
        @DisplayName("å½“åªæœ‰ä¸€ä¸ªå˜é‡æ—¶ï¼Œåº”è¯¥åˆ†é…åˆ°r0")
        void whenSingleVariable_ShouldAllocateToR0() {
            // æµ‹è¯•ä»£ç 
        }
    }

    @Nested
    @DisplayName("æº¢å‡ºåœºæ™¯")
    class OverflowCases {

        @Test
        @DisplayName("å½“å˜é‡æ•°>å¯„å­˜å™¨æ•°æ—¶ï¼Œéƒ¨åˆ†å˜é‡åº”è¯¥æº¢å‡ºåˆ°æ ˆ")
        void whenVariablesMoreThanRegisters_ShouldSpillToStack() {
            // æµ‹è¯•ä»£ç 
        }

        @Test
        @DisplayName("æº¢å‡ºçš„å˜é‡åº”è¯¥æŒ‰ç…§LRUé¡ºåº")
        void whenVariablesSpill_ShouldFollowLRUOrder() {
            // æµ‹è¯•ä»£ç 
        }
    }
}
```

### 4.7 å¼‚å¸¸æµ‹è¯•

**JUnit5 assertThrows**ï¼š

```java
@Test
@DisplayName("é™¤ä»¥é›¶åº”è¯¥æŠ›å‡ºDivisionByZeroException")
void testDivisionByZero_ShouldThrowException() {
    String program = """
        SET r1, 10
        SET r2, 0
        DIV r3, r1, r2    // é™¤ä»¥é›¶
        HALT
        """;

    RegisterVMInterpreter vm = createVM();
    vm.loadInstructions(parseProgram(program));

    DivisionByZeroException exception = assertThrows(
        DivisionByZeroException.class,
        () -> vm.execute()
    );

    assertThat(exception.getMessage()).contains("Division by zero");
}
```

---

## 5. è¦†ç›–ç‡ç›®æ ‡

### 5.1 è¦†ç›–ç‡è¦æ±‚

| æ¨¡å— | ç›®æ ‡è¦†ç›–ç‡ | è¯´æ˜ |
|------|-----------|------|
| **EP18Ræ•´ä½“** | â‰¥ 85% | ä¿æŒâ‰¥85%ï¼Œæ ¸å¿ƒç±»â‰¥90% |
| **EP21æ•´ä½“** | ä¿æŒ100% | ä¿æŒ100% |
| **æ ¸å¿ƒç±»**ï¼ˆIRã€CFGã€ä¼˜åŒ–å™¨ï¼‰ | â‰¥ 90% | å…³é”®ç®—æ³•100% |
| **æ–°å¢åŠŸèƒ½** | 100% | TDDè¦æ±‚ |
| **é›†æˆæµ‹è¯•** | â‰¥ 20ä¸ªç”¨ä¾‹ | EP21â†’EP18R |

### 5.2 è¦†ç›–ç‡æŠ¥å‘Šç”Ÿæˆ

```bash
# ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
mvn jacoco:report

# æŸ¥çœ‹æŠ¥å‘Š
open target/site/jacoco/index.html
```

### 5.3 è¦†ç›–ç‡é—¨ç¦

**Mavené…ç½®**ï¼š

```xml
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.10</version>
    <configuration>
        <rules>
            <rule implementation="org.jacoco.maven.RuleConfiguration">
                <element>BUNDLE</element>
                <limits>
                    <limit implementation="org.jacoco.report.check.Limit">
                        <counter>INSTRUCTION</counter>
                        <value>COVEREDRATIO</value>
                        <minimum>0.85</minimum>
                    </limit>
                </limits>
            </rule>
        </rules>
    </configuration>
    <executions>
        <execution>
            <id>check</id>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

---

## 6. æµ‹è¯•æ‰§è¡ŒæŒ‡å—

### 6.1 è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
mvn test

# è¿è¡Œç‰¹å®šæ¨¡å—æµ‹è¯•
mvn test -pl ep18r
mvn test -pl ep21

# è¿è¡Œç‰¹å®šæµ‹è¯•ç±»
mvn test -Dtest=LinearScanAllocatorTest

# è¿è¡Œç‰¹å®šæµ‹è¯•æ–¹æ³•
mvn test -Dtest=LinearScanAllocatorTest#testSimpleAllocation

# è¿è¡ŒåŒ¹é…çš„æµ‹è¯•
mvn test -Dtest="*Integration*"
```

### 6.2 è°ƒè¯•æµ‹è¯•

```bash
# å¯ç”¨è¯¦ç»†æ—¥å¿—
mvn test -X

# è·³è¿‡æµ‹è¯•
mvn install -DskipTests

# åªè¿è¡Œå¤±è´¥çš„æµ‹è¯•
mvn test -DfailIfNoTests=false -Dtest="*Test"
```

### 6.3 æµ‹è¯•æŠ¥å‘Š

```bash
# ç”ŸæˆHTMLæŠ¥å‘Š
mvn surefire-report:report

# æŸ¥çœ‹æŠ¥å‘Š
open target/site/surefire-report.html
```

---

## 7. å¸¸è§é—®é¢˜

### 7.1 æµ‹è¯•å¤±è´¥æ€ä¹ˆåŠï¼Ÿ

**æ­¥éª¤**ï¼š
1. æŸ¥çœ‹é”™è¯¯ä¿¡æ¯å’Œå †æ ˆè·Ÿè¸ª
2. ä½¿ç”¨è°ƒè¯•å™¨è®¾ç½®æ–­ç‚¹
3. æ£€æŸ¥æµ‹è¯•æ•°æ®å’Œé¢„æœŸå€¼
4. æ£€æŸ¥ä¾èµ–å’Œç¯å¢ƒé…ç½®

### 7.2 å¦‚ä½•æµ‹è¯•ç§æœ‰æ–¹æ³•ï¼Ÿ

**å»ºè®®**ï¼š
- é€šè¿‡å…¬å…±APIæµ‹è¯•
- å¦‚æœå¿…é¡»æµ‹è¯•ï¼Œä½¿ç”¨åå°„ï¼ˆä¸æ¨èï¼‰
- è€ƒè™‘é‡æ„ä¸ºåŒ…å¯è§

```java
// åå°„æµ‹è¯•ç§æœ‰æ–¹æ³•ï¼ˆä¸æ¨èï¼‰
Method method = clazz.getDeclaredMethod("privateMethod", paramTypes);
method.setAccessible(true);
Object result = method.invoke(instance, args);
```

### 7.3 å¦‚ä½•æ¨¡æ‹Ÿå¤–éƒ¨ä¾èµ–ï¼Ÿ

**ä½¿ç”¨Mockito**ï¼š

```java
@ExtendWith(MockitoExtension.class)
class MyTest {

    @Mock
    private IRegisterAllocator allocator;

    @Test
    void testWithMock() {
        when(allocator.allocateRegister(any())).thenReturn(5);
        // æµ‹è¯•ä»£ç 
    }
}
```

---

## 8. ç›¸å…³èµ„æº

### 8.1 å†…éƒ¨æ–‡æ¡£

- **EP18Ræµ‹è¯•æ¨¡æ¿**: [../ep18r/docs/æµ‹è¯•æ¨¡æ¿.md](../ep18r/docs/æµ‹è¯•æ¨¡æ¿.md)
- **EP21æµ‹è¯•æ¨¡æ¿**: [æµ‹è¯•æ¨¡æ¿.md](../ep21/docs/æµ‹è¯•æ¨¡æ¿.md)
- **EP18Ræ”¹è¿›è®¡åˆ’**: [../ep18r/docs/æ”¹è¿›è®¡åˆ’.md](../ep18r/docs/æ”¹è¿›è®¡åˆ’.md)
- **EP21æ”¹è¿›è®¡åˆ’**: [../ep21/docs/æ”¹è¿›è®¡åˆ’.md](../ep21/docs/æ”¹è¿›è®¡åˆ’.md)

### 8.2 å¤–éƒ¨èµ„æº

- **JUnit5ç”¨æˆ·æŒ‡å—**: https://junit.org/junit5/docs/current/user-guide/
- **AssertJæ–‡æ¡£**: https://assertj.github.io/doc/
- **Mockitoæ–‡æ¡£**: https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html

---

**æœ€åæ›´æ–°**: 2026-01-08
**ç»´æŠ¤è€…**: Claude Code
**çŠ¶æ€**: ğŸ“ æµ‹è¯•åŸºç¡€è®¾æ–½æŒ‡å—åˆç¨¿å®Œæˆ
