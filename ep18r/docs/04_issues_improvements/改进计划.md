# EP18R 改进计划

**版本**: v2.0 | **日期**: 2026-01-08 | **状态**: 已与EP21融合
**目的**: 提供EP18R项目的改进规划和未来发展方向（已与EP21联动融合）
**相关文档**: [架构设计规范](架构设计规范.md) | [详细任务分解](详细任务分解.md) | [TDD执行计划_精简版](TDD执行计划_精简版.md) | [EP18R-EP21联动融合计划](EP18R-EP21联动融合计划.md)

---

## 1. 改进计划概述

### 1.1 当前状态

| 指标 | 值 | 状态 |
|------|-----|------|
| **核心功能** | 完成 | ✅ |
| **测试通过率** | 100% (79/79) | ✅ |
| **ABI规范实现** | 完成 | ✅ |
| **代码质量工具** | 需恢复 | ⚠️ |
| **架构优化** | 待执行 | ⏸️ |

### 1.2 改进目标

1. **代码质量提升**: 恢复代码质量工具链，建立质量门禁
2. **架构优化**: 消除代码重复，降低复杂度，提升可维护性
3. **性能提升**: 目标性能提升≥10%（对比未优化版本）
4. **架构清晰度**: 引入接口抽象，优化包结构
5. **测试增强**: 提升测试覆盖率至≥85%，添加集成测试
6. **EP21联动**: 统一寄存器分配策略，共享测试基础设施，实现端到端集成测试

### 1.3 与EP21联动说明

**联动目标**：EP18R与EP21协同优化，避免重复开发，提高整体效率

**关键联动点**：
- **寄存器分配**：EP21的RegisterVMGenerator使用EP18R的LinearScanAllocator
- **代码生成**：实现GeneratorFactory，支持动态选择StackVM或RegisterVM
- **测试共享**：建立跨模块测试基础设施和集成测试套件
- **接口统一**：ICodeGenerator、IRegisterAllocator等接口契约统一

**执行计划**：详见 [EP18R-EP21联动融合计划](EP18R-EP21联动融合计划.md)

---

## 2. 架构优化路线图

### 2.1 第一阶段：基础设施恢复（预计 2-3 天）

#### 任务 2.1.1：恢复代码质量工具配置
**优先级**: 🔴 高
**预计工时**: 4 小时

**目标**: 在 ep18r/pom.xml 中添加 CheckStyle、SpotBugs、JaCoCo 配置

**具体任务**:
```xml
<!-- 添加到 ep18r/pom.xml -->
<build>
  <plugins>
    <!-- CheckStyle 代码风格检查 -->
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-checkstyle-plugin</artifactId>
      <version>3.2.1</version>
      <configuration>
        <configLocation>google_checks.xml</configLocation>
      </configuration>
    </plugin>
    
    <!-- SpotBugs 静态分析 -->
    <plugin>
      <groupId>com.github.spotbugs</groupId>
      <artifactId>spotbugs-maven-plugin</artifactId>
      <version>4.7.3.0</version>
    </plugin>
    
    <!-- JaCoCo 测试覆盖率 -->
    <plugin>
      <groupId>org.jacoco</groupId>
      <artifactId>jacoco-maven-plugin</artifactId>
      <version>0.8.10</version>
      <executions>
        <execution>
          <goals><goal>prepare-agent</goal></goals>
        </execution>
        <execution>
          <id>report</id>
          <phase>test</phase>
          <goals><goal>report</goal></goals>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
```

**验收标准**:
- [ ] `mvn checkstyle:check` 无错误
- [ ] `mvn spotbugs:check` 无严重问题
- [ ] `mvn test jacoco:report` 生成覆盖率报告

---

#### 任务 2.1.2：建立基线测试覆盖
**优先级**: 🔴 高
**预计工时**: 6 小时

**目标**: 运行现有测试，生成初始覆盖率报告，识别低覆盖率区域

**具体任务**:
1. 运行完整测试套件：`mvn test`
2. 生成覆盖率报告：`mvn jacoco:report`
3. 分析低覆盖率区域：
   - GC 系统（ReferenceCountingGC）
   - 异常处理（Exception classes）
   - 边缘情况（Edge cases）
4. 创建 `CoverageGapAnalysis.md` 文档

**验收标准**:
- [ ] 生成完整的覆盖率报告
- [ ] 识别出所有覆盖率<70%的类
- [ ] 创建覆盖率差距分析文档

---

### 2.2 第二阶段：代码重复消除（预计 3-5 天）

#### 任务 2.2.1：提取通用寄存器操作工具类
**优先级**: 🔴 高
**预计工时**: 8 小时

**目标**: 创建 `RegisterOperandExtractor` 类，消除重复的寄存器操作逻辑

**具体任务**:
```java
// 新类：RegisterOperandExtractor.java
public class RegisterOperandExtractor {
    public static int extractRd(int operand) { /* 统一实现 */ }
    public static int extractRs1(int operand) { /* 统一实现 */ }
    public static int extractRs2(int operand) { /* 统一实现 */ }
    public static int extractImm16(int operand) { /* 统一实现 */ }
    public static int extractImm26(int operand) { /* 统一实现 */ }
}

// 替换所有重复的 extract* 方法调用
```

**受影响文件**:
- `RegisterVMInterpreter.java`
- `ControlFlowExecutors.java`
- `MemoryExecutors.java`
- 所有执行器类

**验收标准**:
- [ ] `RegisterOperandExtractor` 类创建完成
- [ ] 所有重复的 `extract*` 方法替换为调用工具类
- [ ] 所有测试通过
- [ ] 代码重复率降低≥20%

---

#### 任务 2.2.2：创建指令执行模板
**优先级**: 🔴 高
**预计工时**: 12 小时

**目标**: 使用模板方法模式统一指令执行逻辑

**具体任务**:
```java
// 新类：AbstractInstructionExecutor.java
public abstract class AbstractInstructionExecutor implements InstructionExecutor {
    protected final RegisterOperandExtractor extractor;
    protected final RegisterVMInterpreter vm;
    
    // 模板方法：提取操作数 → 执行计算 → 设置结果
    public void execute(int operand, ExecutionContext context) {
        int rd = extractor.extractRd(operand);
        int rs1 = extractor.extractRs1(operand);
        int rs2 = extractor.extractRs2(operand);
        int result = compute(rs1, rs2, operand);
        vm.setRegister(rd, result);
    }
    
    protected abstract int compute(int rs1, int rs2, int operand);
}

// 具体实现：AddExecutor、SubExecutor 等（各 < 50 行）
```

**验收标准**:
- [ ] `AbstractInstructionExecutor` 类创建完成
- [ ] 所有算术/比较指令迁移到模板模式
- [ ] 每个具体执行器<50 行
- [ ] 所有测试通过
- [ ] 代码重复率进一步降低≥15%

---

#### 任务 2.2.4：提取栈帧管理器
**优先级**: 🔴 高
**预计工时**: 10 小时

**目标**: 将CALL/RET中的栈帧计算逻辑提取到`StackFrameManager`

**具体任务**:
```java
// 新类：StackFrameManager.java
public class StackFrameManager {
    public int calculateReturnAddressOffset(int callDepth) { /* ... */ }
    public int calculateSavedRegistersOffset(int callDepth) { /* ... */ }
    public int calculateLocalsOffset(int callDepth) { /* ... */ }
    public void setupStackFrame(CallInstruction call) { /* ... */ }
    public void teardownStackFrame(ReturnInstruction ret) { /* ... */ }
}

// 重构ControlFlowExecutors中的CALL/RET逻辑
```

**受影响文件**:
- `ControlFlowExecutors.java`
- `CallingConventionUtils.java`

**验收标准**:
- [ ] `StackFrameManager` 类创建完成
- [ ] CALL/RET指令逻辑迁移到StackFrameManager
- [ ] 所有测试通过
- [ ] 代码重复率进一步降低

---

#### 任务 2.2.5：统一ABI寄存器映射
**优先级**: 🔴 高
**预计工时**: 6 小时

**目标**: 将分散的寄存器映射统一到一个枚举类

**具体任务**:
```java
// 新类：ABIRegisters.java
public enum ABIRegisters {
    ARG_0(Register.R0),    // 第一个参数
    ARG_1(Register.R1),    // 第二个参数
    // ... ARG_7(Register.R7)
    RETURN_VALUE(Register.R10),  // 返回值
    FRAME_POINTER(Register.R13),  // 栈帧指针
    STACK_POINTER(Register.R14),  // 栈指针
    RETURN_ADDRESS(Register.R15); // 返回地址

    // 统一的映射逻辑
    public static ABIRegisters getArgumentRegister(int index) { /* ... */ }
    public static Register getRegisterForRole(RegisterRole role) { /* ... */ }
}

// 替换CallingConventionUtils和StackOffsets中的重复定义
```

**受影响文件**:
- `CallingConventionUtils.java`
- `StackOffsets.java`
- 所有使用寄存器映射的类

**验收标准**:
- [ ] `ABIRegisters` 枚举类创建完成
- [ ] 所有寄存器映射统一到ABIRegisters
- [ ] 删除重复的映射定义
- [ ] 所有测试通过

---

### 2.3 第三阶段：上帝类拆分与复杂度降低（预计 4-6 天）

#### 任务 2.3.1：拆分 CallingConventionUtils（607 行）
**优先级**: 🔴 高
**预计工时**: 16 小时

**目标**: 将 607 行的上帝类拆分为多个专注类

**具体任务**:

| 新类 | 职责 | 方法数 | 预估行数 |
|-----|------|-------|---------|
| `RegisterSaver` | 寄存器保存/恢复逻辑 | 4 | 120 |
| `StackFrameManager` | 栈帧分配/释放 | 6 | 150 |
| `ParameterPassing` | 参数传递（寄存器+栈） | 8 | 200 |
| `ABIValidator` | ABI 规范验证 | 5 | 100 |
| `CallingConventionUtils`（保留） | 外观门面，委托给上述类 | 5 | 80 |

**验收标准**:
- [ ] 所有新类创建完成
- [ ] `CallingConventionUtils` 简化为外观类
- [ ] 每个新类职责单一
- [ ] 所有测试通过
- [ ] 平均类长度<200 行

---

#### 任务 2.3.2：重构 RegisterVMInterpreter.executeInstruction()
**优先级**: 🔴 高
**预计工时**: 12 小时

**目标**: 将 300+ 行的 executeInstruction() 方法降低到<100 行

**具体任务**:
```java
// 当前：300+ 行，switch-case + 直接逻辑
// 目标：< 100 行，策略委托 + 工厂模式

private void executeInstruction(int opcode, int operand) throws Exception {
    // 1. 特殊指令检查（HALT、CALL、RET、跳转等）
    if (isSpecialInstruction(opcode)) {
        handleSpecialInstruction(opcode, operand);
        return;
    }
    
    // 2. 通过工厂获取执行器
    InstructionExecutor executor = instructionFactory.getExecutor(opcode);
    
    // 3. 统一执行
    ExecutionContext context = createExecutionContext();
    executor.execute(operand, context);
}
```

**验收标准**:
- [ ] `executeInstruction()` 方法<100 行
- [ ] 圈复杂度≤10
- [ ] 所有测试通过
- [ ] 代码可读性提升

---

#### 任务 2.3.3：引入指令工厂
**优先级**: 🟡 中
**预计工时**: 8 小时

**目标**: 创建 `InstructionFactory` 类，统一管理指令执行器

**具体任务**:
```java
public class InstructionFactory {
    private final Map<Integer, InstructionExecutor> executorMap;
    
    public InstructionFactory() {
        executorMap = new HashMap<>();
        registerExecutors();
    }
    
    private void registerExecutors() {
        executorMap.put(ADD_OPCODE, new ArithmeticExecutor(ArithmeticOperation.ADD));
        executorMap.put(SUB_OPCODE, new ArithmeticExecutor(ArithmeticOperation.SUB));
        // ... 注册所有指令
    }
    
    public InstructionExecutor getExecutor(int opcode) {
        return executorMap.getOrDefault(opcode, 
            (op, ctx) -> { throw new UnsupportedOperationException("Opcode: " + opcode); });
    }
}
```

**验收标准**:
- [ ] `InstructionFactory` 类创建完成
- [ ] 所有 42 条指令注册到工厂
- [ ] 所有测试通过
- [ ] 支持动态添加新指令

---

### 2.4 第四阶段：接口抽象与包结构优化（预计 5-7 天）

#### 任务 2.4.1：定义核心接口
**优先级**: 🟡 中
**预计工时**: 10 小时

**目标**: 为核心组件定义接口，支持依赖注入

**具体任务**:
```java
// 虚拟机接口
public interface IVirtualMachine {
    void load(InputStream input) throws Exception;
    void execute() throws Exception;
    int getRegister(int regNum);
    void setRegister(int regNum, int value);
    VMConfig getConfig();
}

// 指令执行器接口
public interface IInstructionExecutor {
    void execute(int operand, ExecutionContext context) throws Exception;
    default boolean isSpecialInstruction() { return false; }
}

// 配置接口
public interface IVMConfig {
    int getHeapSize();
    int getLocalsSize();
    int getMaxCallStackDepth();
    int getMaxExecutionSteps();
}
```

**验收标准**:
- [ ] 所有核心接口定义完成
- [ ] 接口包含完整的 JavaDoc
- [ ] 现有类实现对应接口
- [ ] 所有测试通过

---

#### 任务 2.4.2：重构包结构
**优先级**: 🟡 中
**预计工时**: 12 小时

**目标**: 按职责重新组织 `stackvm` 包，提高内聚性

**具体任务**:
```
org.teachfx.antlr4.ep18r.stackvm/
├── interpreter/           # 解释器核心
│   ├── RegisterVMInterpreter.java
│   ├── IVirtualMachine.java
│   └── ExecutionContext.java
├── instructions/          # 指令系统
│   ├── factory/          # InstructionFactory
│   ├── executors/        # 各种执行器
│   ├── strategies/       # 执行策略
│   └── model/            # 指令数据模型
├── memory/               # 内存管理
│   ├── RegisterFile.java
│   ├── MemorySpace.java
│   └── HeapManager.java
├── registers/            # 寄存器系统
│   ├── RegisterFile.java
│   ├── RegisterAllocator.java
│   └── RegisterOperandExtractor.java
├── callingconvention/    # 调用约定
│   ├── RegisterSaver.java
│   ├── StackFrameManager.java
│   ├── ParameterPassing.java
│   └── ABIValidator.java
├── config/               # 配置系统
│   ├── VMConfig.java
│   ├── VMConfigBuilder.java
│   └── IVMConfig.java
└── exception/            # 异常体系
    ├── VMException.java
    ├── InvalidOpcodeException.java
    └── DivisionByZeroException.java
```

**验收标准**:
- [ ] 新包结构创建完成
- [ ] 所有类迁移到新位置
- [ ] 包导入更新完成
- [ ] 所有测试通过
- [ ] 包内聚性提升

---

#### 任务 2.4.3：实现依赖注入
**优先级**: 🟡 中
**预计工时**: 8 小时

**目标**: 使用构造器注入替代硬编码依赖

**具体任务**:
```java
// 使用构造器注入替代硬编码依赖
public class RegisterVMInterpreter implements IVirtualMachine {
    private final IVMConfig config;
    private final IInstructionFactory instructionFactory;
    private final IRegisterFile registerFile;
    private final IMemoryManager memoryManager;
    
    public RegisterVMInterpreter(IVMConfig config, 
                                 IInstructionFactory factory,
                                 IRegisterFile registers,
                                 IMemoryManager memory) {
        this.config = config;
        this.instructionFactory = factory;
        this.registerFile = registers;
        this.memoryManager = memory;
    }
}
```

**验收标准**:
- [ ] 核心类支持依赖注入
- [ ] 依赖通过构造器传入
- [ ] 所有测试通过
- [ ] 可测试性提升

---

### 2.5 第五阶段：测试增强与性能优化（预计 4-6 天）

#### 任务 2.5.1：测试策略升级
**优先级**: 🟡 中
**预计工时**: 16 小时

**目标**: 完善测试策略，提升测试覆盖率

**具体任务**:
1. **单元测试**: 每个核心类≥90%覆盖率
2. **集成测试**: 测试组件间交互
3. **性能测试**: JMH基准测试对比栈式vs寄存器式
4. **ABI测试**: 调用约定兼容性验证

**验收标准**:
- [ ] 测试覆盖率≥85%
- [ ] 核心类覆盖率≥90%
- [ ] 集成测试用例≥20个
- [ ] 性能基准测试建立

---

#### 任务 2.5.2：新增测试类
**优先级**: 🟡 中
**预计工时**: 12 小时

**具体任务**:
1. **RegisterVMInterpreterUnitTest** - 单元测试（200+测试方法）
2. **InstructionExecutorTest** - 指令执行器测试
3. **CallingConventionIntegrationTest** - 调用约定集成测试
4. **RegisterAllocationTest** - 寄存器分配测试
5. **PerformanceBenchmark** - JMH性能基准测试

**验收标准**:
- [ ] 所有新测试类创建完成
- [ ] 测试命名遵循规范
- [ ] 测试覆盖率达标
- [ ] 所有测试通过

---

#### 任务 2.5.3：性能优化点
**优先级**: 🟢 低
**预计工时**: 16 小时

**具体任务**:
1. **指令缓存**: 预解码常用指令
2. **寄存器分配优化**: 改进 LinearScanAllocator 算法
3. **内存访问优化**: 批量内存操作
4. **跳转预测**: 简单分支预测提高流水线效率

**验收标准**:
- [ ] 指令缓存实现
- [ ] 寄存器分配器优化
- [ ] 性能提升≥10%
- [ ] 内存访问优化

---

### 2.6 第六阶段：文档与规范（预计 2-3 天）

#### 任务 2.6.1：架构文档
**优先级**: 🟢 低
**预计工时**: 4 小时

**内容**: 同步最新实现状态，更新接口说明

---

#### 任务 2.6.2：代码规范
**优先级**: 🟢 低
**预计工时**: 6 小时

**内容**: 为所有公共类/方法添加完整Javadoc

---

## 3. 与EP21联动策略

### 3.1 联动目标

EP18R与EP21协同优化，避免重复开发，提高整体效率：

| 维度 | EP18R现状 | EP21现状 | 联动后价值 |
|------|----------|---------|-----------|
| **寄存器分配** | 成熟LinearScanAllocator | 简单round-robin | 统一使用高质量分配器 |
| **代码生成** | 不涉及 | 两个生成器 | 工厂模式动态选择 |
| **测试覆盖** | 79测试(100%) | 563测试(100%) | 端到端集成测试 |
| **代码重复** | 25%重复率 | 低重复 | 共享测试基础设施 |
| **架构清晰度** | 存在上帝类 | 良好接口抽象 | 统一架构规范 |

### 3.2 关键联动点

#### 联动点1：寄存器分配器集成

**现状**：
- EP21的RegisterVMGenerator使用简单的round-robin分配
- EP18R已有成熟的LinearScanAllocator（526行）

**联动计划**：
1. **TASK-VM-04.1**：适配EP18R的IRegisterAllocator接口以适配EP21（4小时）
2. **TASK-18R-VM-02**：集成EP18R的LinearScanAllocator到EP21的RegisterVMGenerator（6小时）

**预期收益**：
- 寄存器利用率从~50%提升到≥70%
- 支持寄存器溢出处理
- 代码生成质量提升

#### 联动点2：代码生成器工厂

**现状**：
- EP21的Compiler.java硬编码使用StackVMGenerator
- 无动态选择生成器的机制

**联动计划**：
- **TASK-2.4.4**：创建GeneratorFactory，支持根据配置选择StackVM或RegisterVM（6小时）

**预期收益**：
- 支持动态目标VM选择
- 便于扩展新的代码生成器
- 提高代码灵活性

#### 联动点3：调用约定统一

**现状**：
- EP18R的CallingConventionUtils定义了完整的调用约定
- EP21的RegisterVMGenerator需要实现相同的调用约定

**联动计划**：
- **TASK-18R-VM-05**：EP18R调用约定（4小时）
- **TASK-18R-VM-06**：EP18R适配器接口（2小时）

**预期收益**：
- 调用约定100%一致
- 保证代码互操作性
- 减少维护成本

### 3.3 集成测试计划

**EP21→EP18R端到端集成测试**：
- **TASK-EP21-TEST-01**：创建EP21→EP18R集成测试套件（6小时）
- **TASK-EP21-TEST-02**：语义等价性测试（EP18 vs EP18R结果对比）（8小时）

**测试用例覆盖**：
1. 简单算术表达式
2. 变量定义和使用
3. 条件语句if-else
4. while循环
5. 函数调用（无参数、带参数）
6. 嵌套函数调用
7. 递归函数
8. 数组访问
9. 结构体成员访问
10. 全局变量
11. 指针操作
12. 寄存器溢出处理
13. 调用约定验证
14. 异常处理
15. 性能对比
16. 边界条件
17. 浮点运算
18. 逻辑运算
19. 复杂程序
20. 完整编译管道

**验收标准**：
- EP18和EP18R执行结果100%一致
- 性能提升≥10%（EP18R vs EP18）
- 测试覆盖率≥85%

### 3.4 执行协调机制

**里程碑同步**：
- **M1**（阶段1完成）：EP18R基础设施+接口统一，EP21准备接入
- **M2**（阶段2完成）：EP18R代码重复消除，EP21集成LinearScanAllocator
- **M3**（阶段3完成）：EP18R调用约定统一，EP21RegisterVMGenerator完整
- **M4**（阶段4完成）：EP18R包结构优化，EP21→EP18R集成测试
- **M5**（阶段5完成）：测试增强完成，性能验证通过

**沟通机制**：
- **双周会议**：同步进度，协调接口变更
- **接口变更通知**：任何接口变更需提前通知双方
- **集成测试触发**：每个里程碑完成后触发集成测试

**风险缓解**：
- 保持向后兼容的包装类
- 分阶段迁移，明确弃用标记
- 保留回滚点，每个阶段创建git tag

### 3.5 预期收益

**工期节省**：
- 独立执行：142小时（EP18R）+ 61小时（EP21）= 203小时
- 融合并行执行：~75小时（9-10周）
- **节省128小时（63%）**

**代码质量提升**：
- EP18R：代码重复率25% → <15%
- EP21：寄存器分配质量显著提升
- 统一测试基础设施

**集成稳定性**：
- EP18和EP18R执行结果100%一致
- 跨模块测试覆盖率≥85%

**详细执行计划**：参见 [EP18R-EP21联动融合计划](EP18R-EP21联动融合计划.md)

---

## 4. 风险与缓解措施

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| **破坏现有功能** | 高 | 中 | 1. TDD方式开发，先写测试<br>2. 逐步重构，每个阶段验证<br>3. 保留回滚点 |
| **性能下降** | 中 | 低 | 1. 每阶段性能基准测试<br>2. 关键路径性能分析<br>3. 可选优化开关 |
| **接口变更影响其他模块** | 中 | 中 | 1. 保持向后兼容的包装类<br>2. 分阶段迁移计划<br>3. 明确弃用标记和迁移指南 |
| **测试覆盖率下降** | 低 | 中 | 1. 每次提交检查覆盖率<br>2. 覆盖率门禁（<85%失败）<br>3. 自动化测试生成工具 |

---

## 5. 实施优先级与时间线（已与EP21融合）

**说明**：本时间线已与EP21联动融合，详见 [EP18R-EP21联动融合计划](EP18R-EP21联动融合计划.md)

```mermaid
gantt
    title EP18R 架构优化时间线（融合版本）
    dateFormat  YYYY-MM-DD

    section 阶段1：基础设施与接口统一
    代码质量工具配置         :2026-01-09, 1d
    基线测试覆盖建立         :2026-01-10, 2d
    定义核心接口             :2026-01-12, 3d
    适配IRegisterAllocator接口 :crit, 2026-01-15, 1d

    section 阶段2：代码优化与寄存器分配集成
    寄存器操作工具类提取     :2026-01-16, 2d
    指令执行模板创建         :2026-01-18, 3d
    集成LinearScanAllocator  :crit, 2026-01-20, 1d
    提取栈帧管理器           :2026-01-21, 2d
    统一ABI寄存器映射         :2026-01-23, 1d

    section 阶段3：上帝类拆分与调用约定统一
    拆分CallingConventionUtils :crit, 2026-01-24, 4d
    EP18R调用约定            :2026-01-28, 1d
    EP18R适配器接口          :2026-01-29, 1d
    创建GeneratorFactory     :2026-01-30, 1d
    重构RegisterVMInterpreter :2026-01-31, 3d
    引入指令工厂             :2026-02-03, 2d

    section 阶段4：包结构优化与依赖注入
    重构包结构               :2026-02-05, 2d
    实现依赖注入             :2026-02-07, 2d
    集成测试                 :2026-02-09, 1d
    32位字节码编码器         :2026-02-10, 1d

    section 阶段5：测试增强与文档完善
    测试策略升级             :2026-02-11, 3d
    EP21→EP18R集成测试       :crit, 2026-02-14, 1d
    语义等价性测试           :2026-02-15, 2d
    新增测试类               :2026-02-17, 2d
    性能优化                 :2026-02-19, 3d
    架构文档                 :2026-02-22, 1d
    代码规范                 :2026-02-23, 1d
```

**总计**: 约 9-10 周（融合并行执行）

**说明**：
- 标注 `:crit` 的任务为关键路径任务
- 融合后工期比独立执行节省 128小时（63%）
- 详细依赖关系和并行策略参见 [EP18R-EP21联动融合计划](EP18R-EP21联动融合计划.md)

---

## 6. 预期成果与验收标准

```mermaid
gantt
    title EP18R 架构优化时间线
    dateFormat  YYYY-MM-DD

    section 第一阶段：基础设施
    代码质量工具配置     :2026-01-09, 3d
    基线测试覆盖建立     :2026-01-10, 2d
    
    section 第二阶段：代码重复消除
    寄存器操作工具类提取 :2026-01-12, 3d
    指令执行模板创建     :2026-01-13, 4d
    相似执行器合并       :2026-01-15, 3d
    
    section 第三阶段：上帝类拆分
    CallingConventionUtils拆分 :2026-01-18, 5d
    executeInstruction重构     :2026-01-20, 4d
    指令工厂引入           :2026-01-23, 3d
    
    section 第四阶段：接口抽象
    核心接口定义         :2026-01-25, 3d
    包结构重构          :2026-01-27, 5d
    依赖注入实现         :2026-01-30, 4d
    
    section 第五阶段：测试增强
    单元测试增强         :2026-02-03, 5d
    集成测试添加         :2026-02-06, 4d
    性能基准测试         :2026-02-08, 3d
    
    section 第六阶段：文档
    架构文档编写         :2026-02-10, 3d
    代码规范完善         :2026-02-11, 2d
```

**总计**: 约 6 周（30 个工作日）

---

## 5. 预期成果与验收标准

### 6.1 代码质量指标

| 指标 | 当前值 | 目标值 | 测量方法 |
|------|--------|--------|---------|
| 代码重复率 | ~25% | < 15% | CPD（复制粘贴检测） |
| 圈复杂度（平均） | 12.5 | ≤ 8.0 | JaCoCo 复杂度分析 |
| 方法长度（平均） | 45 行 | ≤ 30 行 | CheckStyle 检查 |
| 测试覆盖率 | 未测量 | ≥ 85% | JaCoCo 报告 |
| SpotBugs 问题 | 未测量 | 0 严重问题 | SpotBugs 报告 |
| CheckStyle 违规 | 未测量 | 0 错误级别违规 | CheckStyle 报告 |

### 6.2 架构改进指标

1. **接口抽象度**：核心组件接口抽象比例 ≥ 70%
2. **包内聚性**：单个包职责单一，类数量 ≤ 15
3. **依赖清晰度**：循环依赖数为 0，依赖方向明确
4. **可测试性**：所有核心类可独立单元测试

### 6.3 性能指标

1. **指令执行速度**：相比当前版本提升 ≥ 10%
2. **内存使用**：峰值内存使用降低 ≥ 15%
3. **启动时间**：虚拟机初始化时间减少 ≥ 20%
4. **GC 开销**：垃圾回收暂停时间减少 ≥ 25%

---

## 7. 下一步行动

### 7.1 立即行动（本周）
1. **运行现有测试基线**：`mvn test jacoco:report`（需先添加JaCoCo）
2. **添加代码质量工具**：更新 pom.xml 配置
3. **创建重构跟踪看板**：使用 GitHub Projects 或类似工具

### 7.2 短期行动（1-2 周）
1. **开始第二阶段**：提取 `RegisterOperandExtractor`
2. **建立性能基准**：运行初步性能测试
3. **代码审查会议**：评审当前架构问题

### 7.3 长期规划
1. **考虑与 EP18 的代码共享**：识别可提取的公共组件
2. **探索 JIT 编译可能性**：为寄存器模型设计简单 JIT
3. **工具链集成**：IDE 插件、调试器支持

---

## 8. 相关资源

- **详细任务分解**: [详细任务分解.md](详细任务分解.md)
- **TDD执行计划**: [TDD执行计划_精简版.md](TDD执行计划_精简版.md)
- **架构设计规范**: [架构设计规范.md](架构设计规范.md)
- **EP18R-EP21联动融合计划**: [EP18R-EP21联动融合计划.md](EP18R-EP21联动融合计划.md)

---

**最后更新**: 2026-01-08
**维护者**: Claude Code
**状态**: 📝 改进路线图v2.0，已与EP21融合
