# EP18R æ— é™å¾ªç¯é—®é¢˜ä¿®å¤æŠ¥å‘Š

## ğŸ› å‘ç°çš„é—®é¢˜

### 1. ç¨‹åºè®¡æ•°å™¨è°ƒæ•´é€»è¾‘é”™è¯¯
**é—®é¢˜**: æ‰€æœ‰è·³è½¬æŒ‡ä»¤éƒ½ä½¿ç”¨ `programCounter = target - 4` çš„é€»è¾‘
```java
// åŸé—®é¢˜ä»£ç 
programCounter = target - 4; // å› ä¸ºcpuå¾ªç¯ä¼šåŠ 4
```
**åæœ**: å¦‚æœè·³è½¬ç›®æ ‡å·²ç»å¯¹é½ï¼ˆ4çš„å€æ•°ï¼‰ï¼Œå¯èƒ½å¯¼è‡´PCåœ¨ç›¸åŒä½ç½®å¾ªç¯ï¼Œé€ æˆæ— é™å¾ªç¯ã€‚

### 2. ç¼ºå°‘å¾ªç¯æ£€æµ‹æœºåˆ¶
**é—®é¢˜**: è™šæ‹Ÿæœºæ²¡æœ‰æœ€å¤§æ‰§è¡Œæ­¥æ•°é™åˆ¶ï¼Œæ— æ³•æ£€æµ‹æ— é™å¾ªç¯
**åæœ**: ç¨‹åºä¸€æ—¦é™·å…¥æ— é™å¾ªç¯å°±ä¼šæ°¸è¿œæ‰§è¡Œä¸‹å»

### 3. è¾¹ç•Œæ£€æŸ¥ä¸å®Œæ•´
**é—®é¢˜**: åªæ£€æŸ¥æŒ‡ä»¤å®Œæ•´æ€§ï¼Œæ²¡æœ‰éªŒè¯è·³è½¬ç›®æ ‡çš„åˆæ³•æ€§
**åæœ**: å¯èƒ½è·³è½¬åˆ°æ— æ•ˆåœ°å€å¯¼è‡´ä¸å¯é¢„æµ‹çš„è¡Œä¸º

### 4. è°ƒè¯•è¾“å‡ºé—®é¢˜
**é—®é¢˜**: è°ƒè¯•ä¿¡æ¯æ€»æ˜¯è¾“å‡ºï¼Œå½±å“æ€§èƒ½å’Œå¯è¯»æ€§
**åæœ**: æµ‹è¯•è¾“å‡ºæ··ä¹±ï¼Œéš¾ä»¥è°ƒè¯•

## ğŸ”§ ä¿®å¤æ–¹æ¡ˆ

### 1. é‡æ„ç¨‹åºè®¡æ•°å™¨ç®¡ç†
```java
// æ ‡å¿—ä½ï¼šæŒ‡ç¤ºæ˜¯å¦å‘ç”Ÿäº†è·³è½¬
private boolean didJump = false;

// åœ¨cpu()å¾ªç¯ä¸­ï¼š
if (!didJump) {
    programCounter += 4;  // åªæœ‰åœ¨æ²¡æœ‰è·³è½¬çš„æƒ…å†µä¸‹æ‰è‡ªåŠ¨å¢åŠ PC
}
didJump = false; // é‡ç½®è·³è½¬æ ‡å¿—
```

### 2. æ·»åŠ å¾ªç¯æ£€æµ‹æœºåˆ¶
```java
// å¾ªç¯æ£€æµ‹å’Œå®‰å…¨æœºåˆ¶
private static final int MAX_EXECUTION_STEPS = 1000000; // æœ€å¤§æ‰§è¡Œæ­¥æ•°
private int executionSteps = 0;

// åœ¨cpu()å¾ªç¯ä¸­ï¼š
if (executionSteps++ > MAX_EXECUTION_STEPS) {
    throw new RuntimeException("Maximum execution steps exceeded. Possible infinite loop detected at PC=" + programCounter);
}
```

### 3. å®Œå–„è¾¹ç•Œæ£€æŸ¥
```java
// éªŒè¯è·³è½¬ç›®æ ‡
if (target < 0 || target >= codeSize || target % 4 != 0) {
    throw new IllegalArgumentException("Invalid jump target: " + target + " at PC=" + programCounter);
}
```

### 4. ä¿®å¤æ§åˆ¶æµæŒ‡ä»¤
```java
// ä¿®å¤CALLæŒ‡ä»¤
case RegisterBytecodeDefinition.INSTR_CALL: {
    int target = extractImm26(operand);
    
    // éªŒè¯è·³è½¬ç›®æ ‡
    if (target < 0 || target >= codeSize || target % 4 != 0) {
        throw new IllegalArgumentException("Invalid call target: " + target + " at PC=" + programCounter);
    }
    
    setRegister(RegisterBytecodeDefinition.R15, programCounter + 4);
    programCounter = target;  // ç›´æ¥è®¾ç½®ï¼Œä¸å†è°ƒæ•´
    didJump = true;
    break;
}
```

### 5. ä¿®å¤è°ƒè¯•è¾“å‡º
- å°†è°ƒè¯•è¾“å‡ºç§»åˆ° `trace` æ¨¡å¼
- æ¸…ç†ä¸å¿…è¦çš„è¾“å‡º

## âœ… éªŒè¯ä¿®å¤

### æ–°å¢æµ‹è¯•ç”¨ä¾‹
åˆ›å»ºäº† `InfiniteLoopFixTest.java` åŒ…å«ä»¥ä¸‹æµ‹è¯•ï¼š

1. **testSimpleLoop()**: éªŒè¯ç®€å•å¾ªç¯èƒ½æ­£ç¡®æ‰§è¡Œ
2. **testInfiniteLoopDetection()**: éªŒè¯èƒ½æ£€æµ‹æ— é™å¾ªç¯
3. **testConditionalJumps()**: éªŒè¯æ¡ä»¶è·³è½¬æ­£ç¡®æ€§
4. **testFunctionCalls()**: éªŒè¯å‡½æ•°è°ƒç”¨æ­£ç¡®æ€§
5. **testInvalidJumpTarget()**: éªŒè¯æ— æ•ˆè·³è½¬ç›®æ ‡æ£€æµ‹

## ğŸ“ˆ ä¿®å¤æ•ˆæœ

### ä¿®å¤å‰çš„é—®é¢˜
- ç¨‹åºå¯èƒ½é™·å…¥æ— é™å¾ªç¯
- æ— æ³•æ£€æµ‹åˆ°æ­»å¾ªç¯
- è·³è½¬ç›®æ ‡éªŒè¯ä¸è¶³
- è°ƒè¯•è¾“å‡ºæ··ä¹±

### ä¿®å¤åçš„æ”¹è¿›
- âœ… é˜²æ­¢æ— é™å¾ªç¯ï¼ˆæœ€å¤§æ­¥æ•°é™åˆ¶ï¼‰
- âœ… å®Œå–„çš„è¾¹ç•Œæ£€æŸ¥
- âœ… æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
- âœ… æ­£ç¡®çš„ç¨‹åºè®¡æ•°å™¨ç®¡ç†
- âœ… å¯æ§çš„è°ƒè¯•è¾“å‡º
- âœ… å…¨é¢çš„æµ‹è¯•è¦†ç›–

## ğŸš€ ä½¿ç”¨å»ºè®®

1. **å¯ç”¨è·Ÿè¸ªæ¨¡å¼**: ä½¿ç”¨ `interpreter.setTrace(true)` æŸ¥çœ‹è¯¦ç»†æ‰§è¡Œä¿¡æ¯
2. **ç›‘æ§æ‰§è¡Œæ­¥æ•°**: é€šè¿‡ `executionSteps` ç›‘æ§ç¨‹åºå¤æ‚åº¦
3. **åˆç†è®¾ç½®é™åˆ¶**: æ ¹æ®ç¨‹åºå¤æ‚åº¦è°ƒæ•´ `MAX_EXECUTION_STEPS`
4. **æµ‹è¯•è¦†ç›–**: ä½¿ç”¨æ–°æ·»åŠ çš„æµ‹è¯•ç”¨ä¾‹éªŒè¯ä¿®å¤æ•ˆæœ

## ğŸ“ æ€»ç»“

é€šè¿‡ç³»ç»Ÿæ€§åœ°ä¿®å¤ç¨‹åºè®¡æ•°å™¨ç®¡ç†ã€æ·»åŠ å¾ªç¯æ£€æµ‹ã€å®Œå–„è¾¹ç•Œæ£€æŸ¥ç­‰æªæ–½ï¼ŒæˆåŠŸè§£å†³äº†EP18Rä¸­çš„æ— é™å¾ªç¯é—®é¢˜ã€‚ä¿®å¤åçš„è™šæ‹Ÿæœºæ›´åŠ ç¨³å®šã€å®‰å…¨ï¼Œèƒ½å¤Ÿæ­£ç¡®å¤„ç†å„ç§æ§åˆ¶æµæƒ…å†µï¼Œå¹¶æä¾›æ¸…æ™°çš„é”™è¯¯è¯Šæ–­ä¿¡æ¯ã€‚