[TOC]

# 如何实现一个可自定义算术函数的简单编程语言(Cymbol)

## 目标语言的简单定义

### 词法单元

### 语法定义--EBNF

### 如何求值？

这个问题曾经困扰了我数年之久，抱歉我确实很迟钝也不爱直接接受书本上的理论。
因此，我回到了二进制加法计算的底层实现化简。即通过两个半加器的全加器。

### 作用域与求值

为什么需要作用域？

### 作用域是什么？

#### 词法作用域

module作用域 > 文件作用域 > 类或闭包作用域 > 函数作用域 > 基础块作用域
作用域嵌套情况下，内层作用域中的变量总能够访问父级作用域中可见的任意变量。

##### 静态作用域

Cymbol是一个以文件作为module基础单位的静态作用域的强类型语言。
每一个文件是一个独立的文件作用域。

## 实现思路

## 代码分解

### 实现分词

### 语法分析

### 语义分析

### function的语义是什么？

#### 类型检查

##### 1. 符号类型与值匹配

##### 2. 操作符合法性检查

##### 3. 函数类型检查

### Expr的求值

### Function的求值

#### 1. Function和Expr有什么不同？

Function拥有独立的作用域的一组Expr求值的过程描述。比如，

```
int add(int x, int y) {
    return x + y;
}
```

Function实际上由一组给定的形参(`int x, int y`)构成独立作用域，这组形参也被我们成为定义这个函数的参数列表。
我们实际上只是在Expr求值的基础上增加了一个独立作用域来隔离和保存计算过程与结果。同时，需要
注意的是，我们函数可以引用自其向上所有可见作用域的变量。

#### 2. Function和Block有什么不同？

实际上，根据上面的回答我们可以直到，函数就是参数列表加上block形成的一个计算过程。

#### 3. Function的求值环境（作用域）

求值环境就是从当前函数向上搜索可见作用域加上参数列表。
需要注意的是，我们有两个环境需要注意，一个是定义，一个是调用。

```
int z = 10;
int addOffset(int x, int y) {
    return x + y * z;
}

int c = 1;
int b = 2;
int q = addOffset(c,b);

```

#### 4. Function的执行
