# EP18R 架构设计规范

**版本**: 1.0.0
**发布日期**: 2026-01-08
**最后更新**: 2026-01-08
**目标读者**: 虚拟机学习者、开发者、教育工作者
**规范状态**: 批准 (Approved)

## 📋 规范概览

### 1.1 规范目的

本规范旨在为EP18R寄存器虚拟机项目提供清晰、现代化、教育导向的架构设计指南。EP18R是基于寄存器架构的独立虚拟机模块，采用寄存器指令集和优化的执行模型，专注于寄存器架构的性能优势。它是EP18栈式虚拟机的寄存器版本实现，使用16个通用寄存器（r0-r15）和42条寄存器指令。

### 1.2 核心原则

1. **教育优先原则**: 架构设计优先考虑教学价值和可理解性
2. **现代性原则**: 采用现代寄存器架构设计模式和最佳实践
3. **RISC-V风格**: 仿照RISC-V调用约定，便于学习和对比
4. **分层清晰原则**: 明确分层架构，职责边界清晰
5. **扩展性原则**: 提供清晰的扩展点和插件机制
6. **一致性原则**: 保持接口和行为的一致性

### 1.3 规范结构

- **第2章**: 整体架构规范
- **第3章**: 寄存器系统规范
- **第4章**: 指令集规范
- **第5章**: 调用约定规范
- **第6章**: 内存管理规范
- **第7章**: 执行引擎规范
- **第8章**: 工具链规范
- **第9章**: 扩展性规范
- **第10章**: 符合性要求

---

## 2. 整体架构规范

### 2.1 架构分层模型

EP18R寄存器虚拟机采用**四层架构模型**，每层有明确的输入输出和职责边界：

```
┌─────────────────────────────────────────────────────┐
│                   应用层 (Application)                │
│  • 命令行接口 (CLI)                                  │
│  • 集成开发环境插件                                 │
│  • 测试框架集成                                     │
└─────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────┐
│                   汇编层 (Assembly)                   │
│  • 汇编器 (RegisterByteCodeAssembler)                │
│  • 反汇编器 (RegisterDisAssembler)                  │
│  • 标签解析 (LabelSymbol)                           │
└─────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────┐
│              执行引擎层 (Execution Engine)            │
│  • 取指-解码-执行循环                               │
│  • 寄存器文件 (RegisterFile)                         │
│  • 调用栈管理 (Call Stack)                           │
└─────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────┐
│                   运行时层 (Runtime)                   │
│  • 内存管理 (MemoryManager)                          │
│  • 垃圾回收 (GarbageCollector)                       │
│  • 异常处理 (ExceptionHandler)                       │
└─────────────────────────────────────────────────────┘
```

### 2.2 数据流契约

每层之间通过明确定义的**数据契约**进行通信：

| 转换阶段 | 输入格式 | 输出格式 | 转换责任 |
|----------|----------|----------|----------|
| 汇编 | 汇编代码 (.vmr) | 字节码 (.vm) | 语法分析、指令编码 |
| 加载 | 字节码文件 | 内存映像 | 常量池解析、代码段加载 |
| 取指 | 内存映像 | 指令字 (32-bit) | 指令读取 |
| 解码 | 指令字 | 操作码+操作数 | 指令识别、操作数提取 |
| 执行 | 操作码+操作数 | 状态更新 | 操作执行、状态修改 |

### 2.3 接口规范

所有层间接口必须遵循以下规范：

1. **不可变数据**: 跨层传递的数据结构必须是不可变的
2. **纯函数转换**: 层间转换函数应该是纯函数，无副作用
3. **错误传播**: 使用统一的错误类型和传播机制
4. **类型安全**: 所有接口使用强类型，避免原始类型

---

## 3. 寄存器系统规范

### 3.1 寄存器定义

EP18R提供16个32位通用寄存器（r0-r15），每个寄存器都有特定的ABI名称和用途。

| 寄存器 | ABI名称 | 保存者 | 描述 |
|--------|---------|--------|------|
| r0 | zero | - | 硬连线为零，写入无效 |
| r1 | ra | 调用者 | 返回地址（兼容性用途）/临时值 |
| r2 | a0 | 调用者 | 函数参数1/返回值 |
| r3 | a1 | 调用者 | 函数参数2/临时值 |
| r4 | a2 | 调用者 | 函数参数3/临时值 |
| r5 | a3 | 调用者 | 函数参数4/临时值 |
| r6 | a4 | 调用者 | 函数参数5/临时值 |
| r7 | a5 | 调用者 | 函数参数6/临时值 |
| r8 | s0 | 被调用者 | 保存寄存器1 |
| r9 | s1 | 被调用者 | 保存寄存器2 |
| r10 | s2 | 被调用者 | 保存寄存器3 |
| r11 | s3 | 被调用者 | 保存寄存器4 |
| r12 | s4 | 被调用者 | 保存寄存器5 |
| r13 | sp | 被调用者 | 栈指针（Stack Pointer） |
| r14 | fp | 被调用者 | 帧指针（Frame Pointer） |
| r15 | lr | 调用者 | 链接寄存器（Link Register） |

### 3.2 寄存器文件特性

- **位宽**: 32位整数/浮点统一寄存器
- **数量**: 16个物理寄存器
- **寻址**: 5位寄存器编号（0-15）
- **特殊寄存器**: r0硬连线到0，r13-r15有特殊用途

### 3.3 寄存器保存责任

#### 调用者保存寄存器（Caller-saved / 临时寄存器）
- **寄存器**: ra (r1), a0-a5 (r2-r7), lr (r15)
- **责任**: 调用者在调用前保存这些寄存器的值（如果需要）
- **特点**: 被调用者可以自由使用，无需保存/恢复
- **用途**: 传递参数、存储临时计算结果、存储不需要跨调用保存的值

#### 被调用者保存寄存器（Callee-saved / 保存寄存器）
- **寄存器**: s0-s4 (r8-r12), sp (r13), fp (r14)
- **责任**: 被调用者如果使用这些寄存器，必须在函数入口保存，在函数出口恢复
- **特点**: 值在函数调用间保持不变
- **用途**: 存储需要在函数调用间保持的局部变量、栈和帧指针

### 3.4 特殊寄存器行为

- **zero (r0)**: 始终为0，写入操作被忽略
- **sp (r13)**: 栈指针，指向当前栈顶（低地址方向）
- **fp (r14)**: 帧指针，指向当前栈帧的基址
- **lr (r15)**: 链接寄存器，存储返回地址（与调用栈并存）

---

## 4. 指令集规范

### 4.1 指令格式

所有指令均为32位固定长度，支持三种格式：

#### R类型（寄存器-寄存器运算）
```
 31        26 25     21 20     16 15     11 10         0
┌────────────┬─────────┬─────────┬─────────┬─────────────┐
│   opcode   │    rd   │   rs1   │   rs2   │   unused    │
│    (6)     │   (5)   │   (5)   │   (5)   │    (11)     │
└────────────┴─────────┴─────────┴─────────┴─────────────┘
```
- **用途**: 算术运算、逻辑运算、比较运算
- **示例**: `add r3, r1, r2` (r3 = r1 + r2)

#### I类型（立即数/内存访问）
```
 31        26 25     21 20     16 15                    0
┌────────────┬─────────┬─────────┬───────────────────────┐
│   opcode   │    rd   │   rs1   │      immediate        │
│    (6)     │   (5)   │   (5)   │         (16)          │
└────────────┴─────────┴─────────┴───────────────────────┘
```
- **用途**: 立即数加载、内存访问、条件跳转
- **示例**: `li r1, 100` (r1 = 100), `lw r2, r14, 8` (r2 = memory[FP+8])

#### J类型（跳转指令）
```
 31        26 25                                         0
┌────────────┬───────────────────────────────────────────┐
│   opcode   │               address                     │
│    (6)     │                  (26)                     │
└────────────┴───────────────────────────────────────────┘
```
- **用途**: 无条件跳转、函数返回
- **示例**: `j 0x1000` (跳转到地址0x1000), `ret` (从调用栈返回)

### 4.2 操作码分配表

| 操作码 | 指令 | 格式 | 操作数类型 | 语义描述 |
|--------|------|------|------------|----------|
| **算术指令** |
| 1 | add | R | rd, rs1, rs2 | 整数加法：rd = rs1 + rs2 |
| 2 | sub | R | rd, rs1, rs2 | 整数减法：rd = rs1 - rs2 |
| 3 | mul | R | rd, rs1, rs2 | 整数乘法：rd = rs1 * rs2 |
| 4 | div | R | rd, rs1, rs2 | 整数除法：rd = rs1 / rs2 |
| **比较指令** |
| 5 | slt | R | rd, rs1, rs2 | 小于设置：rd = (rs1 < rs2) ? 1 : 0 |
| 6 | sle | R | rd, rs1, rs2 | 小于等于设置：rd = (rs1 ≤ rs2) ? 1 : 0 |
| 7 | sgt | R | rd, rs1, rs2 | 大于设置：rd = (rs1 > rs2) ? 1 : 0 |
| 8 | sge | R | rd, rs1, rs2 | 大于等于设置：rd = (rs1 ≥ rs2) ? 1 : 0 |
| 9 | seq | R | rd, rs1, rs2 | 等于设置：rd = (rs1 == rs2) ? 1 : 0 |
| 10 | sne | R | rd, rs1, rs2 | 不等于设置：rd = (rs1 != rs2) ? 1 : 0 |
| **逻辑指令** |
| 11 | neg | R | rd, rs1 | 整数取负：rd = -rs1 |
| 12 | not | R | rd, rs1 | 按位取反：rd = ~rs1 |
| 13 | and | R | rd, rs1, rs2 | 按位与：rd = rs1 & rs2 |
| 14 | or | R | rd, rs1, rs2 | 按位或：rd = rs1 \| rs2 |
| 15 | xor | R | rd, rs1, rs2 | 按位异或：rd = rs1 ^ rs2 |
| **浮点指令** |
| 16 | fadd | R | rd, rs1, rs2 | 浮点加法：rd = rs1 + rs2 |
| 17 | fsub | R | rd, rs1, rs2 | 浮点减法：rd = rs1 - rs2 |
| 18 | fmul | R | rd, rs1, rs2 | 浮点乘法：rd = rs1 * rs2 |
| 19 | fdiv | R | rd, rs1, rs2 | 浮点除法：rd = rs1 / rs2 |
| 20 | flt | R | rd, rs1, rs2 | 浮点小于：rd = (rs1 < rs2) ? 1 : 0 |
| 21 | feq | R | rd, rs1, rs2 | 浮点等于：rd = (rs1 == rs2) ? 1 : 0 |
| 22 | itof | R | rd, rs1 | 整数转浮点：rd = (float)rs1 |
| **控制流指令** |
| 23 | call | J | immediate | 函数调用：压栈返回地址；PC = target |
| 24 | ret | J | - | 函数返回：从调用栈弹出返回地址；PC = 返回地址 |
| 25 | j | J | immediate | 无条件跳转：PC = target |
| 26 | jt | I | rs1, immediate | 条件为真跳转：if (rs1 != 0) PC = target |
| 27 | jf | I | rs1, immediate | 条件为假跳转：if (rs1 == 0) PC = target |
| **加载指令** |
| 28 | li | I | rd, immediate | 加载整数立即数：rd = immediate |
| 29 | lc | I | rd, immediate | 加载字符立即数：rd = immediate |
| 30 | lf | I | rd, pool_index | 加载浮点常量：rd = pool[pool_index] |
| 31 | ls | I | rd, pool_index | 加载字符串常量：rd = pool[pool_index] |
| **存储指令** |
| 32 | lw | I | rd, base, offset | 加载字：rd = memory[base + offset] |
| 33 | sw | I | rs, base, offset | 存储字：memory[base + offset] = rs |
| 34 | lw_g | I | rd, offset | 全局加载：rd = memory[GBASE + offset] |
| 35 | sw_g | I | rs, offset | 全局存储：memory[GBASE + offset] = rs |
| **结构体指令** |
| 36 | lw_f | I | rd, offset | 字段加载：rd = memory[obj_ptr + offset] |
| 37 | sw_f | I | rs, offset | 字段存储：memory[obj_ptr + offset] = rs |
| 38 | struct | I | rd, size | 分配结构体：rd = allocate_struct(size) |
| **系统指令** |
| 39 | null | I | rd | 加载空指针：rd = NULL |
| 40 | print | I | rs | 打印寄存器值：print(rs) |
| **杂项指令** |
| 41 | mov | R | rd, rs1 | 寄存器移动：rd = rs1 |
| 42 | halt | J | - | 停止执行 |

### 4.3 指令编码规范

#### 立即数符号扩展
- **16位立即数**: 符号扩展至32位
- **26位立即数**: 符号扩展至32位
- **零扩展**: 对于无符号立即数使用零扩展

#### 寄存器编码
- **寄存器编号**: 5位无符号整数 (0-15)
- **特殊寄存器**: r0固定为0，r13-r15有特殊用途

---

## 5. 调用约定规范

### 5.1 参数传递规则

#### 整数参数传递
| 参数位置 | 传递方式 | 寄存器 | 栈偏移（当寄存器不足时） |
|----------|----------|--------|--------------------------|
| 第1个参数 | 寄存器 | a0 (r2) | - |
| 第2个参数 | 寄存器 | a1 (r3) | - |
| 第3个参数 | 寄存器 | a2 (r4) | - |
| 第4个参数 | 寄存器 | a3 (r5) | - |
| 第5个参数 | 寄存器 | a4 (r6) | - |
| 第6个参数 | 寄存器 | a5 (r7) | - |
| 第7+个参数 | 栈 | - | fp + 16 + 4*(n-7) |

#### 参数传递流程
1. **调用者准备参数**:
   - 前6个整数参数放入寄存器 a0-a5 (r2-r7)
   - 剩余参数从右向左压入栈中
   - 栈传递的参数紧接在返回地址之后

2. **被调用者访问参数**:
   - 前6个参数从寄存器 a0-a5 读取
   - 额外参数从栈中读取：`[fp + 16 + 4*(param_index-7)]`

### 5.2 返回值约定

#### 整数返回值
- **单个返回值**: 通过 a0 (r2) 寄存器返回
- **多个返回值**: 不支持（可通过结构体或指针实现）

#### 返回值流程
1. **被调用者设置返回值**: 将返回值存入 a0 (r2) 寄存器
2. **调用者获取返回值**: 从 a0 (r2) 寄存器读取返回值

### 5.3 函数调用/返回指令

#### CALL指令语义
```assembly
call target_address
```
**操作**:
1. 将返回地址（PC+4）保存到:
   - 调用栈: `callStack[++framePointer] = PC+4`
   - 链接寄存器: `lr (r15) = PC+4`（兼容性）
2. 保存调用者保存寄存器到当前栈帧的`savedCallerRegisters`数组
3. 跳转到目标地址: `PC = target_address`

#### RET指令语义
```assembly
ret
```
**操作**:
1. 从调用栈弹出返回地址: `returnAddr = callStack[framePointer--]`
2. 恢复调用者保存寄存器从栈帧的`savedCallerRegisters`数组
3. 跳转回返回地址: `PC = returnAddr`

---

## 6. 内存管理规范

### 6.1 内存布局

```
0x00000000 ┌─────────────────┐
           │   代码区        │ 存储字节码指令
0x10000000 ├─────────────────┤
           │   常量池        │ 存储浮点、字符串常量
0x20000000 ├─────────────────┤
           │   全局数据区    │ 存储全局变量
0x30000000 ├─────────────────┤
           │   堆区          │ 动态分配内存（结构体）
0x40000000 ├─────────────────┤
           │   栈区          │ 函数调用栈（向下增长）
0x50000000 └─────────────────┘
```

### 6.2 栈帧布局

```
┌─────────────────┐ 高地址
│   调用者帧      │
├─────────────────┤
│   参数7+          │   fp + 16 + 4*(n-1)
│   ...             │
│   参数8           │   fp + 20
│   参数7           │   fp + 16
├─────────────────┤
│   返回地址         │   fp + 12  (存储在调用栈中)
├─────────────────┤
│   旧FP             │   fp + 8   (fp旧值)
├─────────────────┤
│   保存寄存器s4     │   fp + 4   (r12)
│   保存寄存器s3     │   fp + 0   (r11)
│   保存寄存器s2     │   fp - 4   (r10)
│   保存寄存器s1     │   fp - 8   (r9)
│   保存寄存器s0     │   fp - 12  (r8)
├─────────────────┤
│   局部变量n       │   fp - 16 - 4*(n-1)
│   ...             │
│   局部变量2       │   fp - 20
│   局部变量1       │   fp - 16
├─────────────────┤
│   临时空间         │
└─────────────────┘ 低地址
```

### 6.3 栈帧大小计算

```
栈帧大小 = 保存寄存器区 + 局部变量区 + 临时空间 + 对齐填充

其中：
- 保存寄存器区: 5 * 4 = 20字节（s0-s4）
- 局部变量区: num_locals * 4字节
- 临时空间: 根据需要动态计算
- 对齐填充: 确保栈帧大小是8字节的倍数
```

### 6.4 栈指针对齐

- **栈指针对齐**: sp 必须保持8字节对齐（最低3位为0）
- **栈帧对齐**: 每个栈帧大小必须是8字节的倍数
- **对齐目的**: 确保内存访问性能和兼容性

---

## 7. 执行引擎规范

### 7.1 执行循环

```java
while (running) {
    // 1. 检查调试器（断点、单步）
    checkDebugger();

    // 2. 取指
    int instruction = fetchInstruction(programCounter);

    // 3. 解码
    InstructionInfo info = decodeInstruction(instruction);

    // 4. 执行前检查（权限、资源）
    if (!preExecuteCheck(info)) {
        handleExecutionError(info);
        continue;
    }

    // 5. 执行指令
    executeInstruction(info);

    // 6. 更新程序计数器（除非跳转指令已修改）
    updateProgramCounter(info);

    // 7. 更新统计信息
    updateStatistics(info);

    // 8. 检查停止条件
    if (shouldHalt()) {
        running = false;
    }
}
```

### 7.2 指令处理流水线

#### 阶段1：取指 (Fetch)
- 从指令缓存读取32位指令
- 指令缓存大小可配置（默认1024条指令）
- 支持指令预取，减少内存访问延迟

#### 阶段2：解码 (Decode)
- 解析操作码（bits[31:26]）
- 根据指令格式解析操作数
  - R类型：rd, rs1, rs2
  - I类型：rd, rs1, immediate
  - J类型：address
- 符号扩展立即数（16位→32位）

#### 阶段3：执行 (Execute)
- **算术运算**: 访问寄存器文件，执行ALU操作
- **内存访问**: 计算有效地址，加载/存储数据
- **控制流**: 更新程序计数器，处理跳转
- **特殊操作**: 系统调用、调试操作

#### 阶段4：写回 (Writeback)
- 将结果写回目标寄存器
- 更新条件标志寄存器（如有）
- 提交内存写入（如有）

### 7.3 程序计数器管理

#### 跳转标志机制
```java
private boolean didJump = false;

// 在cpu()循环中：
if (!didJump) {
    programCounter += 4;  // 只有在没有跳转的情况下才自动增加PC
}
didJump = false; // 重置跳转标志
```

#### 循环检测机制
```java
// 循环检测和安全机制
private static final int MAX_EXECUTION_STEPS = 1000000; // 最大执行步数
private int executionSteps = 0;

// 在cpu()循环中：
if (executionSteps++ > MAX_EXECUTION_STEPS) {
    throw new RuntimeException("Maximum execution steps exceeded. Possible infinite loop detected at PC=" + programCounter);
}
```

### 7.4 异常处理机制

#### 异常类型
| 异常码 | 异常名称 | 触发条件 |
|--------|----------|----------|
| 1 | 非法操作码 | 操作码不在1-42范围内 |
| 2 | 寄存器越界 | 寄存器编号不在0-15范围内 |
| 3 | 内存越界 | 访问地址超出有效内存范围 |
| 4 | 除零错误 | 整数除法除数为0 |
| 5 | 栈溢出 | 栈指针超出栈边界 |
| 6 | 栈下溢 | 栈指针低于栈底 |
| 7 | 空指针访问 | 访问空指针指向的内存 |

---

## 8. 工具链规范

### 8.1 汇编器设计

#### 汇编语言语法
```antlr4
grammar VMAssembler;

program
    :   (globalVariable | globals)?
        (functionDeclaration | instr | label | NEWLINE)+
    ;

// 全局变量声明
globalVariable : '.global' type=ID name=ID NEWLINE;

// 全局数据空间声明
globals : NEWLINE* '.globals' intVal=INT NEWLINE;

// 函数声明
functionDeclaration
    :   '.def' name=ID ':' 'args' '=' a=INT ',' 'locals' '=' lo=INT NEWLINE
    ;

// 指令
instr
    :   op=ID NEWLINE
    |   op=ID a=temp NEWLINE
    |   op=ID a=temp ',' b=temp NEWLINE
    |   op=ID a=temp ',' b=temp ',' c=temp NEWLINE
    ;
```

#### 汇编程序示例
```assembly
# 简单寄存器汇编程序示例
.globals 1024

.def main: args=0, locals=2
    li r1, 10          # 加载立即数10到r1
    li r2, 20          # 加载立即数20到r2
    add r3, r1, r2     # r3 = r1 + r2
    print r3           # 打印r3的值
    halt               # 停止执行

.def add_func: args=2, locals=0
    add r1, r1, r2     # r1 = r1 + r2 (参数在r1, r2)
    ret                # 返回，结果在r1
```

### 8.2 反汇编器设计

#### 反汇编流程
1. **字节码解析**: 读取头部、解析常量池、解析代码段
2. **指令解码**: 指令识别、操作数解码、符号解析
3. **文本生成**: 指令格式化、标签生成、注释添加
4. **输出生成**: 文件写入、格式美化、交叉引用

---

## 9. 扩展性规范

### 9.1 新指令添加流程

1. **定义操作码**: 在`RegisterBytecodeDefinition`中分配新操作码
2. **实现执行器**: 在相应的`*Executors`类中添加执行逻辑
3. **更新汇编器**: 在`RegisterByteCodeAssembler`中添加汇编语法支持
4. **添加测试**: 为新指令编写单元测试和集成测试
5. **更新文档**: 更新本规范的指令集规范部分

### 9.2 新优化Pass添加流程

1. **定义Pass接口**: 实现统一的`OptimizationPass`接口
2. **实现优化逻辑**: 编写优化算法实现
3. **注册Pass**: 在`Optimizer`中注册新Pass
4. **添加测试**: 编写优化效果验证测试
5. **更新文档**: 更新优化策略文档

### 9.3 扩展点清单

- **指令执行器**: `InstructionExecutor`接口
- **优化Pass**: `OptimizationPass`接口
- **垃圾回收器**: `GarbageCollector`接口
- **调试器**: `Debugger`接口
- **代码生成器**: `ICodeGenerator`接口

---

## 10. 符合性要求

### 10.1 架构符合性

| 要求 | 规范 | 验证方法 |
|------|------|----------|
| 分层架构 | 所有层必须通过明确定义的接口通信 | 架构审查 |
| 数据流契约 | 层间转换必须是纯函数 | 单元测试 |
| 接口一致性 | 所有接口使用强类型 | 类型检查 |
| 错误传播 | 使用统一的错误类型 | 集成测试 |

### 10.2 代码质量符合性

| 要求 | 规范 | 验证方法 |
|------|------|----------|
| 编码规范 | 遵循Google Java Style | CheckStyle检查 |
| 测试覆盖率 | 整体≥85%，核心≥90% | JaCoCo报告 |
| 静态分析 | 无严重SpotBugs问题 | SpotBugs检查 |
| 文档覆盖 | 所有公共API有Javadoc | Javadoc检查 |

### 10.3 性能符合性

| 要求 | 规范 | 验证方法 |
|------|------|----------|
| 执行速度 | 优于栈式虚拟机≥10% | 性能基准测试 |
| 内存使用 | 峰值内存≤2*EP18 | 内存分析工具 |
| 指令吞吐量 | ≥100万指令/秒 | 吞吐量测试 |
| JIT兼容性 | 支持未来JIT集成 | 代码审查 |

---

## 附录A：快速参考表

### 寄存器使用快速参考
```
参数寄存器: a0-a5 (r2-r7)     调用者保存
保存寄存器: s0-s4 (r8-r12)    被调用者保存
特殊寄存器: sp (r13), fp (r14), lr (r15)
零寄存器: zero (r0)           只读，始终为0
```

### 栈帧偏移快速参考
```
fp+16+4n:       第(7+n)个参数（n≥0）
fp+12:          返回地址（调用栈中）
fp+8:           旧fp保存位置
fp+0:           s2保存位置
fp-4:           s2保存位置
fp-8:           s1保存位置
fp-12:          s0保存位置
fp-16:          局部变量0
fp-20:          局部变量1
...
```

### 常用指令序列
```assembly
# 函数序言模板
addi sp, sp, -framesize
sw fp, 8(sp)
addi fp, sp, framesize-4
# 保存使用的s0-s4寄存器

# 函数尾声模板
# 恢复使用的s0-s4寄存器
lw fp, 8(sp)
addi sp, sp, framesize
ret

# 调用函数
# 准备参数到a0-a5（和栈）
call function

# 返回函数
# 返回值在a0中
ret
```

---

## 附录B：相关文档

1. **EP18R ABI设计文档**: EP18R_ABI_设计文档.md
2. **EP18R TDD执行计划**: TDD执行计划_精简版.md
3. **EP18R 改进计划**: EP18R_改进计划.md
4. **RegisterBytecodeDefinition.java**: 指令集定义源文件
5. **RegisterVMInterpreter.java**: 虚拟机解释器源文件
6. **CallingConventionUtils.java**: 调用约定工具源文件

---

**文档版本**: 1.0.0
**最后更新**: 2026-01-08
**维护者**: Claude Code
**状态**: 正式发布（规范）
