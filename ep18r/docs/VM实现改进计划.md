
# ep18r 寄存器虚拟机实现计划

### 项目概述
ep18r 是基于寄存器架构的独立虚拟机，采用寄存器指令集和优化的执行模型，专注于寄存器架构的性能优势。本计划描述ep18r的实现步骤和时间安排。

### 当前状态（2025年12月15日更新）
- ✅ 模块创建和基础结构完成
- ✅ 寄存器指令集设计完成（RegisterBytecodeDefinition）
- ✅ 寄存器虚拟机核心实现完成（RegisterVMInterpreter指令集完整实现）
- ✅ 汇编器和反汇编器完成（RegisterByteCodeAssembler、RegisterDisAssembler）
- ⬜ 寄存器优化未开始
- ⬜ 优化和性能对比未开始

### 渐进式实现计划

#### 阶段 1：模块创建和基础结构（已完成）
1. 创建 ep18r 目录和 pom.xml（基于 ep18 的 pom.xml）
2. 复制 ep18 的代码结构作为起点
3. 修改模块配置：artifactId 为 ep18r，包路径为 org.teachfx.antlr4.ep18r
4. 更新根 pom.xml 的 modules 列表，在 ep18 后添加 ep18r
5. 构建验证：确保 mvn compile 通过

#### 阶段 2：寄存器指令集设计（已完成）
1. 分析现有 42 条栈指令，设计对应的寄存器版本
2. 定义寄存器指令编码格式（32 位指令，包含操作码和寄存器字段）
3. 创建 RegisterBytecodeDefinition.java
4. 设计寄存器文件（16 个通用寄存器）

#### 阶段 3：寄存器虚拟机核心实现（已完成）
1. 创建 CymbolRegisterVM 类，基于 CymbolStackVM 但改用寄存器架构（注：实际实现为RegisterVMInterpreter类，提供完整的寄存器指令集支持）
2. 实现寄存器文件（register file）和寄存器分配策略
3. 实现指令解码和执行循环，支持新的寄存器指令
4. 保持相同的堆内存管理、结构体支持和垃圾回收
5. 实现栈帧管理，但局部变量存储在寄存器中（可能需要寄存器溢出处理）

#### 阶段 4：汇编器和反汇编器（已完成）
1. 扩展 VMAssembler.g4 语法，支持寄存器指令格式（注：现有VMAssembler.g4语法已支持寄存器指令格式）
2. 创建 RegisterByteCodeAssembler.java
3. 创建 RegisterDisAssembler.java
4. 确保向后兼容：仍能解析现有的栈式汇编代码（可选，或提供转换工具）

#### 阶段 5：寄存器优化和性能测试（未开始）
1. 实现寄存器分配优化算法
2. 添加性能统计和基准测试框架
3. 对比寄存器架构与栈式架构的性能差异
4. 优化热点指令和内存访问模式

#### 阶段 6：优化和性能对比（未开始）
1. 实现寄存器分配优化（如线性扫描）
2. 添加性能统计和对比
3. 文档记录设计决策和性能特征

#### 阶段 7：集成和文档（未开始）
1. 更新项目文档，说明 ep18r 的存在和用途
2. 确保构建脚本支持 ep18r
3. 编写使用示例和教程

### 关键设计决策
1. **寄存器数量**：16 个通用寄存器（r0-r15），采用简单固定分配策略
2. **指令格式**：32位指令，R/I/J三种类型
3. **兼容性策略**：采用新的寄存器汇编格式，提供栈式字节码到寄存器字节码的转换工具

### 时间安排
- **第1-2周**：完成阶段3（寄存器虚拟机核心实现）
- **第3周**：完成阶段4（汇编器和反汇编器）
- **第4周**：完成阶段5（寄存器优化和性能测试）
- **第5-6周**：完成阶段6-7（优化和文档）

### 成功标准
1. 所有现有测试通过（或适配后通过）
2. 寄存器优化效果达到预期
3. 模块可独立构建和运行
4. 文档完整

### 风险评估
1. **复杂性**：寄存器分配和优化复杂 → 分阶段实现，先实现简单固定分配
2. **性能**：需要验证寄存器架构的性能优势 → 专注于寄存器优化，性能为主要目标
3. **测试**：确保寄存器架构正确性困难 → 实现详细的测试框架

---

*本计划制定时间：2025年12月7日*
*预计完成时间：2026年6月*
*负责人：Claude Code*