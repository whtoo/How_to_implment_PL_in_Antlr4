# EP21 编译器架构设计规范

**版本**: 1.0.0
**发布日期**: 2025-12-21
**目标读者**: 编译器学习者、开发者、教育工作者
**规范状态**: 草案 (Draft)

## 📋 规范概览

### 1.1 规范目的

本规范旨在为EP21编译器项目提供清晰、现代化、教育导向的架构设计指南。规范优先级高于具体设计和实现，所有开发活动必须遵循本规范。

### 1.2 核心原则

1. **教育优先原则**: 架构设计优先考虑教学价值和可理解性
2. **现代性原则**: 采用现代编译器设计模式和最佳实践
3. **分层清晰原则**: 明确分层架构，职责边界清晰
4. **扩展性原则**: 提供清晰的扩展点和插件机制
5. **一致性原则**: 保持接口和行为的一致性

### 1.3 规范结构

- **第2章**: 整体架构概述
- **第3章**: 前端层规范
- **第4章**: 中间表示层规范
- **第5章**: 优化层规范
- **第6章**: 后端层规范
- **第7章**: 工具链规范
- **第8章**: 扩展性规范
- **第9章**: 教育应用规范

---

## 2. 整体架构规范

### 2.1 架构分层模型

EP21编译器采用**四层架构模型**，每层有明确的输入输出和职责边界：

```
┌─────────────────────────────────────────────────────┐
│                   应用层 (Application)                │
│  • 命令行接口 (CLI)                                  │
│  • 集成开发环境插件                                 │
│  • 测试框架集成                                     │
└─────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────┐
│                   前端层 (Frontend)                   │
│  • 词法分析 (Lexical Analysis)                      │
│  • 语法分析 (Syntax Analysis)                       │
│  • 语义分析 (Semantic Analysis)                     │
│  • 抽象语法树 (AST) 构建                            │
└─────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────┐
│              中间表示与优化层 (Middle End)            │
│  • 中层IR生成 (MIR Generation)                      │
│  • 低层IR转换 (LIR Conversion)                      │
│  • 控制流分析 (Control Flow Analysis)               │
│  • 数据流分析 (Data Flow Analysis)                  │
│  • SSA形式转换 (SSA Form Conversion)                │
│  • 优化Pass应用 (Optimization Passes)               │
└─────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────┐
│                   后端层 (Backend)                    │
│  • 代码生成 (Code Generation)                       │
│  • 寄存器分配 (Register Allocation)                 │
│  • 指令选择 (Instruction Selection)                 │
│  • 目标代码输出 (Target Code Emission)              │
└─────────────────────────────────────────────────────┘
```

### 2.2 数据流契约

每层之间通过明确定义的**数据契约**进行通信：

| 转换阶段 | 输入格式 | 输出格式 | 转换责任 |
|----------|----------|----------|----------|
| 词法分析 | 源代码字符串 | Token流 | 识别词汇单元 |
| 语法分析 | Token流 | 解析树 (Parse Tree) | 验证语法结构 |
| AST构建 | 解析树 | 抽象语法树 (AST) | 构建语义结构 |
| 语义分析 | AST + 符号表 | 类型化AST | 类型检查和语义验证 |
| MIR生成 | 类型化AST | 中层IR (MIR) | 保留控制流结构 |
| LIR转换 | MIR | 低层IR (LIR) | 三地址码转换 |
| CFG构建 | LIR | 控制流图 (CFG) | 基本块划分 |
| 优化Pass | CFG | 优化后CFG | 应用优化算法 |
| 代码生成 | 优化后CFG | 目标代码 | 生成可执行代码 |

### 2.3 接口规范

所有层间接口必须遵循以下规范：

1. **不可变数据**: 跨层传递的数据结构必须是不可变的
2. **纯函数转换**: 层间转换函数应该是纯函数，无副作用
3. **错误传播**: 使用统一的错误类型和传播机制
4. **位置信息**: 所有节点必须携带源代码位置信息
5. **可序列化**: 所有中间表示必须支持序列化和反序列化

---

## 3. 前端层规范

### 3.1 词法分析规范

#### 3.1.1 词法单元定义
```antlr4
// 必须支持的词法单元类型
TOKEN_TYPES {
  // 标识符和字面量
  IDENTIFIER:      [a-zA-Z_][a-zA-Z0-9_]*
  INTEGER:         [0-9]+
  FLOAT:           [0-9]+\.[0-9]+
  STRING:          \"([^\"\\]|\\.)*\"
  CHARACTER:       \'([^\'\\]|\\.)\'
  BOOLEAN:         true|false

  // 关键字 (必须完整列表)
  TYPE_KEYWORDS:   int|float|bool|string|void|object
  CONTROL_FLOW:    if|else|while|for|return|break|continue
  DECLARATION:     var|let|const|function

  // 操作符和分隔符
  OPERATORS:       +|-|*|/|%|==|!=|<|>|<=|>=|&&|\|\||!|=|+=|-=|*=|/=
  SEPARATORS:      ;|,|:|.|(|)|{|}|[|]

  // 空白和注释
  WHITESPACE:      [ \t\r\n]+ -> skip
  LINE_COMMENT:    //.* -> skip
  BLOCK_COMMENT:   /\*.*?\*/ -> skip
}
```

#### 3.1.2 词法分析器要求
1. **无状态性**: 词法分析器必须是纯函数，无内部状态
2. **错误恢复**: 必须实现错误恢复机制，继续扫描后续内容
3. **位置跟踪**: 必须准确记录每个Token的行列位置
4. **性能要求**: 必须支持流式处理大文件

### 3.2 语法分析规范

#### 3.2.1 语法定义原则
1. **LL(k)友好**: 语法必须适合LL(k)分析，k≤2
2. **无歧义**: 语法必须明确无歧义
3. **左递归消除**: 必须消除所有直接和间接左递归
4. **优先级明确**: 操作符优先级必须在语法中明确体现

#### 3.2.2 语法结构要求
```antlr4
// 必须包含的核心语法规则
GRAMMAR_RULES {
  // 程序结构
  compilationUnit: (functionDecl | variableDecl)* EOF

  // 函数声明
  functionDecl: returnType identifier '(' parameterList? ')' blockStatement

  // 变量声明
  variableDecl: type identifier ('=' expression)? ';'

  // 语句
  statement: blockStatement
           | ifStatement
           | whileStatement
           | forStatement
           | returnStatement
           | expressionStatement
           | variableDecl

  // 表达式 (按优先级从低到高)
  expression: assignmentExpression
  assignmentExpression: logicalOrExpression ('=' assignmentExpression)?
  logicalOrExpression: logicalAndExpression ('||' logicalAndExpression)*
  logicalAndExpression: equalityExpression ('&&' equalityExpression)*
  equalityExpression: relationalExpression (('=='|'!=') relationalExpression)*
  relationalExpression: additiveExpression (('<'|'>'|'<='|'>=') additiveExpression)*
  additiveExpression: multiplicativeExpression (('+'|'-') multiplicativeExpression)*
  multiplicativeExpression: unaryExpression (('*'|'/'|'%') unaryExpression)*
  unaryExpression: ('-'|'!'|'++'|'--')? primaryExpression
  primaryExpression: literal
                   | identifier
                   | '(' expression ')'
                   | functionCall
}
```

### 3.3 抽象语法树规范

#### 3.3.1 AST节点设计原则
1. **单一职责**: 每个AST节点类型对应一种语言结构
2. **不可变性**: 所有AST节点创建后不可修改
3. **访问者模式**: 必须实现访问者模式用于遍历
4. **位置信息**: 每个节点必须包含源代码位置
5. **类型信息**: 语义分析后每个表达式节点必须有类型

#### 3.3.2 核心AST节点类型
```java
// 必须实现的基础接口
interface ASTNode {
  Location getLocation();
  <T> T accept(ASTVisitor<T> visitor);
  String toString();  // 用于调试
}

// 必须实现的节点分类
NODE_CATEGORIES {
  // 声明节点
  CompilationUnitNode
  FunctionDeclarationNode
  VariableDeclarationNode
  ParameterDeclarationNode

  // 语句节点
  BlockStatementNode
  IfStatementNode
  WhileStatementNode
  ForStatementNode
  ReturnStatementNode
  ExpressionStatementNode
  BreakStatementNode
  ContinueStatementNode

  // 表达式节点
  IdentifierExpressionNode
  LiteralExpressionNode (IntLiteral, FloatLiteral, StringLiteral, BooleanLiteral)
  BinaryExpressionNode
  UnaryExpressionNode
  FunctionCallExpressionNode
  AssignmentExpressionNode
}
```

### 3.4 语义分析规范

#### 3.4.1 符号表设计
```java
// 必须实现的符号表接口
interface SymbolTable {
  // 作用域管理
  Scope enterScope(ScopeType type);
  void exitScope();
  Scope getCurrentScope();

  // 符号管理
  void defineSymbol(Symbol symbol);
  Symbol resolveSymbol(String name);
  List<Symbol> getAllSymbols();

  // 类型管理
  void defineType(Type type);
  Type resolveType(String name);
}

// 必须实现的符号类型
SYMBOL_TYPES {
  VariableSymbol: { name: string, type: Type, isConstant: boolean }
  FunctionSymbol: { name: string, returnType: Type, parameters: ParameterSymbol[] }
  TypeSymbol: { name: string, size: number, alignment: number }
}
```

#### 3.4.2 类型系统要求
1. **类型安全性**: 必须实现静态类型检查
2. **类型推断**: 支持局部变量类型推断 (var x = 10)
3. **类型转换**: 明确定义隐式和显式类型转换规则
4. **类型兼容性**: 定义类型兼容性矩阵

---

## 4. 中间表示层规范

### 4.1 分层IR设计原则

EP21采用**两层中间表示**设计，兼顾优化能力和简化程度：

#### 4.1.1 中层IR (MIR) - 用于高层优化
- **保留控制流结构**: if/while/for等高级控制流
- **支持复杂表达式**: 嵌套表达式，多操作数运算
- **类型信息完整**: 保留完整的类型信息
- **便于数据流分析**: 结构适合数据流分析框架

#### 4.1.2 低层IR (LIR) - 用于低层优化和代码生成
- **三地址码形式**: 每条指令最多三个操作数
- **简化控制流**: 只有跳转和标签
- **接近目标代码**: 便于寄存器分配和指令选择
- **SSA形式支持**: 支持静态单赋值形式

### 4.2 MIR规范

#### 4.2.1 MIR节点体系
```java
// MIR必须实现的基础接口
interface MIRNode {
  Location getLocation();
  <T> T accept(MIRVisitor<T> visitor);
  Type getType();  // 节点类型
}

// 必须支持的MIR节点类型
MIR_NODE_TYPES {
  // 程序结构
  MIRFunction: { name: string, parameters: MIRVariable[], body: MIRBlock }
  MIRBlock: { statements: MIRStatement[] }

  // 语句
  MIRIfStatement: { condition: MIRExpression, thenBlock: MIRBlock, elseBlock: MIRBlock? }
  MIRWhileStatement: { condition: MIRExpression, body: MIRBlock }
  MIRReturnStatement: { value: MIRExpression? }
  MIRAssignment: { target: MIRVariable, value: MIRExpression }

  // 表达式
  MIRBinaryExpression: { operator: BinaryOperator, left: MIRExpression, right: MIRExpression }
  MIRUnaryExpression: { operator: UnaryOperator, operand: MIRExpression }
  MIRCallExpression: { function: string, arguments: MIRExpression[] }
  MIRVariableExpression: { variable: MIRVariable }
  MIRLiteralExpression: { value: any, type: Type }
}
```

### 4.3 LIR规范

#### 4.3.1 LIR指令集
```java
// LIR必须支持的指令类型
LIR_INSTRUCTION_TYPES {
  // 算术和逻辑运算
  ADD, SUB, MUL, DIV, MOD
  AND, OR, XOR, NOT
  SHL, SHR  // 移位

  // 比较和跳转
  CMP: { left: Operand, right: Operand, condition: Condition }
  JMP: { target: Label }
  CJMP: { condition: Condition, thenTarget: Label, elseTarget: Label }

  // 内存操作
  LOAD: { dest: Register, address: Operand }
  STORE: { address: Operand, value: Operand }

  // 函数调用
  CALL: { function: string, arguments: Operand[], dest: Register? }
  RET: { value: Operand? }

  // 数据移动
  MOV: { dest: Operand, src: Operand }

  // 特殊指令
  PHI: { dest: Register, operands: Map<Label, Operand> }  // SSA φ函数
}
```

#### 4.3.2 操作数类型
```java
// 必须支持的操作数类型
OPERAND_TYPES {
  Register: { id: number, type: Type }
  Immediate: { value: any, type: Type }      // 立即数
  Memory: { base: Register, offset: number } // 内存地址
  Label: { name: string }                    // 代码标签
}
```

### 4.4 控制流图规范

#### 4.4.1 基本块定义
```java
// 基本块必须满足的条件
BASIC_BLOCK_REQUIREMENTS {
  1. 单一入口点: 只能在块开始处进入
  2. 单一出口点: 只能在块结束处离开
  3. 连续指令: 块内指令顺序执行
  4. 最大长度限制: 避免过长的基本块
}

// 基本块接口
interface BasicBlock {
  String getId();
  List<Instruction> getInstructions();
  List<BasicBlock> getPredecessors();
  List<BasicBlock> getSuccessors();
  void addInstruction(Instruction instr);
  void addPredecessor(BasicBlock pred);
  void addSuccessor(BasicBlock succ);
}
```

#### 4.4.2 CFG构建规则
1. **块划分规则**:
   - 标签指令开始新块
   - 跳转指令结束当前块
   - 跳转目标开始新块

2. **边建立规则**:
   - 顺序执行: 块A末尾无跳转 → 连接块A和块B
   - 无条件跳转: JMP指令 → 连接块A和跳转目标块
   - 条件跳转: CJMP指令 → 连接块A到then块和else块

---

## 5. 优化层规范

### 5.1 优化Pass架构

#### 5.1.1 优化Pass接口
```java
// 所有优化Pass必须实现的接口
interface OptimizationPass {
  String getName();
  String getDescription();

  // 优化执行
  OptimizationResult optimize(IRModule module);

  // 配置选项
  void configure(OptimizationConfig config);
  boolean isEnabled();
  void setEnabled(boolean enabled);
}

// 优化结果
interface OptimizationResult {
  boolean changed();              // 是否修改了IR
  List<OptimizationMetric> getMetrics();  // 优化指标
  List<OptimizationWarning> getWarnings(); // 警告信息
}
```

#### 5.1.2 优化Pass分类
```java
// 必须实现的优化Pass类型
OPTIMIZATION_CATEGORIES {
  // 局部优化 (基本块内)
  ConstantFoldingPass:       常量折叠
  CommonSubexpressionEliminationPass: 公共子表达式消除
  DeadCodeEliminationPass:   死代码删除

  // 全局优化 (函数内)
  ConstantPropagationPass:   常量传播
  CopyPropagationPass:       复制传播
  DeadStoreEliminationPass:  死存储消除

  // 循环优化
  LoopInvariantCodeMotionPass: 循环不变量外提
  LoopUnrollingPass:         循环展开

  // 控制流优化
  UnreachableCodeEliminationPass: 不可达代码删除
  BranchOptimizationPass:    分支优化
}
```

### 5.2 数据流分析框架

#### 5.2.1 数据流分析接口
```java
// 统一的数据流分析接口
interface DataFlowAnalysis<T> {
  enum Direction { FORWARD, BACKWARD }

  Direction getDirection();

  // 数据流方程
  T transfer(BasicBlock block, T input);
  T meet(T value1, T value2);      // 交汇操作
  T getInitialValue();
  boolean lessEqual(T value1, T value2);  // 偏序关系

  // 迭代求解
  Map<BasicBlock, T> analyze(CFG cfg);
}

// 必须实现的数据流分析
REQUIRED_ANALYSES {
  LiveVariableAnalysis:       活跃变量分析
  ReachingDefinitionsAnalysis: 到达定义分析
  AvailableExpressionsAnalysis: 可用表达式分析
}
```

#### 5.2.2 SSA形式转换

##### 5.2.2.1 SSA构建步骤
1. **支配树计算**: 构建支配关系树
2. **支配边界计算**: 确定φ函数插入位置
3. **φ函数插入**: 在支配边界插入φ函数
4. **变量重命名**: 将变量转换为SSA形式

##### 5.2.2.2 SSA破坏步骤
1. **φ函数消除**: 将φ函数转换为复制操作
2. **复制传播**: 传播复制操作
3. **寄存器分配**: 分配物理寄存器

---

## 6. 后端层规范

### 6.1 代码生成规范

#### 6.1.1 目标代码生成接口
```java
// 代码生成器接口
interface CodeGenerator {
  // 代码生成
  TargetCode generate(IRModule module);

  // 目标架构配置
  void setTargetArchitecture(TargetArchitecture arch);
  TargetArchitecture getTargetArchitecture();

  // 优化选项
  void setOptimizationLevel(OptimizationLevel level);
  OptimizationLevel getOptimizationLevel();
}

// 必须支持的目标架构
SUPPORTED_TARGETS {
  EP18_VIRTUAL_MACHINE:  EP18虚拟机字节码
  X86_64_ASSEMBLY:      x86-64汇编
  LLVM_IR:              LLVM中间表示
}
```

#### 6.1.2 寄存器分配规范

##### 6.1.2.1 寄存器分配算法要求
1. **图着色算法**: 必须实现图着色寄存器分配
2. **溢出处理**: 支持寄存器溢出到内存
3. **调用约定**: 遵循标准的函数调用约定
4. **寄存器类别**: 区分通用寄存器、浮点寄存器等

##### 6.1.2.2 寄存器分配接口
```java
interface RegisterAllocator {
  // 分配接口
  AllocationResult allocate(Function function, RegisterSet registerSet);

  // 统计信息
  AllocationStatistics getStatistics();
  List<SpillInstruction> getSpillInstructions();
}

// 分配结果
interface AllocationResult {
  Map<VirtualRegister, PhysicalRegister> getMapping();
  List<MoveInstruction> getMoveInstructions();
  boolean hasSpills();
}
```

### 6.2 指令选择规范

#### 6.2.1 指令选择器接口
```java
interface InstructionSelector {
  // 指令选择
  List<MachineInstruction> select(List<IRInstruction> irInstructions);

  // 模式匹配
  void addPattern(InstructionPattern pattern);
  List<InstructionPattern> getPatterns();

  // 代价模型
  CostModel getCostModel();
  void setCostModel(CostModel model);
}
```

#### 6.2.2 指令调度规范
1. **列表调度算法**: 必须实现列表调度算法
2. **依赖分析**: 准确分析指令间依赖关系
3. **资源冲突**: 处理功能单元冲突
4. **延迟隐藏**: 利用指令级并行

---

## 7. 工具链规范

### 7.1 编译器驱动规范

#### 7.1.1 命令行接口
```bash
# 必须支持的命令行选项
USAGE: ep21c [options] <input-file>

OPTIONS {
  # 输入输出控制
  -o, --output <file>        指定输出文件
  -S, --assembly             输出汇编代码
  -c, --compile-only         只编译不链接

  # 优化控制
  -O0, -O1, -O2, -O3        优化级别
  --opt <pass>              启用特定优化Pass
  --no-opt <pass>           禁用特定优化Pass

  # 调试信息
  -g, --debug               生成调试信息
  --dump-ast                输出AST
  --dump-ir                 输出IR
  --dump-cfg                输出控制流图

  # 语言特性
  --std <version>           语言标准版本
  --feature <feature>       启用语言特性

  # 其他
  -v, --verbose             详细输出
  --version                 显示版本信息
  -h, --help                显示帮助信息
}
```

### 7.2 调试信息规范

#### 7.2.1 调试信息格式
```java
// 必须生成的调试信息
DEBUG_INFO_TYPES {
  // 位置信息
  SourceLocation: { file: string, line: number, column: number }

  // 变量信息
  VariableInfo: { name: string, type: string, location: StorageLocation }

  // 函数信息
  FunctionInfo: { name: string, returnType: string, parameters: VariableInfo[] }

  // 类型信息
  TypeInfo: { name: string, size: number, alignment: number, members: MemberInfo[] }
}
```

---

## 8. 扩展性规范

### 8.1 插件系统规范

#### 8.1.1 插件接口
```java
// 插件基础接口
interface CompilerPlugin {
  String getName();
  String getVersion();
  String getDescription();

  // 生命周期
  void initialize(CompilerContext context);
  void shutdown();

  // 扩展点
  List<ExtensionPoint> getExtensionPoints();
}

// 支持的扩展点类型
EXTENSION_POINTS {
  AST_TRANSFORM:     AST转换插件
  IR_OPTIMIZATION:   IR优化插件
  CODE_GENERATOR:    代码生成插件
  TARGET_BACKEND:    目标后端插件
  ANALYSIS_PASS:     分析Pass插件
}
```

### 8.2 语言扩展规范

#### 8.2.1 新语言特性集成流程
1. **语法扩展**: 在Cymbol.g4中添加新语法规则
2. **AST扩展**: 添加新的AST节点类型
3. **语义分析**: 实现类型检查和语义规则
4. **IR生成**: 支持新特性的IR转换
5. **代码生成**: 生成目标代码
6. **测试覆盖**: 添加完整的测试用例

---

## 9. 教育应用规范

### 9.1 教学用例设计原则

#### 9.1.1 渐进式复杂度
```markdown
# 教学用例复杂度分级

## Level 1: 基础语法 (第1-2周)
- 变量声明和赋值
- 基本算术运算
- 简单函数定义
- 条件语句 (if-else)

## Level 2: 控制流 (第3-4周)
- 循环结构 (while, for)
- 嵌套控制流
- 函数调用和返回
- 递归函数

## Level 3: 数据结构 (第5-6周)
- 数组操作
- 结构体定义
- 指针和引用
- 动态内存

## Level 4: 高级特性 (第7-8周)
- 模块化编程
- 错误处理
- 并发编程
- 元编程特性
```

#### 9.1.2 可视化教学支持
1. **AST可视化**: 图形化显示抽象语法树
2. **CFG可视化**: 显示控制流图结构
3. **数据流可视化**: 展示数据流分析结果
4. **优化效果可视化**: 对比优化前后代码

### 9.2 实验设计规范

#### 9.2.1 实验任务类型
```java
// 必须支持的实验类型
EXPERIMENT_TYPES {
  // 理解性实验
  CODE_ANALYSIS:    代码分析实验
  VISUALIZATION:    可视化实验
  TRACING:          执行跟踪实验

  // 实现性实验
  GRAMMAR_EXTENSION: 语法扩展实验
  OPTIMIZATION_IMPLEMENTATION: 优化实现实验
  BACKEND_EXTENSION: 后端扩展实验

  // 研究性实验
  PERFORMANCE_ANALYSIS: 性能分析实验
  ALGORITHM_COMPARISON: 算法对比实验
  NEW_FEATURE_DESIGN:   新特性设计实验
}
```

#### 9.2.2 实验报告要求
1. **问题描述**: 清晰描述实验目标
2. **实现方案**: 详细说明实现方法
3. **结果分析**: 定量和定性分析结果
4. **问题讨论**: 讨论遇到的问题和解决方案
5. **扩展思考**: 提出进一步改进方向

---

## 10. 符合性要求

### 10.1 规范符合性级别

#### 10.1.1 必须实现 (MUST)
- 所有标记为"MUST"的规范条款必须完全实现
- 这是编译器正常工作的基本要求
- 测试覆盖率必须达到100%

#### 10.1.2 应该实现 (SHOULD)
- 标记为"SHOULD"的条款建议实现
- 未实现需要提供合理说明
- 影响编译器完整性和质量

#### 10.1.3 可以实现 (MAY)
- 标记为"MAY"的条款是可选的
- 实现可以提供额外价值
- 不影响核心功能

### 10.2 测试要求

#### 10.2.1 测试覆盖率
```yaml
测试覆盖率要求:
  整体覆盖率: ≥85%
  核心模块: ≥90% (前端、优化、后端)
  新功能: 100%
  错误处理: 100%
```

#### 10.2.2 测试类型要求
1. **单元测试**: 每个公开方法必须有单元测试
2. **集成测试**: 模块间接口必须有集成测试
3. **端到端测试**: 完整编译流程必须有端到端测试
4. **性能测试**: 关键算法必须有性能测试
5. **回归测试**: 所有修复的bug必须有回归测试

---

## 附录A: 术语表

| 术语 | 定义 | 参考 |
|------|------|------|
| AST | 抽象语法树，源代码的树状表示 | 第3.3节 |
| CFG | 控制流图，程序执行流程的图形表示 | 第4.4节 |
| IR | 中间表示，介于源代码和目标代码之间的表示形式 | 第4章 |
| MIR | 中层中间表示，保留高级控制流结构 | 第4.2节 |
| LIR | 低层中间表示，接近三地址码形式 | 第4.3节 |
| SSA | 静态单赋值形式，每个变量只赋值一次 | 第5.2.2节 |
| φ函数 | SSA中的特殊函数，根据控制流选择值 | 第5.2.2节 |

## 附录B: 变更记录

| 版本 | 日期 | 变更描述 | 负责人 |
|------|------|----------|--------|
| 1.0.0 | 2025-12-21 | 初始版本发布 | 编译器团队 |

---

**规范状态**: 批准 (Approved)
**生效日期**: 2025-12-21
**下次评审日期**: 2026-06-21

---

*本规范是EP21编译器项目的权威参考文档，所有设计和实现必须遵循本规范。如有冲突，以本规范为准。*