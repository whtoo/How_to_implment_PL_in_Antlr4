# 《编译原理》（龙书第二版）章节索引 - 理论实践对照学习指南

**教材**: Compilers: Principles, Techniques, and Tools (2nd Edition)
**作者**: Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman
**俗称**: 龙书（Dragon Book）

---

## 📚 理论实践对照总览

```
┌─────────────────────────────────────────────────────────────────┐
│                    龙书章节 ↔ 项目EP对照表                        │
├─────────────────────────────────────────────────────────────────┤
│  龙书章节              │  理论主题          │  实践EP            │
├─────────────────────────────────────────────────────────────────┤
│  第1章                  │  编译器结构        │  项目概览          │
│  第2章                  │  语法制导翻译      │  EP3              │
│  第3章                  │  词法分析          │  EP1              │
│  第4章                  │  语法分析          │  EP2              │
│  第5章                  │  语法制导翻译      │  EP3, EP11        │
│  第6章                  │  中间代码生成      │  EP11, EP16       │
│  第7章                  │  运行时环境        │  EP18, EP18R      │
│  第8章                  │  代码生成          │  EP16, EP19, EP20 │
│  第9章                  │  机器无关优化      │  EP21            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 📖 详细章节对照

### 第1章：编译器结构 (Chapter 1: Introduction)

**📍 理论要点**:
- 编译器的各个阶段（词法分析、语法分析、语义分析、中间代码生成、优化、代码生成）
- 编译器的结构：前端、中端、后端
- 解释器 vs 编译器
- 编译器的设计原则

**🔗 实践对应**:
- **项目概览**: [README.md](../../README.md) - 项目整体架构说明
- **学习路径**: [COURSE_编译器构造完全指南.md](./COURSE_编译器构造完全指南.md) - 三阶段学习路径
- **EP依赖关系**: 理解21个EP的依赖关系和渐进式设计

**💡 学习建议**:
```
理论学习（第1章）→ 理解编译器的整体架构
                  ↓
实践学习（README）→ 查看21个EP的依赖关系图
                  ↓
对比学习          → 识别：前端(EP1-10)、中端(EP11-15)、后端(EP16-21)
```

**⏱️ 建议学时**: 2小时理论学习 + 1小时项目概览

---

### 第2章：一个简单的语法制导翻译器 (Chapter 2: A Simple Syntax-Directed Translator)

**📍 理论要点**:
- 语法制导定义（Syntax-Directed Definitions）
- 语法树（Syntax Trees）
- 抽象语法树 vs 具体语法树
- 属性文法（Attribute Grammars）
- 自顶向下翻译

**🔗 实践对应**:
- **EP3**: [AST构建](./EP3_教学文档.md) - 抽象语法树的构建
- **EP11**: [表达式AST](./EP11_教学文档.md) - 自定义AST节点体系
- **ANTLR4**: 使用Listener/Visitor模式实现语法制导翻译

**💡 学习建议**:
```
龙书第2.1节  →  理解语法制导定义
              ↓
EP3教学文档   →  实践：使用ANTLR4 Listener构建AST
              ↓
对比学习      →  理论：属性文法 vs 实践：Java Visitor模式
```

**🎯 关键概念映射**:
| 龙书概念 | 实践实现 | 位置 |
|---------|---------|------|
| 抽象语法树 | `ASTNode` 及其子类 | `ep3/src/main/java/.../ast/` |
| 语法规则 | ANTLR4 `.g4` 文件 | `ep3/src/main/antlr4/` |
| 访问者模式 | `ExprVisitor.java` | `ep3/src/main/java/.../visitor/` |
| 语法制导翻译 | Visitor的visit方法 | 各个Visitor类 |

**⏱️ 建议学时**: 4小时理论学习 + 4小时实践

---

### 第3章：词法分析 (Chapter 3: Lexical Analysis)

**📍 理论要点**:
- 词法单元（Tokens）：关键字、标识符、字面量、运算符
- 正则表达式（Regular Expressions）
- 有限自动机（Finite Automata）
  - DFA（确定性有限自动机）
  - NFA（非确定性有限自动机）
- NFA到DFA的转换
- 词法分析器生成工具（如Lex/Flex）

**🔗 实践对应**:
- **EP1**: 词法分析器实现
- **ANTLR4 Lexer**: 自动生成词法分析器
- **Token流处理**: 理解TokenStream的工作原理

**💡 学习建议**:
```
龙书第3.3节（正则表达式）  →  理解正则语言
                        ↓
EP1实现                  →  实践：定义词法规则
                        ↓
对比学习                →  理论：NFA/DFA vs 实践：ANTLR4自动生成
```

**🎯 关键概念映射**:
| 龙书概念 | 实践实现 | 位置 |
|---------|---------|------|
| Token定义 | `CymbolLexer` | `ep1/src/main/antlr4/CymbolLexer.g4` |
| 正则表达式 | ANTLR4词法规则 | `.g4` 文件的词法规则部分 |
| 有限自动机 | ANTLR4内部实现 | 自动生成，不可见 |
| 词法错误处理 | Lexer错误恢复 | ANTLR4默认机制 |

**🔍 深入学习**:
- 龙书3.5节：正则表达式的代数定律 → 对应：ANTLR4词法规则的组合
- 龙书3.6节：正则表达式的等价性 → 对应：词法规则的优化

**⏱️ 建议学时**: 6小时理论学习 + 3小时实践

---

### 第4章：语法分析 (Chapter 4: Syntax Analysis)

**📍 理论要点**:
- 上下文无关文法（Context-Free Grammars）
- 文法的推导与语法树
- 二义性（Ambiguity）
- 解析方法：
  - 自顶向下（Top-Down Parsing）：LL(k)文法
  - 自底向上（Bottom-Up Parsing）：LR(k)文法
- FIRST和FOLLOW集
- 预测分析（Predictive Parsing）
- 语法分析器生成工具（如Yacc/Bison）

**🔗 实践对应**:
- **EP2**: 语法分析器实现
- **ANTLR4 Parser**: ALL(*)预测分析算法
- **ParseTree vs AST**: 理解两者的区别

**💡 学习建议**:
```
龙书第4.2节（上下文无关文法）  →  理解文法形式化定义
                           ↓
龙书第4.4节（LL(1)文法）     →  理解预测分析
                           ↓
EP2实现                     →  实践：定义语法规则
                           ↓
对比学习                    →  理论：LL(1) vs 实践：ALL(*)
```

**🎯 关键概念映射**:
| 龙书概念 | 实践实现 | 位置 |
|---------|---------|------|
| 文法规则 | ANTLR4语法规则 | `ep2/src/main/antlr4/*.g4` |
| ParseTree | `ParseTree` 接口 | ANTLR4生成 |
| LL(k)分析 | ALL(*)算法 | ANTLR4内部实现 |
| 语法错误恢复 | Parser错误恢复 | ANTLR4默认机制 |
| 左递归处理 | ANTLR4直接左递归 | 语法规则定义 |

**🔍 深入学习**:
- 龙书4.3节：书写文法 → 对应：ANTLR4语法规则设计
- 龙书4.5节：简单LR分析 → 对应：理解为什么ANTLR4选择ALL(*)而非LR

**⚠️ 学习难点**:
- 理论：FIRST/FOLLOW集的手动计算
- 实践：ANTLR4通过自动分析避免手动计算
- **对比优势**: 理论理解"为什么"，实践学会"如何用"

**⏱️ 建议学时**: 8小时理论学习 + 4小时实践

---

### 第5章：语法制导翻译 (Chapter 5: Syntax-Directed Translation)

**📍 理论要点**:
- 语法制导定义（SDD）的设计
- 继承属性与综合属性
- 依赖图（Dependency Graph）
- 语法制导翻译方案（SDT）
- SDD的求值顺序
- 应用：抽象语法树的构造、类型的综合

**🔗 实践对应**:
- **EP3**: AST构建（使用Visitor模式）
- **EP11**: 表达式AST构建（类型检查、符号表）
- **EP4**: 类型检查实现
- **EP5-EP6**: 作用域和符号表

**💡 学习建议**:
```
龙书第5.1节（语法制导定义）  →  理解继承属性和综合属性
                          ↓
龙书第5.2节（SDD的求值）     →  理解依赖图和拓扑排序
                          ↓
EP3 + EP11                 →  实践：Visitor模式实现SDD
                          ↓
对比学习                   →  理论：属性文法 vs 实践：Visitor模式
```

**🎯 关键概念映射**:
| 龙书概念 | 实践实现 | 位置 |
|---------|---------|------|
| 综合属性 | Visitor的返回值 | 各Visitor类的visit方法 |
| 继承属性 | Visitor的上下文参数 | 通过构造函数传递的上下文 |
| 依赖图 | Visitor的调用顺序 | 由AST遍历顺序隐式决定 |
| 语义动作 | Visitor方法中的代码 | visit方法中的Java代码 |
| 类型检查 | TypeChecker Visitor | `ep4/src/main/java/.../TypeChecker.java` |

**🔍 深入学习**:
- 龙书5.3节：语法制导翻译方案的应用 → 对应：EP11的类型检查和符号表构建
- 龙书5.4节：抽象语法树的构造 → 对应：EP3的AST构建

**💡 实践洞察**:
```
理论SDD的优势：
├── 形式化定义，易于推理
├── 显式的依赖关系
└── 适用于编译器理论研究

实践Visitor模式的优势：
├── 面向对象，易于扩展
├── 自动管理求值顺序
└── 符合Java工程实践
```

**⏱️ 建议学时**: 6小时理论学习 + 6小时实践

---

### 第6章：中间代码生成 (Chapter 6: Intermediate-Code Generation)

**📍 理论要点**:
- 中间表示的类型：
  - 三地址码（Three-Address Code）
  - 图表示（DAG、SSA）
- 声明语句的翻译
- 赋值语句的翻译
- 布尔表达式的翻译
- 控制流语句的翻译（if、while）
- 回填技术（Backpatching）

**🔗 实践对应**:
- **EP11**: 表达式AST（自定义中间表示）
- **EP16**: 线性IR（三地址码实现）
- **EP12**: SSA形式构建
- **EP17**: CFG构建

**💡 学习建议**:
```
龙书第6.2节（三地址码）      →  理解中间表示的理论基础
                          ↓
龙书第6.3节（类型声明）      →  理解声明的翻译
                          ↓
EP16实现                   →  实践：设计线性IR指令集
                          ↓
龙书第6.6节（布尔表达式）    →  理解控制流的翻译
                          ↓
EP17实现                   →  实践：构建控制流图
```

**🎯 关键概念映射**:
| 龙书概念 | 实践实现 | 位置 |
|---------|---------|------|
| 三地址码 | `IRInstruction` | `ep16/src/main/java/.../ir/` |
| 中间表示 | `MIRNode`, `LIRNode` | EP16的IR类层次 |
| 静态单赋值(SSA) | `SSAGraph` | `ep12/src/main/java/.../ssa/` |
| 控制流图 | `ControlFlowGraph` | `ep17/src/main/java/.../cfg/` |
| 基本块 | `BasicBlock` | CFG的节点 |
| 支配边界 | `DominanceFrontier` | SSA构建的关键 |

**🔍 深入学习**:
- 龙书6.4节：表达式的翻译 → 对应：EP16的算术指令生成
- 龙书6.5节：数组元素的引用 → 对应：EP16的数组访问指令
- 龙书6.7节：控制流翻译 → 对应：EP17的CFG构建

**⚠️ 学习难点**:
- **SSA理论**（龙书未详细覆盖）：需要补充阅读Cytron et al. 1991论文
- **支配边界计算**：理论复杂，实践中通过EP12的代码学习
- **回填技术**：理论优雅，实践中通过两次遍历AST简化

**⏱️ 建议学时**: 10小时理论学习 + 12小时实践

---

### 第7章：运行时环境 (Chapter 7: Run-Time Environments)

**📍 理论要点**:
- 存储组织
- 栈式存储分配
- 栈帧（Stack Frames）的结构
- 参数传递机制
- 寄存器分配
- 垃圾回收（Garbage Collection）
  - 标记-清除（Mark-Sweep）
  - 引用计数（Reference Counting）
  - 复制收集（Copying Collection）

**🔗 实践对应**:
- **EP18**: 栈式虚拟机（栈帧管理、GC实现）
- **EP18R**: 寄存器虚拟机（寄存器分配）
- **GC实现**: `ReferenceCountingGC`

**💡 学习建议**:
```
龙书第7.1节（存储组织）       →  理解运行时内存布局
                             ↓
龙书第7.2节（栈式存储）       →  理解栈帧结构
                             ↓
龙书第7.3节（参数传递）       →  理解调用约定
                             ↓
EP18实现                    →  实践：设计栈式VM和栈帧
                             ↓
龙书第7.6节（垃圾回收）       →  理解GC算法
                             ↓
EP18的GC实现                →  实践：引用计数GC
```

**🎯 关键概念映射**:
| 龙书概念 | 实践实现 | 位置 |
|---------|---------|------|
| 栈帧 | `StackFrame` | `ep18/src/main/java/.../frame/` |
| 活动记录 | `StackFrame` | 同上 |
| 参数传递 | `CallInstruction` | 通过操作数栈传递 |
| 返回地址 | `returnAddress` | StackFrame的字段 |
| 局部变量 | `localVariables` | StackFrame的数组 |
| 调用约定 | `ABIConvention` | EP18的ABI规范 |
| 垃圾回收 | `ReferenceCountingGC` | `ep18/src/main/java/.../gc/` |
| 堆管理 | `MemorySpace` | VM的堆空间 |

**🔍 深入学习**:
- 龙书7.3节：运行时栈的完整实现 → 对应：EP18的完整栈帧管理
- 龙书7.4节：基于堆的运行时环境 → 对应：EP18的堆分配
- 龙书7.6节：垃圾回收算法 → 对应：EP18的GC实现

**💡 实践洞察**:
```
理论运行时环境（龙书）:
├── 专注于C/C++语言模型
├── 栈帧布局详细
└── GC算法理论分析

实践VM设计（EP18）:
├── 字节码解释执行
├── 简化的栈帧结构
└── 引用计数GC（简单但实用）

对比学习价值：
├── 理论理解"为什么"
└── 实践学会"如何实现"
```

**⏱️ 建议学时**: 8小时理论学习 + 12小时实践

---

### 第8章：代码生成 (Chapter 8: Code Generation)

**📍 理论要点**:
- 代码生成器的主要问题
- 目标语言
- 寄存器分配
- 基本块的指令调度
- 窥孔优化（Peephole Optimization）
- 指令选择
- 代码生成算法

**🔗 实践对应**:
- **EP16**: 线性IR设计（指令选择）
- **EP19**: 基础编译器（AST到字节码的完整转换）
- **EP20**: 进阶编译器（代码生成优化）
- **EP18/EP18R**: 虚拟机作为目标平台

**💡 学习建议**:
```
龙书第8.1节（代码生成器）     →  理解代码生成的总体架构
                           ↓
龙书第8.4节（寄存器分配）     →  理解寄存器分配算法
                           ↓
EP18R实现                  →  实践：寄存器VM的寄存器分配
                           ↓
龙书第8.5节（指令调度）      →  理解指令优化
                           ↓
EP20实现                   →  实践：代码生成优化
```

**🎯 关键概念映射**:
| 龙书概念 | 实践实现 | 位置 |
|---------|---------|------|
| 指令选择 | `IRBuilder` | EP16的IR生成 |
| 寄存器分配 | 寄存器分配算法 | EP18R的寄存器VM |
| 活跃变量分析 | `LivenessAnalysis` | EP14/EP21 |
| 基本块 | `BasicBlock` | EP17的CFG节点 |
| 窥孔优化 | `PeepholeOptimizer` | EP20的优化Pass |
| 代码生成器 | `CymbolAssembler` | EP19/EP20的代码生成 |

**🔍 深入学习**:
- 龙书8.2节：目标语言 → 对应：EP18的字节码指令集设计
- 龙书8.6节：指令选择 → 对应：EP16的IR设计
- 龙书8.7节：窥孔优化 → 对应：EP20的优化实现

**💡 实践洞察**:
```
理论代码生成（龙书）:
├── 目标：真实机器码（x86, ARM）
├── 复杂度：寄存器分配、指令调度复杂
└── 优化：多种优化算法

实践代码生成（本项目）:
├── 目标：字节码（.vm文件）
├── 复杂度：简化（虚拟机统一抽象）
└── 优化：窥孔优化、简单优化Pass

对比优势：
├── 避免硬件复杂性
├── 专注于编译原理本身
└── 可视化调试更容易
```

**⏱️ 建议学时**: 10小时理论学习 + 10小时实践

---

### 第9章：机器无关优化 (Chapter 9: Machine-Independent Optimizations)

**📍 理论要点**:
- 优化的主要来源
- 数据流分析简介
- 常量传播（Constant Propagation）
- 复写传播（Copy Propagation）
- 死代码消除（Dead Code Elimination）
- 循环优化（Loop Optimizations）
- 数据流分析框架
- 到达定义分析（Reaching Definitions）
- 可用表达式分析（Available Expressions）
- 活跃变量分析（Live-Variable Analysis）

**🔗 实践对应**:
- **EP13**: 数据流分析
- **EP14**: 活跃变量分析
- **EP15**: 常量传播
- **EP21**: 高级优化（完整优化框架）

**💡 学习建议**:
```
龙书第9.1节（优化概述）       →  理解优化的价值和挑战
                             ↓
龙书第9.2节（数据流分析）     →  理解数据流方程
                             ↓
EP13实现                    →  实践：数据流分析框架
                             ↓
龙书第9.3节（常量传播）       →  理解常量传播算法
                             ↓
EP15实现                    →  实践：常量传播优化
                             ↓
龙书第9.4节（死代码消除）     →  理解死代码消除
                             ↓
EP21实现                    →  实践：完整优化Pass实现
```

**🎯 关键概念映射**:
| 龙书概念 | 实践实现 | 位置 |
|---------|---------|------|
| 数据流方程 | `DataFlowAnalysis` | `ep13/src/main/java/.../dataflow/` |
| 到达定义 | `ReachingDefinitionAnalysis` | EP13 |
| 活跃变量 | `LiveVariableAnalysis` | EP14 |
| 常量传播 | `ConstantPropagation` | EP15 |
| 死代码消除 | `DeadCodeElimination` | EP21 |
| 支配分析 | `DominanceAnalysis` | EP12/EP17 |
| SSA形式 | `SSAGraph` | EP12 |
| 循环优化 | `LoopOptimizer` | EP21 |

**🔍 深入学习**:
- 龙书9.2节：数据流分析的基础 → 对应：EP13的数据流框架
- 龙书9.3节：数据流分析的基础架构 → 对应：EP21的优化Pass框架
- 龙书9.4节：活跃变量分析 → 对应：EP14的活跃分析实现

**💡 实践洞察**:
```
理论优化（龙书）:
├── 数学化的数据流方程
├── 形式化的证明
└── 通用的优化算法

实践优化（本项目）:
├── 可执行的优化Pass
├── 可视化的优化结果
└── 真实的性能提升

对比学习：
├── 理论保证正确性
└── 实践验证有效性
```

**⚠️ 学习难点**:
- **数据流方程的理论**：需要数学基础
- **SSA的构建算法**：需要深入理解支配树
- **优化的顺序**：不同优化Pass的相互影响

**⏱️ 建议学时**: 15小时理论学习 + 15小时实践

---

## 🎓 分阶段学习计划

### 阶段1：前端编译（第1-5章）

**目标**: 理解从源代码到AST的转换过程

```
周次 | 龙书章节 | 理论主题 | 实践EP | 学时
-----|---------|---------|--------|------
1   | Ch1-2   | 编译器结构、语法制导翻译 | EP3  | 3h理论 + 3h实践
2   | Ch3     | 词法分析 | EP1  | 6h理论 + 3h实践
3   | Ch4     | 语法分析 | EP2  | 8h理论 + 4h实践
4   | Ch5     | 语法制导翻译 | EP3, EP4 | 6h理论 + 6h实践
```

**阶段1成果**:
- 理解：编译器前端的工作原理
- 实践：能够构建简单的语言处理器

---

### 阶段2：中端编译（第6章）

**目标**: 理解中间表示和程序分析

```
周次 | 龙书章节 | 理论主题 | 实践EP | 学时
-----|---------|---------|--------|------
5-6 | Ch6     | 中间代码生成 | EP11, EP16 | 10h理论 + 10h实践
7   | 补充    | SSA形式      | EP12    | 4h理论 + 8h实践
```

**阶段2成果**:
- 理解：中间表示的设计和作用
- 实践：能够生成三地址码和SSA形式

---

### 阶段3：后端编译（第7-8章）

**目标**: 理解代码生成和运行时环境

```
周次 | 龙书章节 | 理论主题 | 实践EP | 学时
-----|---------|---------|--------|------
8-9 | Ch7     | 运行时环境 | EP18, EP18R | 8h理论 + 12h实践
10  | Ch8     | 代码生成   | EP19, EP20 | 10h理论 + 10h实践
```

**阶段3成果**:
- 理解：虚拟机的设计和代码生成
- 实践：能够构建完整的编译器

---

### 阶段4：优化技术（第9章）

**目标**: 理解编译器优化

```
周次 | 龙书章节 | 理论主题 | 实践EP | 学时
-----|---------|---------|--------|------
11-12 | Ch9   | 数据流分析 | EP13, EP14 | 10h理论 + 8h实践
13-14 | Ch9   | 优化技术   | EP15, EP21 | 10h理论 + 10h实践
```

**阶段4成果**:
- 理解：数据流分析和优化Pass
- 实践：能够实现多种优化

---

## 📊 理论实践对照表

### 完整映射表

| 龙书章节 | 理论主题 | 核心概念 | 实践EP | 实践内容 | 难度 |
|---------|---------|---------|--------|---------|------|
| **Ch1** | 编译器结构 | 编译阶段、前端/中端/后端 | 项目概览 | 理解21个EP的架构 | ⭐ |
| **Ch2** | 语法制导翻译 | AST、属性文法 | EP3 | ANTLR4构建AST | ⭐⭐ |
| **Ch3** | 词法分析 | 正则表达式、DFA/NFA | EP1 | ANTLR4词法规则 | ⭐⭐ |
| **Ch4** | 语法分析 | CFG、LL(k)、LR(k) | EP2 | ANTLR4语法规则 | ⭐⭐⭐ |
| **Ch5** | 语法制导翻译 | SDD、SDT、属性 | EP4, EP5 | 类型检查、作用域 | ⭐⭐⭐ |
| **Ch6** | 中间代码生成 | 三地址码、SSA | EP11, EP16 | 自定义IR、线性IR | ⭐⭐⭐⭐ |
| **Ch7** | 运行时环境 | 栈帧、GC、ABI | EP18, EP18R | 栈式VM、寄存器VM | ⭐⭐⭐⭐ |
| **Ch8** | 代码生成 | 寄存器分配、指令选择 | EP19, EP20 | 完整编译器 | ⭐⭐⭐⭐ |
| **Ch9** | 机器无关优化 | 数据流分析、优化Pass | EP13-15, EP21 | 优化框架 | ⭐⭐⭐⭐⭐ |

---

## 🎯 学习建议

### 对于工程师（在职学习）

**时间有限，快速上手**:
1. **跳过理论证明**：关注概念和应用，跳过复杂的数学证明
2. **实践优先**：先运行项目代码，再查阅理论
3. **针对性学习**：遇到问题时查阅龙书相应章节

**推荐学习路径**:
```
第1周: Ch1 → 项目概览 → EP3（快速体验）
第2周: Ch3 → EP1（词法分析）
第3周: Ch4 → EP2（语法分析）
第4周: Ch6 → EP16（中间表示）
第5周: Ch7 → EP18（虚拟机）
第6周: Ch9 → EP21（优化）
```

### 对于学生（系统学习）

**理论学习+实践验证**:
1. **先读理论**：每周先阅读龙书相应章节
2. **再做实验**：完成对应的EP实践
3. **对比总结**：对比理论和实现的差异

**推荐学习路径**:
```
每周结构:
├── 2小时：阅读龙书章节
├── 2小时：阅读EP教学文档
├── 3小时：完成EP实践
└── 1小时：对比总结
```

---

## 📚 补充阅读资源

### 龙书未覆盖的重要主题

| 主题 | 龙书覆盖 | 补充资源 | 本项目实践 |
|------|---------|---------|-----------|
| **SSA形式** | ⚠️ 简略 | Cytron et al. 1991 | EP12详细实现 |
| **ANTLR4** | ❌ 未覆盖 | ANTLR4官方文档 | EP1-3使用 |
| **现代优化** | ⚠️ 基础 | LLVM文档 | EP21高级优化 |
| **JIT编译** | ❌ 未覆盖 | LuaJIT、V8文档 | 未来计划 |
| **类型推导** | ⚠️ 简略 | Pierce《Types and Programming Languages》 | EP8实现 |

### 推荐阅读顺序

**基础理论**:
1. 龙书第1-5章 → 对应：EP1-5
2. 龙书第6-7章 → 对应：EP11, EP16-18
3. 龙书第8-9章 → 对应：EP19-21

**进阶主题**:
1. SSA论文（Cytron 1991）→ 对应：EP12
2. LLVM文档 → 对应：EP21
3. JVM规范 → 对应：EP18/EP18R

---

## ✅ 检查点

### 完成每个阶段后，你应该能够：

**阶段1（前端）后**:
- [ ] 解释词法分析和语法分析的区别
- [ ] 手写简单的正则表达式和文法规则
- [ ] 使用ANTLR4构建AST
- [ ] 理解访问者模式的应用

**阶段2（中端）后**:
- [ ] 解释三地址码的优势
- [ ] 构建简单的控制流图
- [ ] 理解SSA形式的作用
- [ ] 实现基本的数据流分析

**阶段3（后端）后**:
- [ ] 设计虚拟机指令集
- [ ] 实现栈帧管理
- [ ] 理解垃圾回收的基本算法
- [ ] 构建完整的代码生成器

**阶段4（优化）后**:
- [ ] 实现常量传播优化
- [ ] 实现死代码消除
- [ ] 理解数据流分析的框架
- [ ] 设计优化Pass的执行顺序

---

## 🎓 学习成果

完成理论+实践结合学习后，你将获得：

**理论深度**:
- 编译原理的系统理论知识
- 形式化的编译器设计能力
- 理解工业级编译器的工作原理

**实践能力**:
- 能够从零设计并实现一个简单的编程语言
- 掌握ANTLR4等现代编译工具
- 理解虚拟机和字节码的设计
- 具备优化器实现的基础

**工程素养**:
- 测试驱动开发（TDD）
- 代码审查和质量标准
- 文档编写能力
- 大型项目管理经验

---

**版本**: v1.0 | **日期**: 2025-12-27 | **作者**: Claude Code

**使用建议**: 将本指南与龙书第二版配合使用，理论学习与实践操作交替进行，效果最佳。
