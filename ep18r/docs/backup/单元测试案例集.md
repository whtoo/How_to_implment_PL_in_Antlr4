# 单元测试案例集：VM与ABI设计统一

**文档版本**: v1.0
**创建日期**: 2025-12-18
**最后更新**: 2025-12-18
**制定者**: Claude Code
**基于**: TDD重构计划，ABI设计文档，VM设计文档

## 概述

本文档提供VM与ABI设计统一的具体单元测试案例，每个案例包含测试设计目的、测试实现的相关模块、测试逻辑和测试代码。测试案例按照TDD重构计划中的测试分类组织，可直接用于实施TDD。

## 1. 寄存器约定测试

### 1.1 测试寄存器ABI名称和默认值

**测试设计目的**: 验证每个寄存器具有正确的ABI名称和默认值（如zero寄存器为0，其他寄存器初始值可定义）。

**测试实现的相关模块**: `RegisterFile`, `CallingConventionUtils`

**测试逻辑**:
1. 初始化寄存器文件。
2. 检查zero寄存器（r0）是否为0且写入无效。
3. 检查其他寄存器的初始值是否符合预期（如未初始化可为任意值）。
4. 验证ABI名称映射正确。

**测试代码**:
```java
package org.teachfx.antlr4.ep18r.abi;

import org.junit.jupiter.api.Test;
import org.teachfx.antlr4.ep18r.stackvm.RegisterFile;
import static org.assertj.core.api.Assertions.*;

class RegisterABITest {

    @Test
    void testZeroRegisterAlwaysZero() {
        RegisterFile regs = new RegisterFile();
        // r0应始终为0
        assertThat(regs.get(0)).isEqualTo(0);
        // 尝试写入r0，应被忽略
        regs.set(0, 42);
        assertThat(regs.get(0)).isEqualTo(0);
    }

    @Test
    void testABINameMapping() {
        // 验证CallingConventionUtils中的映射
        assertThat(CallingConventionUtils.getABIName(0)).isEqualTo("zero");
        assertThat(CallingConventionUtils.getABIName(2)).isEqualTo("a0");
        assertThat(CallingConventionUtils.getABIName(8)).isEqualTo("s0");
        assertThat(CallingConventionUtils.getABIName(13)).isEqualTo("sp");
        assertThat(CallingConventionUtils.getABIName(14)).isEqualTo("fp");
        assertThat(CallingConventionUtils.getABIName(15)).isEqualTo("lr");
    }

    @Test
    void testCallerSavedRegisters() {
        // 验证调用者保存寄存器列表
        int[] callerSaved = CallingConventionUtils.getCallerSavedRegisters();
        assertThat(callerSaved).containsExactly(1, 2, 3, 4, 5, 6, 7, 15);
    }

    @Test
    void testCalleeSavedRegisters() {
        // 验证被调用者保存寄存器列表
        int[] calleeSaved = CallingConventionUtils.getCalleeSavedRegisters();
        assertThat(calleeSaved).containsExactly(8, 9, 10, 11, 12, 13, 14);
    }
}
```

### 1.2 测试寄存器保存责任

**测试设计目的**: 验证调用者和被调用者保存寄存器的行为符合ABI规范。

**测试实现的相关模块**: `MemoryExecutors`, `StackFrame`

**测试逻辑**:
1. 编写测试程序，调用者设置寄存器值，调用被调用者。
2. 被调用者修改调用者保存寄存器，调用者验证这些寄存器值未被保留。
3. 被调用者修改被调用者保存寄存器，但保存并恢复，调用者验证这些寄存器值保持不变。

**测试代码**:
```java
@Test
void testCallerSavedRegistersNotPreserved() {
    // 汇编程序：调用者设置a0=100，调用被调用者，被调用者修改a0=200
    String program = """
        .def caller: args=0, locals=0
            li a0, 100      # 设置a0
            call callee     # 调用
            # 返回后a0可能被修改，验证a0不是100（可能是返回值）
            # 本测试主要验证调用者保存寄存器可能被修改
            halt

        .def callee: args=0, locals=0
            li a0, 200      # 修改a0（调用者保存寄存器）
            ret
        """;
    // 加载并执行程序
    // 验证a0最终值为200（或被调用者设置的值）
}

@Test
void testCalleeSavedRegistersPreserved() {
    // 汇编程序：调用者设置s0=100，调用被调用者，被调用者修改s0但保存恢复
    String program = """
        .def caller: args=0, locals=0
            li s0, 100      # 设置s0
            call callee     # 调用
            # 返回后s0应仍为100
            seq a0, s0, 100 # 比较s0==100
            halt

        .def callee: args=0, locals=1
            # 序言保存s0
            sw s0, -12(fp)
            li s0, 200      # 修改s0
            # 尾声恢复s0
            lw s0, -12(fp)
            ret
        """;
    // 加载并执行程序
    // 验证a0为1（true），表示s0保持不变
}
```

## 2. 栈帧布局测试

### 2.1 测试栈帧偏移计算

**测试设计目的**: 验证栈帧布局工具类正确计算各区域偏移。

**测试实现的相关模块**: `StackFrameCalculator`, `StackOffsets`

**测试逻辑**:
1. 给定参数数量和局部变量数量，计算栈帧布局。
2. 验证保存寄存器区偏移（s0-s4）、局部变量区偏移、参数区偏移。
3. 验证栈帧大小满足8字节对齐。

**测试代码**:
```java
package org.teachfx.antlr4.ep18r.stackvm;

import org.junit.jupiter.api.Test;
import org.teachfx.antlr4.ep18r.stackvm.layout.*;
import static org.assertj.core.api.Assertions.*;

class StackFrameLayoutTest {

    @Test
    void testBasicStackFrameLayout() {
        // 函数有3个参数（全部在寄存器中），2个局部变量
        StackFrameLayout layout = StackFrameCalculator.calculate(3, 2, 0b11111);

        // 验证栈帧大小是8的倍数
        assertThat(layout.getFrameSize() % 8).isEqualTo(0);

        // 验证局部变量偏移
        assertThat(layout.getLocalVarOffset(0)).isEqualTo(-16); // fp-16
        assertThat(layout.getLocalVarOffset(1)).isEqualTo(-20); // fp-20

        // 验证保存寄存器偏移
        assertThat(layout.getSavedRegOffset(8)).isEqualTo(-12);  // s0 at fp-12
        assertThat(layout.getSavedRegOffset(9)).isEqualTo(-8);   // s1 at fp-8
        assertThat(layout.getSavedRegOffset(10)).isEqualTo(-4);  // s2 at fp-4

        // 验证旧fp保存位置
        assertThat(layout.getFpSaveOffset()).isEqualTo(8); // fp+8
    }

    @Test
    void testStackFrameWithStackArguments() {
        // 函数有8个参数（6个在寄存器，2个在栈上），1个局部变量
        StackFrameLayout layout = StackFrameCalculator.calculate(8, 1, 0b00111);

        // 验证栈上传参偏移
        assertThat(layout.getStackArgOffset(6)).isEqualTo(16); // 第7个参数在fp+16
        assertThat(layout.getStackArgOffset(7)).isEqualTo(20); // 第8个参数在fp+20
    }
}
```

### 2.2 测试栈帧内存布局

**测试设计目的**: 验证实际内存中栈帧布局符合计算出的偏移。

**测试实现的相关模块**: `MemoryExecutors`, `StackFrame`

**测试逻辑**:
1. 创建栈帧并写入测试数据到各个区域。
2. 通过FP相对寻址读取数据，验证偏移正确性。
3. 模拟函数序言和尾声，验证栈帧分配和释放。

**测试代码**:
```java
@Test
void testStackFrameMemoryLayout() {
    // 使用虚拟机执行测试程序，验证栈帧布局
    String program = """
        .def test_func: args=2, locals=3
            # 序言后，栈帧已分配
            # 测试局部变量存储
            li t0, 100
            sw t0, -16(fp)  # 局部变量0
            li t0, 200
            sw t0, -20(fp)  # 局部变量1

            # 测试保存寄存器存储
            li s0, 300
            sw s0, -12(fp)  # 保存s0（实际已由序言保存）

            # 验证读取
            lw a0, -16(fp)  # 应得到100
            lw a1, -20(fp)  # 应得到200
            lw a2, -12(fp)  # 应得到300

            # 设置返回值
            li a0, 0
            ret
        """;
    // 执行程序，验证寄存器a0,a1,a2的值
}
```

## 3. 函数调用测试

### 3.1 测试参数传递（寄存器参数）

**测试设计目的**: 验证前6个整数参数通过寄存器a0-a5正确传递。

**测试实现的相关模块**: `MemoryExecutors`, `CallingConventionUtils`

**测试逻辑**:
1. 调用者设置a0-a5的值，调用被调用者。
2. 被调用者读取参数寄存器，验证值正确。
3. 被调用者返回，调用者验证返回值。

**测试代码**:
```java
@Test
void testRegisterArgumentPassing() {
    String program = """
        .def caller: args=0, locals=0
            # 设置6个参数
            li a0, 10   # 参数1
            li a1, 20   # 参数2
            li a2, 30   # 参数3
            li a3, 40   # 参数4
            li a4, 50   # 参数5
            li a5, 60   # 参数6
            call callee
            # 返回值在a0中
            halt

        .def callee: args=6, locals=0
            # 验证参数值
            # 这里简单返回参数总和
            add t0, a0, a1
            add t0, t0, a2
            add t0, t0, a3
            add t0, t0, a4
            add t0, t0, a5
            mov a0, t0   # 返回值 = 10+20+30+40+50+60 = 210
            ret
        """;
    // 执行程序，验证最终a0值为210
}
```

### 3.2 测试参数传递（栈参数）

**测试设计目的**: 验证第7个及以后的参数通过栈传递。

**测试实现的相关模块**: `MemoryExecutors`, `StackFrame`

**测试逻辑**:
1. 调用者传递8个参数（6个寄存器，2个栈）。
2. 被调用者从栈上读取额外参数，验证值正确。

**测试代码**:
```java
@Test
void testStackArgumentPassing() {
    String program = """
        .def caller: args=0, locals=0
            # 设置8个参数
            li a0, 1    # 参数1
            li a1, 2    # 参数2
            li a2, 3    # 参数3
            li a3, 4    # 参数4
            li a4, 5    # 参数5
            li a5, 6    # 参数6
            # 参数7和8通过栈传递（需要手动压栈）
            li t0, 7
            sw t0, 16(sp)  # 参数7在返回地址之后
            li t0, 8
            sw t0, 20(sp)  # 参数8
            call callee
            # 返回值在a0中
            halt

        .def callee: args=8, locals=0
            # 读取栈参数（注意：序言会调整sp/fp，参数偏移需要计算）
            # 假设参数7在fp+16，参数8在fp+20
            lw t0, 16(fp)  # 应得到7
            lw t1, 20(fp)  # 应得到8
            # 计算总和：1+2+3+4+5+6+7+8 = 36
            add a0, a0, a1
            add a0, a0, a2
            add a0, a0, a3
            add a0, a0, a4
            add a0, a0, a5
            add a0, a0, t0
            add a0, a0, t1
            ret
        """;
    // 执行程序，验证a0值为36
}
```

### 3.3 测试返回值约定

**测试设计目的**: 验证单个整数返回值通过a0寄存器传递。

**测试实现的相关模块**: `MemoryExecutors`

**测试逻辑**:
1. 被调用者设置a0为返回值。
2. 调用者读取a0，验证值正确。

**测试代码**:
```java
@Test
void testReturnValueConvention() {
    String program = """
        .def caller: args=0, locals=0
            call callee
            # 返回值在a0中，应等于42
            seq a1, a0, 42  # a1=1如果相等
            halt

        .def callee: args=0, locals=0
            li a0, 42
            ret
        """;
    // 执行程序，验证a1为1
}
```

## 4. 内存访问测试

### 4.1 测试FP相对寻址

**测试设计目的**: 验证通过帧指针（FP）访问局部变量的正确性。

**测试实现的相关模块**: `MemoryExecutors`, 指令`LW`/`SW`

**测试逻辑**:
1. 在函数中通过FP偏移存储和加载局部变量。
2. 验证读写值一致。

**测试代码**:
```java
@Test
void testFPRelativeAddressing() {
    String program = """
        .def test: args=0, locals=2
            # 局部变量0在fp-16，局部变量1在fp-20
            li t0, 123
            sw t0, -16(fp)  # 存储到局部变量0
            li t0, 456
            sw t0, -20(fp)  # 存储到局部变量1

            # 读取验证
            lw a0, -16(fp)  # 应得到123
            lw a1, -20(fp)  # 应得到456

            seq a2, a0, 123
            seq a3, a1, 456
            and a0, a2, a3  # a0=1如果两个都正确
            ret
        """;
    // 执行程序，验证a0为1
}
```

### 4.2 测试结构体字段访问

**测试设计目的**: 验证`LW_F`/`SW_F`指令正确转换字节偏移为字索引。

**测试实现的相关模块**: `MemoryExecutors`, 指令`LW_F`/`SW_F`

**测试逻辑**:
1. 创建结构体实例，字段有不同字节偏移。
2. 使用`SW_F`存储值到字段，使用`LW_F`加载字段值。
3. 验证读写正确，字节偏移正确转换。

**测试代码**:
```java
@Test
void testStructFieldAccess() {
    // 假设结构体：struct S { int a; char b; int c; }
    // 内存布局：a偏移0，b偏移4，c偏移8（考虑对齐）
    String program = """
        .def test: args=0, locals=0
            # 假设结构体基址在寄存器s0中
            li s0, 0x1000  # 模拟结构体基址

            # 存储字段值
            li t0, 42
            sw_f t0, s0, 0   # S.a = 42 (偏移0)

            li t0, 99
            sw_f t0, s0, 8   # S.c = 99 (偏移8)

            # 加载字段值
            lw_f a0, s0, 0   # 应得到42
            lw_f a1, s0, 8   # 应得到99

            seq a2, a0, 42
            seq a3, a1, 99
            and a0, a2, a3   # a0=1如果两个都正确
            halt
        """;
    // 执行程序，验证a0为1
    // 注意：需要模拟内存和结构体布局
}
```

## 5. ABI一致性测试套件

### 5.1 综合ABI测试

**测试设计目的**: 综合测试ABI所有方面，确保一致性。

**测试实现的相关模块**: 整个EP18R虚拟机

**测试逻辑**:
1. 编写复杂测试程序，涉及函数嵌套调用、参数传递、返回值、寄存器保存。
2. 验证程序执行结果符合ABI规范预期。

**测试代码**:
```java
@Test
void testABIComprehensive() {
    String program = """
        .def main: args=0, locals=0
            # 测试1：寄存器保存
            li s0, 100
            li s1, 200
            li s2, 300
            call func1
            # s0-s2应保持不变
            seq t0, s0, 100
            seq t1, s1, 200
            seq t2, s2, 300
            and a0, t0, t1
            and a0, a0, t2  # a0=1如果都保持不变

            # 测试2：参数传递和返回值
            li a0, 5
            li a1, 3
            call add_func
            # 返回值应为8
            seq t0, a0, 8
            and a0, a0, t0

            # 测试3：栈参数
            li a0, 1
            li a1, 2
            li a2, 3
            li a3, 4
            li a4, 5
            li a5, 6
            li t0, 7
            sw t0, 16(sp)
            li t0, 8
            sw t0, 20(sp)
            call sum8
            # 返回值应为36
            seq t0, a0, 36
            and a0, a0, t0

            halt

        .def func1: args=0, locals=1
            # 被调用者保存s0-s2
            sw s0, -12(fp)
            sw s1, -8(fp)
            sw s2, -4(fp)
            # 修改它们的值
            li s0, 999
            li s1, 888
            li s2, 777
            # 恢复
            lw s2, -4(fp)
            lw s1, -8(fp)
            lw s0, -12(fp)
            ret

        .def add_func: args=2, locals=0
            add a0, a0, a1
            ret

        .def sum8: args=8, locals=0
            # 计算8个参数之和
            add t0, a0, a1
            add t0, t0, a2
            add t0, t0, a3
            add t0, t0, a4
            add t0, t0, a5
            lw t1, 16(fp)  # 参数7
            lw t2, 20(fp)  # 参数8
            add t0, t0, t1
            add t0, t0, t2
            mov a0, t0
            ret
        """;
    // 执行程序，验证最终a0为1（所有测试通过）
}
```

## 6. 测试夹具和工具

### 6.1 测试夹具基类

提供可重用的测试夹具，简化测试编写：

```java
package org.teachfx.antlr4.ep18r.abi;

import org.junit.jupiter.api.BeforeEach;
import org.teachfx.antlr4.ep18r.stackvm.*;

public abstract class ABITestBase {
    protected RegisterFile registers;
    protected Memory memory;
    protected MemoryExecutors executor;

    @BeforeEach
    void setUp() {
        registers = new RegisterFile();
        memory = new Memory(1024); // 1KB内存
        executor = new MemoryExecutors(registers, memory);
    }

    protected void loadAndExecute(String assembly) {
        // 汇编并执行程序
        // 实现细节略
    }
}
```

### 6.2 测试数据生成器

生成测试用的汇编程序片段：

```java
public class TestProgramGenerator {

    public static String generateFunctionCallTest(int numArgs) {
        StringBuilder sb = new StringBuilder();
        sb.append(".def caller: args=0, locals=0\n");
        // 设置参数
        for (int i = 0; i < numArgs; i++) {
            if (i < 6) {
                sb.append("    li a").append(i).append(", ").append(i+1).append("\n");
            } else {
                sb.append("    li t0, ").append(i+1).append("\n");
                sb.append("    sw t0, ").append(16 + (i-6)*4).append("(sp)\n");
            }
        }
        sb.append("    call callee\n");
        sb.append("    halt\n\n");

        sb.append(".def callee: args=").append(numArgs).append(", locals=0\n");
        sb.append("    # 计算参数总和\n");
        sb.append("    li t0, 0\n");
        for (int i = 0; i < Math.min(numArgs, 6); i++) {
            sb.append("    add t0, t0, a").append(i).append("\n");
        }
        for (int i = 6; i < numArgs; i++) {
            sb.append("    lw t1, ").append(16 + (i-6)*4).append("(fp)\n");
            sb.append("    add t0, t0, t1\n");
        }
        sb.append("    mov a0, t0\n");
        sb.append("    ret\n");

        return sb.toString();
    }
}
```

## 7. 测试执行命令

### 7.1 运行特定测试类
```bash
mvn test -pl ep18r -Dtest=RegisterABITest
```

### 7.2 运行ABI相关所有测试
```bash
mvn test -pl ep18r -Dtest="*ABI*"
```

### 7.3 生成覆盖率报告
```bash
mvn jacoco:report -pl ep18r
open ep18r/target/site/jacoco/index.html
```

## 8. 测试维护指南

### 8.1 添加新测试
1. 确定测试分类（寄存器、栈帧、函数调用等）。
2. 使用现有测试夹具基类。
3. 遵循Arrange-Act-Assert模式。
4. 提供清晰的测试名称和描述。

### 8.2 测试审查清单
- [ ] 测试名称清晰描述目的
- [ ] 测试数据覆盖正常、边界、异常场景
- [ ] 断言充分验证行为
- [ ] 测试独立，不依赖其他测试
- [ ] 测试代码可读、可维护

### 8.3 测试演进
- 新功能必须添加测试。
- 修复bug时添加回归测试。
- 定期重构测试代码，消除重复。

---

**文档状态**: 草案，测试代码待实现
**使用说明**: 实施TDD时，参考本文档编写测试代码，然后实现功能使测试通过。
**更新计划**: 随着重构进展，添加更多测试案例。