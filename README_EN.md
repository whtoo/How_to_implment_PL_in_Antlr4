# How to implement your own first ~~simple~~ programming language with antlr (Cyson:dog:)

**Every watch and star is the fuel and firewood for this dream journey**
[![Security Status](https://www.murphysec.com/platform3/v31/badge/1718907022023983104.svg)](https://www.murphysec.com/console/report/1718907021914931200/1718907022023983104)

[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/whtoo/How_to_implment_PL_in_Antlr4)
**Passion like fire, momentum like wind. Will like oil, flowing endlessly.**

## 1. Global Overview
- [x] [ep1](ep1)--Example of antlr supported EBNF syntax describing hello world.
- [x] [ep2](ep2)--How to use g4 to describe syntax like `{1,2,{3,4..}...}` array and print it in the listener.
- [x] [ep3](ep3)--Implements a mini-calculator containing only addition, subtraction, multiplication and division.
- [x] [ep4](ep4)--Implements an arithmetic calculator that allows simple interaction.
- [x] [ep5](ep5)--Implementation of a Java interface extraction tool.
- [x] [ep6](ep6)--Implements a CVS extractor.
- [x] [ep7](ep7)--Implementing a JSON parsing tool.
- [x] [ep8](ep8)--Abstract syntax tree extractor
- [x] [ep9](ep9)--ep4 enhancements
- [x] [ep10](ep10)--An alternative implementation of ep6
- [x] [ep11](ep11)--Arithmetic interpreter based on ep8 (AST Tree walking)
- [x] [ep12](ep12)--ep11 with assignment statements and variable declarations.
- [x] [ep13](ep13)--Alternative simplified implementation of ep11.
- [x] [ep14](ep14)--Implements symbol table recording.
- [x] [ep15](ep15)--Implements variable scope determination.
- [x] [ep16](ep16)--Implements variable resolution and type checking, and implements function scope and script evaluation with function calls.
- [x] [ep17](ep17)--Implements static declaration dependencies for functions (not exactly call graph generation, but included for others to avoid pitfalls).
- [x] [ep18](ep18)--Uses stack interpreter, currently very simple. Added VM instructions, updated [VM Design Document](ep18/VM_Design.md)
- [x] [ep19](ep19)--Implements simple struct (~~closure~~), currently implemented simplest record type and main function with file scope~~next chapter will add class methods and protocol support~~.
- [x] [ep20](ep20)--Focuses on IR and bytecode generation, the target machine for generated bytecode is the VM we implemented in [ep18](ep18). The reason for this is that this process is simple and precise enough to demonstrate how the most important step in the compilation backend is executed.
- [x] [ep21](ep21)--Implements TAC generation, SSA and CFG analysis.

--------------------
### Extra
‚ù§Ô∏èüëÄ: Finally finished writing, feeling so apprehensive. However, I still have a few other compilation principle related holes to fill.

First, I must thank my parents for their tremendous support.

Second, I thank myself and my wife, without our meeting I would never have been able to finish.

Finally, I thank this era, everything I needed arrived just at the right time.

--------------------

## 2. Why this tutorial series?

From the beginning of programming, I've always thought, if only I were an intent planner,
rather than a human code generator.

Therefore, I plunged into the vast ocean of programming language construction and analysis to fish
for that anchoring needle in my heart.

Now, having truly entered the realm of compilation backend processing and program analysis, I feel
I have too much knowledge, skills, ideas to record, as well as creating useful new tools and processes.

So, this is my starting point, hoping you can enjoy this process as much as I do.

## 3. Engineering System Introduction
The entire project is built based on Maven and requires the following environment support:
- a. `JDK18+` required (recommended OpenJDK 18 or higher)
- b. `Maven 3.8+` build tool
- c. `Antlr4` runtime support (managed via Maven dependencies)

### 3.1 Build Process
1. After cloning the project, execute in the root directory:
```bash
mvn clean install
```
2. Build specific module (take ep20 as example):
```bash
cd ep20
mvn clean package
```

### 3.2 Modular Configuration
The project adopts a Maven multi-module structure, each ep* directory is an independent module containing:
- `src/main/java` - main code
- `src/test/java` - test code
- `pom.xml` - module configuration

### 3.3 Dependency Management
All dependencies are managed via Maven, main dependencies include:
- Antlr4 runtime (`org.antlr:antlr4`)
- Log4j2 (`org.apache.logging.log4j:log4j-core`, `log4j-api`)
- Apache Commons Lang (`org.apache.commons:commons-lang3`)
- JUnit 5 and AssertJ (for testing)

### 3.4 How to Start (Running Examples)
Once the project is built (e.g., via `mvn clean install`), you can run specific episodes. The `scripts/run.sh` script is provided as a convenience for this.

**Using `run.sh`:**
The script helps compile, run, and test individual modules.
```bash
cd your_project_dir

# General usage:
# ./scripts/run.sh <command> <module_name> [extra_arguments_for_run_command]

# Examples:
./scripts/run.sh compile ep16    # Compile ep16 module
./scripts/run.sh run ep16       # Run ep16 module's main class
# For modules that take input files, like ep20 or ep21:
./scripts/run.sh run ep20 "src/main/resources/t.cymbol"
./scripts/run.sh run ep21 "src/main/resources/t.cymbol"
./scripts/run.sh test ep19      # Run tests for ep19

# View help for run.sh:
./scripts/run.sh help
```
**Note on older episodes (ep1-ep15):** These episodes might have outdated `run.main.entry` configurations in their `pom.xml` files. If `run.sh run <module>` fails for these, you might need to:
1. Check the `pom.xml` of the specific episode and correct the `<run.main.entry>` property to point to the actual main class.
2. Or, run the main class directly using `mvn exec:java -pl <module_name> -Dexec.mainClass="your.main.Class" -Dexec.args="..."`.

**Running without `run.sh` (Standard Maven):**
You can also run modules using standard Maven commands if you know the main class:
```bash
# Example for ep20, assuming its pom.xml has correct run.main.entry
mvn exec:java -pl ep20 -Dexec.args="src/main/resources/t.cymbol"
```

## 4. Reference Materials

# Use run.sh script
./scripts/run.sh <command> <module> [extra args]

# Examples:
./scripts/run.sh compile ep1    # Compile ep1 module
./scripts/run.sh run ep2       # Run ep2 module
./scripts/run.sh test ep3      # Run ep3 module tests
./scripts/run.sh clean ep4     # Clean ep4 module
./scripts/run.sh run ep5 "arg1 arg2" # Run ep5 module with args
./scripts/run.sh run ep20 "src/main/resources/t.cymbol" # Run ep20 with input file
./scripts/run.sh run ep21 "src/main/resources/t.cymbol" # Run ep21 with input file

# View help
./scripts/run.sh help
```

## 4. Reference Materials
### 4.1 How to interpret a program
- [Structure and Interpretation of Computer Programs (SICP)](https://www.zhihu.com/topic/19620884/hot)
- [Crafting Interpreters](http://www.craftinginterpreters.com/)
### 4.2 How to implement a calculator
- [How to implement a programming language](http://lisperator.net/pltut/)
- [Programming Language Implementation Patterns](https://www.zhihu.com/topic/20116185/hot)
- [The Definitive ANTLR 4 Reference](https://www.antlr.org/)
- [Top Down Operator Precedence (TDOP)](https://github.com/douglascrockford/TDOP)
- [Compilers: Principles, Techniques, and Tools (Dragon Book:smile:)](https://www.zhihu.com/question/21549783/answer/22749476)