# EP21 CFG增强重构执行计划

**版本**: 1.0
**创建日期**: 2026-01-19
**执行模式**: 原子任务执行模式
**任务粒度**: 所有任务 ≤ 2小时

---

## 📋 修改影响路径分析

### 直接影响的文件（必须修改）

**核心数据结构层**：
1. `CFG.java` - CFG核心类，需要扩展或重构
2. `CFGBuilder.java` - CFG构建器，需要适配新数据结构
3. `BasicBlock.java` - 基本块类，可能需要轻微修改

**接口层**：
4. `IFlowOptimizer.java` - 保持兼容性，可能需要扩展
5. `ICFGBuilder.java` - CFG构建接口，需要更新

### 间接影响的文件（需要验证和适配）

**优化器层**（8个优化器）：
1. `ControlFlowAnalysis.java` - 控制流分析
2. `TailRecursionOptimizer.java` - 尾递归优化
3. `ConstantFoldingOptimizer.java` - 常量折叠
4. `DeadCodeEliminationOptimizer.java` - 死代码消除
5. `CommonSubexpressionEliminationOptimizer.java` - 公共子表达式消除
6. `LoopInvariantCodeMotionOptimizer.java` - 循环不变代码外提
7. `LoopUnrollingOptimizer.java` - 循环展开
8. `StrengthReductionOptimizer.java` - 强度削减

**数据流分析层**：
9. `AbstractDataFlowAnalysis.java` - 数据流分析基类
10. `LivenessAnalysis.java` - 活性分析
11. `ReachingDefinitionAnalysis.java` - 到达定义分析
12. `LoopAnalysis.java` - 循环分析
13. `DominatorAnalysis.java` - 支配分析

**编译器集成层**：
14. `Compiler.java` - 主编译器，需要集成新的CFG类型

### 测试文件（需要更新或新增）

**核心测试**：
1. `CFGBuilderTest.java` - CFG构建测试
2. `CFGTest.java` - CFG结构测试
3. `BasicBlockTest.java` - 基本块测试
4. `ControlFlowAnalysisTest.java` - 控制流分析测试

**优化器测试**：
5-12. 所有优化器的测试类

**集成测试**：
13. 编译器端到端测试

### 依赖关系图

```
新数据结构 → CFG重构 → 优化器适配 → 编译器集成 → 测试更新
    ↓
文档更新
```

---

## 🗺️ 原子任务分解与依赖执行图

### 图例说明
- `→` : 强依赖关系（必须先完成）
- `↔` : 可并行任务（无依赖）
- `●` : 里程碑节点
- `⚠` : 风险点
- `📌` : 需要用户决策点

---

## 第一阶段：核心数据结构重构（预计12小时，6个原子任务）

### 任务依赖图

```
1.1 [设计CFGEdge类]
   ↕
   ↕
1.2 [实现CFGEdge类] ──→ 1.4 [实现EnhancedCFG基类] ──→ 1.5 [添加边索引管理]
   ↕                              ↕                 ↕
1.3 [设计EnhancedCFG架构]      1.6 [实现图索引接口]
```

### 原子任务清单

#### **任务 1.1** - 设计CFGEdge类（2小时）
- **状态**: ⏳ 待执行
- **描述**: 设计新的边数据结构，支持多种边类型和元数据
- **输出**:
  - CFGEdge设计文档
  - 类接口定义（Java接口或抽象类）
- **验收标准**:
  - ✅ 定义清晰的EdgeType枚举（JUMP, SUCCESSOR, FALLTHROUGH, CRITICAL等）
  - ✅ 包含sourceId, targetId, type, weight, isCritical字段
  - ✅ 提供equals, hashCode, toString方法
  - ✅ 添加完整的JavaDoc注释
- **前置条件**: 无
- **后置条件**: 任务1.2可以开始
- **风险**: ⚠ 设计不够灵活，后续需要频繁修改
- **依赖**: 无

#### **任务 1.2** - 实现CFGEdge类（1.5小时）
- **状态**: ⏳ 待执行
- **描述**: 实现CFGEdge类的完整功能
- **输出**:
  - `ep21/src/main/java/org/teachfx/antlr4/ep21/pass/cfg/CFGEdge.java`
- **验收标准**:
  - ✅ 所有字段为final（不可变）
  - ✅ 实现equals和hashCode（基于sourceId, targetId, type）
  - ✅ 提供工厂方法（of静态方法）
  - ✅ 完整的单元测试覆盖
- **前置条件**: 任务1.1完成
- **后置条件**: 任务1.4可以开始
- **依赖**: 1.1
- **备注**: 使用record模式简化实现（Java 14+特性）

#### **任务 1.3** - 设计EnhancedCFG架构（2小时）
- **状态**: ⏳ 待执行
- **描述**: 设计增强的CFG类架构，包括索引和缓存机制
- **输出**:
  - EnhancedCFG架构设计文档
  - 类图和交互关系
- **验收标准**:
  - ✅ 清晰定义与现有CFG的继承或组合关系
  - ✅ 设计索引数据结构（Map<Integer, Set<CFGEdge>>）
  - ✅ 设计缓存机制（TraversalCache, DominatorTree等）
  - ✅ 明确新增的API接口
- **前置条件**: 无
- **后置条件**: 任务1.4可以开始
- **风险**: ⚠ 架构设计过于复杂，实现困难
- **依赖**: 无

#### **任务 1.4** - 实现EnhancedCFG基类（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现EnhancedCFG核心功能，继承或组合现有CFG
- **输出**:
  - `ep21/src/main/java/org/teachfx/antlr4/ep21/pass/cfg/EnhancedCFG.java`
- **验收标准**:
  - ✅ 保持现有CFG的公共API兼容性
  - ✅ 实现边索引（outgoingEdges, incomingEdges映射）
  - ✅ 提供快速的边查询方法（O(1)复杂度）
  - ✅ 添加基本块索引（Map<Integer, BasicBlock>）
  - ✅ 完整的JavaDoc和示例代码
- **前置条件**: 任务1.2, 1.3完成
- **后置条件**: 任务1.5, 1.6可以开始
- **依赖**: 1.2, 1.3
- **备注**: 考虑使用适配器模式而非直接继承

#### **任务 1.5** - 添加边索引管理（1.5小时）
- **状态**: ⏳ 待执行
- **描述**: 实现边的快速索引和管理功能
- **输出**:
  - EnhancedCFG中的边索引方法实现
- **验收标准**:
  - ✅ addEdge()方法时间复杂度O(1)
  - ✅ removeEdge()方法正确维护索引
  - ✅ getOutgoingEdges()和getIncomingEdges()返回O(1)查询
  - ✅ 边添加/删除时自动更新links数组
- **前置条件**: 任务1.4完成
- **后置条件**: 任务2.1可以开始
- **依赖**: 1.4
- **备注**: 使用ConcurrentHashMap支持线程安全（可选）

#### **任务 1.6** - 实现图索引接口（1.5小时）
- **状态**: ⏳ 待执行
- **描述**: 实现图级别的索引和查询接口
- **输出**:
  - EnhancedCFG的索引方法实现
- **验收标准**:
  - ✅ getBlockById() O(1)查询（基于ID索引）
  - ✅ getBlockCount() 返回节点数量
  - ✅ getEdgeCount() 返回边数量
  - ✅ 提供blocks迭代器和edges迭代器
- **前置条件**: 任务1.4完成
- **后置条件**: 任务2.1可以开始
- **依赖**: 1.4

---

## 第二阶段：性能优化实现（预计10小时，5个原子任务）

### 任务依赖图

```
1.5/1.6 [完成边索引]
   ↓
2.1 [实现反向后序遍历缓存] ──→ 2.3 [实现批量边操作] ──→ 2.5 [性能基准测试]
   ↓                               ↓
2.2 [实现拓扑排序缓存]          2.4 [添加Worklist优化]
```

### 原子任务清单

#### **任务 2.1** - 实现反向后序遍历缓存（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现反向后序（Reverse Post-Order）遍历的缓存机制
- **输出**:
  - EnhancedCFG中的reversePostOrder字段和计算方法
- **验收标准**:
  - ✅ 首次调用时计算RPO，后续调用返回缓存
  - ✅ CFG结构变更时自动失效缓存
  - ✅ 提供getReversePostOrder()方法
  - ✅ 单元测试验证缓存正确性
- **前置条件**: 任务1.5, 1.6完成
- **后置条件**: 任务2.2可以开始
- **依赖**: 1.5, 1.6
- **备注**: RPO是数据流分析的关键优化点

#### **任务 2.2** - 实现拓扑排序缓存（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现拓扑排序（Topological Sort）的缓存机制
- **输出**:
  - EnhancedCFG中的topologicalOrder字段和计算方法
- **验收标准**:
  - ✅ 使用Kahn算法或DFS实现拓扑排序
  - ✅ 缓存机制避免重复计算
  - ✅ 检测和报告循环依赖（CFG不应该有循环）
  - ✅ 提供getTopologicalOrder()方法
- **前置条件**: 任务2.1完成
- **后置条件**: 任务2.3可以开始
- **依赖**: 2.1
- **备注**: 拓扑排序用于优化Pass的执行顺序

#### **任务 2.3** - 实现批量边操作（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现批量添加/删除边的API，提高多边操作性能
- **输出**:
  - EnhancedCFG中的addEdges()和removeEdges()方法
- **验收标准**:
  - ✅ addEdges(List<CFGEdge>)方法比逐个添加快
  - ✅ removeEdges(List<CFGEdge>)方法批量删除
  - ✅ 批量操作自动更新索引和links
  - ✅ 单元测试验证批量操作正确性
- **前置条件**: 任务1.5, 1.6完成
- **后置条件**: 任务2.4可以开始
- **依赖**: 1.5, 1.6
- **备注**: 批量操作显著提升CFG构建性能

#### **任务 2.4** - 添加Worklist优化（2小时）
- **状态**: ⏳ 待执行
- **描述**: 优化AbstractDataFlowAnalysis中的Worklist算法，使用优先级队列
- **输出**:
  - 优化的Worklist实现（PriorityQueue）
  - 按基本块重要性排序（循环头优先）
- **验收标准**:
  - ✅ 使用PriorityQueue替代ArrayDeque
  - ✅ 定义基本块重要性度量（如循环头、PHI节点等）
  - ✅ 收敛速度优于FIFO队列
  - ✅ 性能测试验证改进
- **前置条件**: 任务2.1, 2.2完成
- **后置条件**: 任务2.5可以开始
- **依赖**: 2.1, 2.2
- **备注**: 参考LLVM的Worklist优化策略

#### **任务 2.5** - 性能基准测试（2小时）
- **状态**: ⏳ 待执行
- **描述**: 创建性能基准测试套件，对比优化前后的性能差异
- **输出**:
  - `ep21/src/test/java/org/teachfx/antlr4/ep21/perf/CFGPerformanceTest.java`
  - 基准测试报告
- **验收标准**:
  - ✅ 测试不同规模CFG（10, 100, 1000个节点）
  - ✅ 测量边查询速度（O(n) vs O(1)）
  - ✅ 测量图遍历速度（缓存 vs 不缓存）
  - ✅ 测量批量操作性能提升
  - ✅ 生成可读的性能对比报告
- **前置条件**: 任务2.3, 2.4完成
- **后置条件**: 第三阶段可以开始
- **依赖**: 2.3, 2.4
- **备注**: 使用JMH（Java Microbenchmark Harness）进行精确测量

---

## 第三阶段：先进功能开发（预计16小时，8个原子任务）

### 任务依赖图

```
2.5 [性能基准完成]
   ↓
3.1 [设计关键边拆分算法] ──→ 3.3 [实现关键边检测] ──→ 3.5 [实现边拆分操作]
   ↕                              ↕                    ↕
3.2 [设计循环分析增强]     3.4 [实现循环信息结构]    3.6 [集成关键边拆分到CFG]
   ↓                               ↓                    ↓
3.7 [实现循环嵌套树]          3.8 [实现CFG完整性验证器]
```

### 原子任务清单

#### **任务 3.1** - 设计关键边拆分算法（2小时）
- **状态**: ⏳ 待执行
- **描述**: 设计关键边（Critical Edge）识别和拆分算法
- **输出**:
  - 关键边拆分算法设计文档
  - 算法伪代码
- **验收标准**:
  - ✅ 明确定义关键边：入度>1且出度>1的边
  - ✅ 描述拆分过程：插入新基本块分割关键边
  - ✅ 分析拆分后的CFG结构变化
  - ✅ 参考LLVM的break-crit-edges Pass实现
- **前置条件**: 第二阶段完成
- **后置条件**: 任务3.3可以开始
- **依赖**: Phase 2
- **备注**: 关键边拆分对SSA插入很重要

#### **任务 3.2** - 设计循环分析增强（2小时）
- **状态**: ⏳ 待执行
- **描述**: 设计增强的循环分析，支持自然循环、嵌套循环、循环不变表达式检测
- **输出**:
  - 循环分析增强设计文档
  - LoopInfo数据结构设计
- **验收标准**:
  - ✅ 定义NaturalLoop数据结构（header, body, predecessors）
  - ✅ 设计嵌套循环检测算法
  - ✅ 设计循环不变表达式检测方法
  - ✅ 提供循环优化指导信息
- **前置条件**: 第二阶段完成
- **后置条件**: 任务3.4可以开始
- **依赖**: Phase 2
- **备注**: 参考LoopAnalysis.java的现有实现

#### **任务 3.3** - 实现关键边检测（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现关键边的识别算法
- **输出**:
  - `ep21/src/main/java/org/teachfx/antlr4/ep21/pass/cfg/CriticalEdgeDetector.java`
- **验收标准**:
  - ✅ 扫描所有边，识别关键边
  - ✅ 标记边的isCritical属性
  - ✅ 返回关键边集合
  - ✅ 单元测试验证检测正确性
- **前置条件**: 任务3.1完成
- **后置条件**: 任务3.5可以开始
- **依赖**: 3.1
- **备注**: O(V+E)算法，线性复杂度

#### **任务 3.4** - 实现循环信息结构（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现LoopInfo数据结构，存储循环分析结果
- **输出**:
  - `ep21/src/main/java/org/teachfx/antlr4/ep21/pass/cfg/LoopInfo.java`
- **验收标准**:
  - ✅ 存储循环头、循环体、前驱、嵌套循环
  - ✅ 提供循环深度计算方法
  - ✅ 提供循环迭代次数估算（常量循环）
  - ✅ 支持循环合并查询
- **前置条件**: 任务3.2完成
- **后置条件**: 任务3.7可以开始
- **依赖**: 3.2
- **备注**: 为循环优化提供结构化信息

#### **任务 3.5** - 实现边拆分操作（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现关键边的拆分操作，插入新基本块
- **输出**:
  - `ep21/src/main/java/org/teachfx/antlr4/ep21/pass/cfg/CriticalEdgeSplitter.java`
- **验收标准**:
  - ✅ 拆分关键边，插入新的基本块
  - ✅ 正确更新所有相关边
  - ✅ 保持CFG语义不变性
  - ✅ 实现ICFGBuilder接口，可集成到优化流程
- **前置条件**: 任务3.3完成
- **后置条件**: 任务3.6可以开始
- **依赖**: 3.3
- **备注**: 参考LLVM的实现细节

#### **任务 3.6** - 集成关键边拆分到CFG（2小时）
- **状态**: ⏳ 待执行
- **描述**: 将关键边拆分功能集成到EnhancedCFG中
- **输出**:
  - EnhancedCFG中的splitCriticalEdges()方法
- **验收标准**:
  - ✅ 提供splitCriticalEdges()API
  - ✅ 自动调用CriticalEdgeSplitter
  - ✅ 返回拆分后的新CFG
  - ✅ 更新所有相关索引和缓存
- **前置条件**: 任务3.5完成
- **后置条件**: 第四阶段可以开始
- **依赖**: 3.5
- **备注**: 确保与现有优化器兼容

#### **任务 3.7** - 实现循环嵌套树（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现循环嵌套树（Loop Nesting Tree）构建和分析
- **输出**:
  - `ep21/src/main/java/org/teachfx/antlr4/ep21/pass/cfg/LoopNestingTree.java`
- **验收标准**:
  - ✅ 基于LoopInfo构建嵌套树
  - ✅ 提供父子循环查询
  - ✅ 提供循环深度遍历API
  - ✅ 支持循环层次分析
- **前置条件**: 任务3.4完成
- **后置条件**: 第四阶段可以开始
- **依赖**: 3.4
- **备注**: 循环嵌套树用于循环优化决策

#### **任务 3.8** - 实现CFG完整性验证器（2小时）
- **状态**: ⏳ 待执行
- **描述**: 实现CFG完整性检查工具，检测常见错误
- **输出**:
  - `ep21/src/main/java/org/teachfx/antlr4/ep21/pass/cfg/CFGIntegrityChecker.java`
- **验收标准**:
  - ✅ 检查基本块连通性（从入口可达所有节点）
  - ✅ 验证边一致性（所有边都有有效的源和目标）
  - ✅ 检测不可达代码（unreachable blocks）
  - ✅ 验证跳转目标有效性
  - ✅ 提供详细的错误报告
- **前置条件**: 第二阶段完成
- **后置条件**: 第四阶段可以开始
- **依赖**: Phase 2
- **备注**: 参考GCC的CFG验证逻辑

---

## 第四阶段：文档和测试（预计10小时，5个原子任务）

### 任务依赖图

```
3.5/3.6/3.7/3.8 [先进功能完成]
   ↓            ↓           ↓           ↓
4.1 [更新架构设计文档]  4.2 [迁移现有测试]  4.3 [编写新功能测试]
   ↓              ↓              ↓
   └────────────→ 4.4 [编写性能测试] ──→ 4.5 [执行回归测试]
                    ↓
               [生成最终报告]
```

### 原子任务清单

#### **任务 4.1** - 更新架构设计文档（2小时）
- **状态**: ⏳ 待执行
- **描述**: 更新`docs/01_core_design/架构设计规范.md`，添加CFG增强章节
- **输出**:
  - 更新后的架构设计文档
  - 新增第4.5章节：增强的控制流图设计
- **验收标准**:
  - ✅ 添加"4.5 增强的控制流图设计"章节
  - ✅ 包含核心数据结构描述（EnhancedCFG, CFGEdge）
  - ✅ 描述性能优化策略（缓存、索引、批量操作）
  - ✅ 描述先进CFG功能（关键边拆分、循环分析、SSA集成）
  - ✅ 提供API示例和用例
- **前置条件**: 第一阶段完成
- **后置条件**: 任务4.4可以开始
- **依赖**: Phase 1
- **备注**: 保持与文档风格一致

#### **任务 4.2** - 迁移现有测试用例（2小时）
- **状态**: ⏳ 待执行
- **描述**: 更新现有测试用例，使用新的EnhancedCFG
- **输出**:
  - 所有现有测试文件更新
- **验收标准**:
  - ✅ CFGBuilderTest适配EnhancedCFG
  - ✅ CFGTest适配EnhancedCFG
  - ✅ ControlFlowAnalysisTest适配EnhancedCFG
  - ✅ 所有209个CFG测试通过
  - ✅ 保持测试覆盖率
- **前置条件**: 第一阶段完成
- **后置条件**: 任务4.5可以开始
- **依赖**: Phase 1
- **备注**: 使用适配器模式最小化测试代码修改

#### **任务 4.3** - 编写新功能测试（2小时）
- **状态**: ⏳ 待执行
- **描述**: 为新的CFG功能编写单元测试
- **输出**:
  - `CFGEdgeTest.java` - CFGEdge测试
  - `EnhancedCFGTest.java` - EnhancedCFG功能测试
  - `CriticalEdgeSplitterTest.java` - 关键边拆分测试
  - `LoopInfoTest.java` - 循环信息测试
  - `CFGIntegrityCheckerTest.java` - CFG完整性验证测试
- **验收标准**:
  - ✅ 每个新类至少10个测试用例
  - ✅ 覆盖正常、边界、异常情况
  - ✅ 测试覆盖率≥80%
  - ✅ 所有测试通过
- **前置条件**: 第三阶段完成
- **后置条件**: 任务4.5可以开始
- **依赖**: Phase 3
- **备注**: 使用JUnit 5参数化测试

#### **任务 4.4** - 编写性能测试（2小时）
- **状态**: ⏳ 待执行
- **描述**: 编写性能测试，对比新旧实现的性能差异
- **输出**:
  - `CFGPerformanceComparisonTest.java` - 性能对比测试
  - 性能测试报告（JMH生成）
- **验收标准**:
  - ✅ 测试边查询性能（旧实现vs新实现）
  - ✅ 测试图遍历性能（缓存vs不缓存）
  - ✅ 测试批量操作性能
  - ✅ 生成JMH基准测试报告
  - ✅ 性能提升≥50%（至少在大型CFG上）
- **前置条件**: 第二阶段完成
- **后置条件**: 任务4.5可以开始
- **依赖**: Phase 2
- **备注**: 使用JMH保证测试准确性

#### **任务 4.5** - 执行回归测试（2小时）
- **状态**: ⏳ 待执行
- **描述**: 执行完整的回归测试套件，确保所有现有功能正常工作
- **输出**:
  - 回归测试报告
  - 修复的问题列表（如有）
- **验收标准**:
  - ✅ 所有209个CFG测试通过
  - ✅ 所有11个优化器集成测试通过
  - ✅ 所有新功能测试通过
  - ✅ 无新的测试失败
  - ✅ 测试覆盖率≥80%
- **前置条件**: 任务4.2, 4.3, 4.4完成
- **后置条件**: 重构完成
- **依赖**: 4.2, 4.3, 4.4
- **备注**: 运行完整测试套件：`mvn test`

---

## 📊 总体时间估算和资源需求

### 时间估算

| 阶段 | 原子任务数 | 预计时间 | 累计时间 |
|------|------------|----------|----------|
| 第一阶段：核心数据结构重构 | 6 | 12小时 | 12小时 |
| 第二阶段：性能优化实现 | 5 | 10小时 | 22小时 |
| 第三阶段：先进功能开发 | 8 | 16小时 | 38小时 |
| 第四阶段：文档和测试 | 5 | 10小时 | 48小时 |

**总预计时间**: 48小时（约6个工作日）

### 里程碑节点

| 里程碑 | 完成时间 | 交付物 |
|-------|----------|--------|
| **M1: 数据结构完成** | Day 2 | CFGEdge, EnhancedCFG基类，边索引 |
| **M2: 性能优化完成** | Day 4 | RPO缓存，拓扑排序，批量操作，Worklist优化 |
| **M3: 先进功能完成** | Day 7 | 关键边拆分，循环分析增强，完整性验证 |
| **M4: 测试和文档完成** | Day 8 | 更新文档，完整测试套件，性能报告 |

### 资源需求

**开发资源**:
- 开发工程师：1人（全职，2周）
- 代码审查：1人（兼职，每个阶段结束）

**硬件资源**:
- 开发机器：标准开发笔记本即可
- 测试环境：Java 21, Maven 3.8+
- 性能测试：需要JMH支持（Java Microbenchmark Harness）

**软件工具**:
- IDE：IntelliJ IDEA或Eclipse
- 版本控制：Git
- 构建工具：Maven
- 测试框架：JUnit 5, AssertJ
- 性能测试：JMH

**外部依赖**：
- 无新的外部依赖（仅使用Java标准库）

### 风险评估与缓解

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 架构设计过于复杂 | 高 | 中 | 采用渐进式设计，先实现核心功能 |
| 现有优化器不兼容 | 高 | 中 | 使用适配器模式，保持接口兼容 |
| 性能提升不明显 | 中 | 低 | 提前进行基准测试，调整优化策略 |
| 测试覆盖不足 | 高 | 中 | 增加测试编写时间，使用代码覆盖率工具 |
| 进度延误 | 中 | 中 | 预留缓冲时间（10%），定期评估进度 |

---

## 🎯 执行建议

### 立即行动

1. **从第一阶段开始**：任务1.1 - 设计CFGEdge类
2. **每日进度跟踪**：每天结束时更新任务状态
3. **持续集成**：每个阶段结束都运行测试套件
4. **定期回顾**：每2天回顾进度，调整计划

### 关键决策点

📌 **需要用户决策**：

1. **架构选择**：
   - 选项A：继承CFG类（保持兼容性）
   - 选项B：组合CFG类（更灵活但需要适配）
   - **建议**：选项A（继承），最小化影响

2. **性能目标**：
   - 选项A：边查询性能提升≥50%
   - 选项B：图遍历性能提升≥30%
   - 选项C：内存增加≤20%
   - **建议**：选项A优先，选项C次之

3. **功能优先级**：
   - 选项A：先实现关键边拆分（对SSA重要）
   - 选项B：先实现循环分析增强（对循环优化重要）
   - 选项C：同时并行开发
   - **建议**：选项A优先，后续扩展选项B

### 执行检查清单

**每天开始前**：
- [ ] 检查待执行任务的依赖条件
- [ ] 确认测试环境正常
- [ ] 备份当前代码状态

**每天结束时**：
- [ ] 更新todo列表状态
- [ ] 运行相关测试
- [ ] 提交代码到Git（如有进展）
- [ ] 记录遇到的问题和解决方案

**每个阶段结束时**：
- [ ] 运行完整测试套件
- [ ] 更新文档
- [ ] 进行代码审查
- [ ] 评估进度，调整下一阶段计划

---

## 📝 附录

### 任务状态跟踪表

| 任务ID | 任务名称 | 状态 | 负责人 | 开始时间 | 结束时间 | 实际耗时 |
|-------|---------|------|--------|---------|---------|----------|
| 1.1 | 设计CFGEdge类 | ⏳ | | | |
| 1.2 | 实现CFGEdge类 | ⏳ | | | |
| 1.3 | 设计EnhancedCFG架构 | ⏳ | | | |
| 1.4 | 实现EnhancedCFG基类 | ⏳ | | | |
| 1.5 | 添加边索引管理 | ⏳ | | | |
| 1.6 | 实现图索引接口 | ⏳ | | | |
| 2.1 | 实现反向后序遍历缓存 | ⏳ | | | |
| 2.2 | 实现拓扑排序缓存 | ⏳ | | | |
| 2.3 | 实现批量边操作 | ⏳ | | | |
| 2.4 | 添加Worklist优化 | ⏳ | | | |
| 2.5 | 性能基准测试 | ⏳ | | | |
| 3.1 | 设计关键边拆分算法 | ⏳ | | | |
| 3.2 | 设计循环分析增强 | ⏳ | | | |
| 3.3 | 实现关键边检测 | ⏳ | | | |
| 3.4 | 实现循环信息结构 | ⏳ | | | |
| 3.5 | 实现边拆分操作 | ⏳ | | | |
| 3.6 | 集成关键边拆分到CFG | ⏳ | | | |
| 3.7 | 实现循环嵌套树 | ⏳ | | | |
| 3.8 | 实现CFG完整性验证器 | ⏳ | | | |
| 4.1 | 更新架构设计文档 | ⏳ | | | |
| 4.2 | 迁移现有测试用例 | ⏳ | | | |
| 4.3 | 编写新功能测试 | ⏳ | | | |
| 4.4 | 编写性能测试 | ⏳ | | | |
| 4.5 | 执行回归测试 | ⏳ | | | |

---

**文档版本**: 1.0
**创建日期**: 2026-01-19
**执行模式**: 原子任务执行（≤2h/任务）
**总预计时间**: 48小时（6个工作日）
**状态**: 📋 待批准执行
