# 虚拟机执行引擎设计

## 概述
本文档详细描述 ep18r 寄存器虚拟机的执行引擎设计，包括核心组件架构、执行循环、寄存器文件管理、内存访问模型和异常处理机制。执行引擎负责解码和执行寄存器字节码指令，管理虚拟机运行时状态。

## 设计目标
1. **高性能**：高效执行寄存器指令，减少指令解码开销
2. **模块化**：清晰的组件分离，便于维护和扩展
3. **可调试**：支持单步执行、断点、寄存器查看等调试功能
4. **健壮性**：完善的错误检测和异常处理
5. **可观测性**：详细的执行统计和性能监控

## 整体架构

### 组件关系图
```
CymbolRegisterVM (主控制器)
├── RegisterVMInterpreter (指令解释器)
│   ├── InstructionDecoder (指令解码器)
│   ├── InstructionExecutor (指令执行器)
│   └── ExceptionHandler (异常处理器)
├── RegisterFile (寄存器文件)
│   ├── 16个通用寄存器
│   └── 特殊寄存器管理
├── MemoryManager (内存管理器)
│   ├── StackManager (栈管理)
│   ├── HeapManager (堆管理)
│   └── ConstantPool (常量池)
├── StackFrameManager (栈帧管理)
│   ├── CallStack (调用栈)
│   └── FrameAllocator (栈帧分配器)
└── DebugSupport (调试支持)
    ├── BreakpointManager (断点管理)
    ├── StepController (单步控制器)
    └── ExecutionTracer (执行跟踪器)
```

### 核心类职责
- **CymbolRegisterVM**：虚拟机主类，协调各组件，管理执行状态
- **RegisterVMInterpreter**：指令解释器，负责取指、解码、执行循环
- **RegisterFile**：寄存器文件，管理16个寄存器的读写访问
- **MemoryManager**：内存管理器，统一管理栈、堆、常量池
- **StackFrameManager**：栈帧管理器，处理函数调用和返回
- **DebugSupport**：调试支持，提供调试接口和工具

## 执行引擎核心

### 执行循环
```java
while (running) {
    // 1. 检查调试器（断点、单步）
    checkDebugger();

    // 2. 取指
    int instruction = fetchInstruction(programCounter);

    // 3. 解码
    InstructionInfo info = decodeInstruction(instruction);

    // 4. 执行前检查（权限、资源）
    if (!preExecuteCheck(info)) {
        handleExecutionError(info);
        continue;
    }

    // 5. 执行指令
    executeInstruction(info);

    // 6. 更新程序计数器（除非跳转指令已修改）
    updateProgramCounter(info);

    // 7. 更新统计信息
    updateStatistics(info);

    // 8. 检查停止条件
    if (shouldHalt()) {
        running = false;
    }
}
```

### 指令处理流水线
#### 阶段1：取指 (Fetch)
- 从指令缓存读取32位指令
- 指令缓存大小可配置（默认1024条指令）
- 支持指令预取，减少内存访问延迟

#### 阶段2：解码 (Decode)
- 解析操作码（bits[31:26]）
- 根据指令格式解析操作数
  - R类型：rd, rs1, rs2
  - I类型：rd, rs1, immediate
  - J类型：address
- 符号扩展立即数（16位→32位）

#### 阶段3：执行 (Execute)
- **算术运算**：访问寄存器文件，执行ALU操作
- **内存访问**：计算有效地址，加载/存储数据
- **控制流**：更新程序计数器，处理跳转
- **特殊操作**：系统调用、调试操作

#### 阶段4：写回 (Writeback)
- 将结果写回目标寄存器
- 更新条件标志寄存器（如有）
- 提交内存写入（如有）

## 寄存器文件设计

### 寄存器组织
| 寄存器 | 名称 | 读写权限 | 复位值 | 用途 |
|--------|------|----------|--------|------|
| r0 | 零寄存器 | 只读 | 0 | 恒为零，用于清零操作 |
| r1-r12 | 通用寄存器 | 读写 | 未定义 | 通用计算、临时值、局部变量 |
| r13 | SP (栈指针) | 读写 | 栈底地址 | 指向栈顶，用于栈操作 |
| r14 | FP (帧指针) | 读写 | 初始帧地址 | 指向当前栈帧基址 |
| r15 | LR (链接寄存器) | 读写 | 未定义 | 存储函数返回地址 |

### 寄存器文件接口
```java
public class RegisterFile {
    // 寄存器读操作
    public int read(int regIndex);

    // 寄存器写操作（r0写操作被忽略）
    public void write(int regIndex, int value);

    // 批量读写（用于上下文切换）
    public int[] snapshot();  // 获取所有寄存器快照
    public void restore(int[] snapshot);  // 恢复寄存器状态

    // 特殊寄存器访问
    public int getSP();
    public void setSP(int value);
    public int getFP();
    public void setFP(int value);
    public int getLR();
    public void setLR(int value);
}
```

### 寄存器分配策略
- **简单固定分配**：局部变量按声明顺序分配寄存器
- **调用约定**：
  - 参数传递：r1-r4（前4个参数），剩余参数通过栈传递
  - 返回值：r1
  - 调用者保存寄存器：r1-r8（调用者负责保存）
  - 被调用者保存寄存器：r9-r12（被调用者负责保存）
- **寄存器溢出**：当寄存器不足时，将寄存器值溢出到栈内存

## 内存管理模型

### 内存布局
```
0x00000000 ┌─────────────────┐
           │   代码区        │ 存储字节码指令
0x10000000 ├─────────────────┤
           │   常量池        │ 存储浮点、字符串常量
0x20000000 ├─────────────────┤
           │   全局数据区    │ 存储全局变量
0x30000000 ├─────────────────┤
           │   堆区          │ 动态分配内存（结构体）
0x40000000 ├─────────────────┤
           │   栈区          │ 函数调用栈（向下增长）
0x50000000 └─────────────────┘
```

### 栈帧结构
```
┌─────────────────┐ 高地址
│   调用者帧      │
├─────────────────┤
│   返回地址      │ ← FP+8
├─────────────────┤
│   旧FP          │ ← FP+4
├─────────────────┤
│   局部变量n     │ ← FP-4*(n+1)
│   ...           │
│   局部变量1     │ ← FP-8
├─────────────────┤
│   参数m         │ ← FP+12+4*(m-1)
│   ...           │
│   参数1         │ ← FP+12
├─────────────────┤
│   临时空间      │
└─────────────────┘ 低地址
```

### 内存访问操作
1. **局部变量访问**：`lw rd, fp, offset` (offset为负值)
2. **全局变量访问**：`lw_g rd, offset` (相对于全局基址)
3. **结构体字段访问**：`lw_f rd, offset` (相对于对象指针)
4. **栈操作**：通过SP寄存器进行push/pop

## 函数调用机制

### 调用约定
#### 调用者责任
1. 将参数存入寄存器r1-r4（前4个参数）或压栈（剩余参数）
2. 执行`call target`指令
3. 期望返回值在r1中

#### 被调用者责任
1. 保存调用者保存寄存器（如果需要）
2. 建立新栈帧：保存旧FP，设置新FP
3. 为局部变量分配栈空间
4. 执行函数体
5. 将返回值存入r1
6. 恢复调用者保存寄存器
7. 恢复旧栈帧
8. 执行`ret`指令返回

### 调用流程示例
```assembly
# 调用者代码
li r1, 10       # 第一个参数
li r2, 20       # 第二个参数
call add_func   # 调用函数

# 被调用者代码 (add_func)
push fp         # 保存旧FP
mov fp, sp      # 建立新栈帧
sub sp, sp, 8   # 为局部变量分配空间
# ... 函数体 ...
add r1, r1, r2  # 计算返回值
mov sp, fp      # 恢复SP
pop fp          # 恢复旧FP
ret             # 返回
```

## 异常处理机制

### 异常类型
| 异常码 | 异常名称 | 触发条件 |
|--------|----------|----------|
| 1 | 非法操作码 | 操作码不在1-42范围内 |
| 2 | 寄存器越界 | 寄存器编号不在0-15范围内 |
| 3 | 内存越界 | 访问地址超出有效内存范围 |
| 4 | 除零错误 | 整数除法除数为0 |
| 5 | 栈溢出 | 栈指针超出栈边界 |
| 6 | 栈下溢 | 栈指针低于栈底 |
| 7 | 空指针访问 | 访问空指针指向的内存 |

### 异常处理流程
1. **异常检测**：在执行阶段检测异常条件
2. **异常触发**：设置异常码和异常PC
3. **上下文保存**：保存当前寄存器状态和栈帧
4. **异常分发**：根据异常码调用对应处理例程
5. **恢复或终止**：尝试恢复执行或终止虚拟机

### 调试模式异常处理
- 在调试模式下，异常会暂停执行，进入调试器
- 支持查看异常上下文（寄存器、栈、内存）
- 支持单步继续执行或终止

## 性能优化

### 指令缓存
- **缓存大小**：可配置（默认1024条指令）
- **缓存策略**：直接映射缓存
- **缓存失效**：当PC跳转到缓存外地址时失效

### 热点检测
- 统计指令执行频率
- 识别热点代码段（循环、频繁调用函数）
- 为JIT编译做准备（未来扩展）

### 寄存器转发
- 解决RAW（读后写）数据冒险
- 在执行阶段直接将结果转发给解码阶段
- 减少流水线停顿

### 分支预测
- **简单预测**：总是预测不跳转
- **预测错误惩罚**：清空流水线，从正确地址重新取指

## 调试支持

### 断点管理
- 支持代码地址断点
- 支持条件断点（寄存器值条件）
- 断点命中时暂停执行，进入调试模式

### 单步执行
- 支持指令级单步执行
- 支持函数级单步执行（step over/into/out）
- 单步执行时显示寄存器状态变化

### 执行跟踪
- 记录指令执行历史
- 记录寄存器值变化历史
- 记录内存访问历史
- 支持回放执行轨迹

### 调试接口
```java
public interface Debugger {
    // 断点操作
    void setBreakpoint(int address);
    void clearBreakpoint(int address);

    // 执行控制
    void step();        // 单步执行
    void continue();    // 继续执行
    void pause();       // 暂停执行

    // 状态查询
    RegisterSnapshot getRegisters();
    MemorySnapshot getMemory(int address, int size);
    StackTrace getStackTrace();

    // 跟踪控制
    void startTrace();
    ExecutionTrace stopTrace();
}
```

## 执行统计

### 统计指标
- **指令计数**：各类指令执行次数
- **周期计数**：估计执行周期（用于性能分析）
- **缓存命中率**：指令缓存命中率
- **分支预测准确率**：分支预测准确率
- **内存访问统计**：读/写次数、命中率

### 性能监控
- 实时显示执行速度（指令/秒）
- 内存使用情况监控
- 热点指令识别
- 性能瓶颈分析

## 实现注意事项

### 线程安全
- 虚拟机实例非线程安全
- 多线程环境需每个线程独立虚拟机实例
- 共享数据需外部同步

### 资源管理
- 及时释放内存资源
- 限制最大执行步骤（防止无限循环）
- 监控内存使用，防止内存泄漏

### 错误恢复
- 尽可能从错误中恢复（如栈溢出可扩展栈）
- 提供详细的错误信息和上下文
- 支持安全模式（忽略非致命错误继续执行）

## 测试验证

### 单元测试
- 指令解码正确性测试
- 指令执行正确性测试
- 寄存器文件功能测试
- 内存管理功能测试

### 集成测试
- 完整程序执行测试
- 函数调用测试
- 异常处理测试
- 调试功能测试

### 性能测试
- 指令执行速度基准测试
- 内存访问性能测试
- 与栈式虚拟机的性能对比

## 附录

### A. 相关源文件
- `CymbolRegisterVM.java`：虚拟机主类
- `RegisterVMInterpreter.java`：指令解释器
- `RegisterFile.java`：寄存器文件
- `MemoryManager.java`：内存管理器
- `StackFrameManager.java`：栈帧管理器

### B. 配置参数
- `instructionCacheSize`：指令缓存大小（默认1024）
- `stackSize`：栈大小（默认65536字节）
- `heapSize`：堆大小（默认131072字节）
- `maxSteps`：最大执行步骤（默认1000000）

### C. 性能调优建议
1. 调整指令缓存大小以匹配工作集
2. 使用寄存器转发减少数据冒险
3. 优化热点代码的指令序列
4. 合理设置栈和堆大小，避免频繁扩展