# ep18r 寄存器版本实现计划

## 概述
基于 ep18 的设计规范，创建语义等价的寄存器版本 ep18r。ep18r 将实现寄存器架构的虚拟机，与现有的栈式虚拟机（ep18）保持语义等价，但使用寄存器指令集和不同的内部执行模型。

## 探索发现总结

### ep18 当前架构
1. **栈式虚拟机**：操作数栈模型，42条指令（BytecodeDefinition.java）
2. **核心组件**：CymbolStackVM、VMInterpreter、StackFrame、ByteCodeAssembler
3. **内存管理**：堆内存、结构体统一表示（StructValue）、垃圾回收（ReferenceCountingGC）
4. **汇编语法**：VMAssembler.g4 已支持寄存器语法（REG token），但当前实现未使用
5. **设计规范**：docs/VM_Design.md 描述虚拟机设计

### 项目模块结构
- 根 pom.xml 包含 ep17-ep21 模块
- ep18 模块有自己的 pom.xml，继承父模块
- 可添加 ep18r 作为新模块，位置在 ep18 之后、ep19 之前

### 栈式 vs 寄存器虚拟机差异
1. **操作数存储**：栈 vs 寄存器文件
2. **指令格式**：隐式操作数（栈顶）vs 显式寄存器操作数
3. **指令数量**：寄存器指令通常需要更多指令（load/store），但每条指令更复杂
4. **性能特征**：寄存器虚拟机通常需要更少的指令和数据移动

## 实现目标
1. **语义等价**：相同输入程序产生相同输出
2. **API 兼容**：保持与 ep18 相同的公共接口（如 VMInterpreter、VMRunner）
3. **测试兼容**：现有 .vm 测试文件应能运行（可能需要转换或适配）
4. **渐进实现**：分阶段完成，确保每个阶段可验证

## 渐进式实现计划

### 阶段 1：模块创建和基础结构
1. 创建 ep18r 目录和 pom.xml（基于 ep18 的 pom.xml）
2. 复制 ep18 的代码结构作为起点
3. 修改模块配置：artifactId 为 ep18r，包路径为 org.teachfx.antlr4.ep18r
4. 更新根 pom.xml 的 modules 列表，在 ep18 后添加 ep18r
5. 构建验证：确保 mvn compile 通过

### 阶段 2：寄存器指令集设计
1. 分析现有 42 条栈指令，设计对应的寄存器版本
   - 算术指令：`iadd r1, r2, r3` 替代栈式的 `iadd`
   - 常量加载：`iconst r1, 10` 替代 `iconst 10`
   - 内存访问：`load r1, r2, offset` 替代 `load offset`
   - 控制流：`br r1, label` 替代 `br label`
2. 定义寄存器指令编码格式（可能需要 32 位指令，包含操作码和寄存器字段）
3. 创建 RegisterBytecodeDefinition.java
4. 设计寄存器文件（如 16 或 32 个通用寄存器）

### 阶段 3：寄存器虚拟机核心实现
1. 创建 CymbolRegisterVM 类，基于 CymbolStackVM 但改用寄存器架构
2. 实现寄存器文件（register file）和寄存器分配策略
3. 实现指令解码和执行循环，支持新的寄存器指令
4. 保持相同的堆内存管理、结构体支持和垃圾回收
5. 实现栈帧管理，但局部变量存储在寄存器中（可能需要寄存器溢出处理）

### 阶段 4：汇编器和反汇编器
1. 扩展 VMAssembler.g4 语法，支持寄存器指令格式
2. 创建 RegisterByteCodeAssembler.java
3. 创建 RegisterDisAssembler.java
4. 确保向后兼容：仍能解析现有的栈式汇编代码（可选，或提供转换工具）

### 阶段 5：语义等价验证
1. 创建等价性测试框架
2. 对相同的源程序，比较栈式 VM 和寄存器 VM 的输出
3. 使用现有的 .vm 测试文件作为基准
4. 实现自动转换工具：栈式字节码 → 寄存器字节码（用于测试）

### 阶段 6：优化和性能对比
1. 实现寄存器分配优化（如线性扫描）
2. 添加性能统计和对比
3. 文档记录设计决策和性能特征

### 阶段 7：集成和文档
1. 更新项目文档，说明 ep18r 的存在和用途
2. 确保构建脚本支持 ep18r
3. 编写使用示例和教程

## 关键设计决策

### 寄存器数量（基于用户选择）
采用**简单固定分配**策略：
- 16 个通用寄存器（r0-r15）
- r0: 零寄存器（恒为 0）
- r1-r12: 通用目的寄存器
- r13: 栈指针（SP）
- r14: 帧指针（FP）
- r15: 链接寄存器（LR，存储返回地址）
- 简单分配：局部变量和临时值按顺序分配寄存器，寄存器不足时报告错误（后续可扩展为溢出到内存）

### 指令格式
32 位指令，可能格式：
- R 类型：opcode(6) | rd(5) | rs1(5) | rs2(5) | unused(11)
- I 类型：opcode(6) | rd(5) | rs1(5) | immediate(16)
- J 类型：opcode(6) | address(26)

### 与栈式指令的映射
需要设计从栈式到寄存器指令的转换策略。例如：
- 栈式 `iconst 10` → 寄存器 `iconst r1, 10`
- 栈式 `iadd`（弹出 v1, v2，压入 v1+v2）→ 寄存器 `iadd r3, r1, r2`
- 栈式 `load offset`（从局部变量加载）→ 寄存器 `load r1, fp, offset`

### 兼容性策略（基于用户选择）
采用**新的寄存器汇编格式**：
1. ep18r 使用全新的寄存器汇编语法
2. 现有 .vm 文件需要通过转换工具才能运行
3. 提供栈式字节码到寄存器字节码的转换工具
4. 简化虚拟机实现，专注于寄存器架构

## 风险与缓解
1. **复杂性**：寄存器分配和优化复杂 → 分阶段实现，先实现简单固定分配
2. **性能**：可能不如优化后的栈式 VM → 专注于语义等价，性能为次要目标
3. **测试**：确保完全等价困难 → 实现详细的对照测试框架

## 成功标准
1. 所有现有测试通过（或适配后通过）
2. 语义等价性验证通过
3. 模块可独立构建和运行
4. 文档完整

## 下一步
1. 创建 ep18r 模块目录结构
2. 复制并修改 pom.xml
3. 开始寄存器指令集设计