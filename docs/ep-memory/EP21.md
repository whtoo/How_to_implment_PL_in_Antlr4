# EP21 专属工作记忆

**EP 名称**: EP21 (高级优化编译器)
**文档版本**: v1.0
**最后更新**: 2025-12-21
**状态**: EP 专用记忆

---

## 📌 EP21 核心定位

### EP21 在架构中的位置

```
┌──────────────────────────────────────────┐
│        EP19-EP21 高级优化阶段             │
└──────────────────────────────────────────┘
                  ↓
        ┌─────────▼─────────┐
        │      EP21         │
        │  高级优化编译器      │
        └─────────┬─────────┘
                  ↓
        ┌─────────▼─────────┐
        │      EP20         │
        │  完整编译器        │
        └─────────┬─────────┘
                  ↓
        ┌─────────▼─────────┐
        │      EP19         │
        │  调试器框架        │
        └─────────────────────┘
```

**依赖关系**:
- **上游**: EP20 (完整编译器，提供优化前的代码)
- **下游**: 无 (EP21 是编译器优化阶段的终点)

**核心特性**:
- 数据流分析框架
- SSA 形式转换
- 优化传递实现
- 性能基准测试

---

## 🏗️ EP21 目录结构

```
ep21/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── org/teachfx/antlr4/ep21/
│   │   │       ├── compiler/
│   │   │       │   ├── Compiler.java              <-- 主编译器
│   │   │       │   └── CompilationResult.java
│   │   │       ├── frontend/
│   │   │       │   ├── lexer/
│   │   │       │   ├── parser/
│   │   │       │   └── semantic/
│   │   │       │       ├── TypeChecker.java
│   │   │       │       └── SymbolTable.java
│   │   │       ├── middle/
│   │   │       │   ├── ir/
│   │   │       │   │   ├── MIRNode.java          <-- 中层IR
│   │   │       │   │   └── LIRInstruction.java   <-- 低层IR
│   │   │       │   ├── cfg/
│   │   │       │   │   ├── BasicBlock.java
│   │   │       │   │   └── ControlFlowGraph.java
│   │   │       │   └── optimize/
│   │   │       │       ├── DataFlowAnalyzer.java <-- 数据流分析
│   │   │       │       ├── SSAConverter.java     <-- SSA转换
│   │   │       │       └── OptimizationPass.java <-- 优化传递
│   │   │       └── backend/
│   │   │           ├── codegen/
│   │   │           │   ├── CodeGenerator.java
│   │   │           │   └── RegisterAllocator.java
│   │   │           └── target/
│   │   │               ├── x86/
│   │   │               └── vm/
│   │   │                   └── BytecodeEmitter.java
│   │   └── resources/
│   │       └── compiler.properties
│   └── test/
│       ├── java/
│       │   └── org/teachfx/antlr4/ep21/
│       │       ├── compiler/
│       │       │   └── CompilerIntegrationTest.java
│       │       ├── middle/
│       │       │   ├── ir/
│       │       │   └── optimize/
│       │       │       ├── DataFlowAnalyzerTest.java
│       │       │       └── SSAConverterTest.java
│       │       └── backend/
│       │           └── codegen/
│       └── resources/
│           └── test-programs/
│               ├── optimization/
│               └── ssa/
└── docs/
    ├── TDD重构计划.md              <-- TDD 重构任务
    ├── 语言规范.md                  <-- Cymbol 2.0 规范
    ├── 架构设计规范.md              <-- 架构设计
    └── 高级技术实现指南.md          <-- 研究生级优化
```

### 核心文件速查表

| 功能模块 | 主要文件 | 关键类 | 测试文件 |
|----------|----------|--------|----------|
| **编译器主控** | `Compiler.java` | `Compiler` | `CompilerIntegrationTest.java` |
| **类型检查** | `TypeChecker.java` | `TypeChecker` | `TypeCheckerTest.java` |
| **中层 IR** | `MIRNode.java` | `MIRNode` | `MIRTest.java` |
| **低层 IR** | `LIRInstruction.java` | `LIRInstruction` | `LIRTest.java` |
| **数据流分析** | `DataFlowAnalyzer.java` | `DataFlowAnalyzer` | `DataFlowAnalyzerTest.java` |
| **SSA 转换** | `SSAConverter.java` | `SSAConverter` | `SSAConverterTest.java` |
| **优化传递** | `OptimizationPass.java` | `OptimizationPass` | `OptimizationPassTest.java` |
| **代码生成** | `CodeGenerator.java` | `CodeGenerator` | `CodeGeneratorTest.java` |
| **寄存器分配** | `RegisterAllocator.java` | `RegisterAllocator` | `RegisterAllocatorTest.java` |

---

## 🔑 关键类和接口

### 核心类

#### 1. Compiler (编译器主类)
```java
public class Compiler {
    private final Frontend frontend;      // 前端
    private final MiddleEnd middleEnd;    // 中端
    private final Backend backend;        // 后端
    
    public CompilationResult compile(SourceFile source) {
        // 1. 前端: 词法/语法/语义分析
        AST ast = frontend.parse(source);
        
        // 2. 中端: IR 生成和优化
        MIR mir = middleEnd.generateMIR(ast);
        LIR lir = middleEnd.optimize(mir);
        
        // 3. 后端: 代码生成
        return backend.generateCode(lir);
    }
}
```

**前端职责**:
- 词法分析: 将源码转为 Token 流
- 语法分析: 构建抽象语法树 (AST)
- 语义分析: 类型检查、符号解析

**中端职责**:
- IR 生成: AST → MIR → LIR
- CFG 构建: 控制流图
- 优化: 常量传播、死代码删除等

**后端职责**:
- 寄存器分配
- 指令选择和调度
- 目标代码生成 (x86/VM)

#### 2. MIRNode (中层 IR)
```java
public abstract class MIRNode {
    private final Location location;
    private Type type;
    
    // 接受访问者模式
    public abstract <T> T accept(MIRVisitor<T> visitor);
}

// 具体节点类型
public class MIRFunction extends MIRNode {
    private List<MIRParameter> parameters;
    private List<MIRBlock> blocks;
}

public class MIRIfStmt extends MIRNode {
    private MIRExpression condition;
    private MIRBlock thenBlock;
    private MIRBlock elseBlock;
}
```

#### 3. DataFlowAnalyzer (数据流分析)
```java
public class DataFlowAnalyzer {
    private final ControlFlowGraph cfg;
    
    // 活跃变量分析
    public Set<Variable> analyzeLiveVariables(BasicBlock block);
    
    // 到达定义分析
    public Map<Variable, Set<Definition>> analyzeReachingDefinitions();
    
    // 可用表达式分析
    public Set<Expression> analyzeAvailableExpressions();
    
    // 常量传播
    public Map<Variable, Constant> analyzeConstantPropagation();
}
```

**分析类型**:
1. **活跃变量分析**: 哪些变量在基本块出口仍然需要
2. **到达定义分析**: 哪些定义可以到达某个使用点
3. **可用表达式分析**: 哪些表达式已经被计算过
4. **常量传播**: 哪些变量在编译时已知

#### 4. SSAConverter (SSA 转换)
```java
public class SSAConverter {
    /**
     * 将 LIR 转换为 SSA 形式
     * 1. 计算支配树
     * 2. 计算支配边界
     * 3. 插入 φ 函数
     * 4. 重命名变量
     */
    public SSALIR convertToSSA(LIR lir);
    
    /**
     * 将 SSA 形式销毁 (准备代码生成)
     * 1. 替换 φ 函数为副本
     * 2. 寄存器分配
     */
    public LIR destructSSA(SSALIR ssa);
}
```

**SSA 构建步骤**:
1. **支配树计算**: 确定基本块之间的支配关系
2. **支配边界计算**: 确定在哪些地方需要 φ 函数
3. **φ 函数插入**: 在合并点插入 φ 函数
4. **变量重命名**: 让每个变量只被赋值一次

#### 5. OptimizationPass (优化传递)
```java
public interface OptimizationPass {
    String getName();
    
    /**
     * 优化 IR
     * @return true 如果有优化 applied
     */
    boolean optimize(IR ir);
}

// 具体优化实现
public class DeadCodeElimination implements OptimizationPass {
    public boolean optimize(IR ir) {
        // 删除不可达代码
        // 删除无用赋值
    }
}

public class ConstantFolding implements OptimizationPass {
    public boolean optimize(IR ir) {
        // 计算常量表达式
        // 替换为结果
    }
}
```

**优化流水线**:
```
输入 IR
   ↓
常量折叠 (Constant Folding)
   ↓
死代码删除 (Dead Code Elimination)
   ↓
公共子表达式消除 (Common Subexpression Elimination)
   ↓
循环不变量外提 (Loop Invariant Code Motion)
   ↓
输出优化后的 IR
```

---

## 📋 EP21 任务规范

### 添加新优化传递

```bash
# 步骤 1: 创建优化类
# src/main/java/org/teachfx/antlr4/ep21/middle/optimize/CopyPropagation.java

# 步骤 2: 实现 OptimizationPass 接口
public class CopyPropagation implements OptimizationPass {
    @Override
    public boolean optimize(IR ir) { ... }
}

# 步骤 3: 注册到优化流水线
# 编辑 OptimizePasses.java
copyPropagation,  // 复制传播

# 步骤 4: 编写测试
@Test
void testCopyPropagationEliminatesRedundantCopies() { ... }

# 步骤 5: 验证效果
mvn test -pl ep21 -Dtest=CopyPropagationTest
```

### 性能基准测试

```bash
# 步骤 1: 准备测试程序
cat > test-programs/performance/fibonacci.csymbol <<EOF
function fib(n: int): int {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}
EOF

# 步骤 2: 配置 JMH 基准测试
cat > benchmark/CompilerBenchmark.java <<EOF
@Benchmark
public void compileFibonacci() {
    compiler.compile("fibonacci.csymbol");
}
EOF

# 步骤 3: 运行基准测试
mvn test -P benchmark -pl ep21

# 步骤 4: 分析结果
# 查看 target/jmh-result.csv
```

### 测试结果
- **测试类**: `ep21/src/test/java/org/teachfx/antlr4/ep21/**/*.java`
- **覆盖率要求**: 
  - 整体: ≥85%
  - 优化模块: ≥90%
  - 新功能: 100%

---

## 🔗 跨 EP 依赖接口

### EP21 依赖 EP20

#### 1. 完整编译器接口
```java
// EP20 提供的编译器接口
public interface EP20Compiler {
    /**
     * 编译但不优化，返回 LIR
     */
    LIR compileWithoutOptimization(SourceFile source);
    
    /**
     * 获取编译时的中间结果
     */
    CompilationArtifacts getArtifacts();
}
```

#### 2. 字节码输出
```java
// EP20 生成的字节码
public class BytecodeOutput {
    private final byte[] bytecode;
    private final DebugInfo debugInfo;
    
    public int execute(VM vm);
}
```

### EP21 为 EP18/EP18R 提供支持

#### 1. 优化字节码
```java
// EP21 优化后的字节码更小更快
public class OptimizedBytecode {
    private final byte[] optimizedCode;
    private final OptimizationMetrics metrics;
    
    public int getSizeReduction();  // 代码大小减少 %
    public int getPerformanceGain(); // 性能提升 %
}
```

---

## 📖 快速参考

### 常用命令

```bash
# 编译 EP21
mvn clean compile -pl ep21

# 运行测试
mvn test -pl ep21

# 生成覆盖率报告
mvn jacoco:report -pl ep21
open ep21/target/site/jacoco/index.html

# 性能基准测试
mvn test -P benchmark -pl ep21

# 文档生成
mvn javadoc:javadoc -pl ep21
```

### 优化效果评估

#### 测量指标
```java
// 优化效果数据结构
public class OptimizationMetrics {
    private int instructionCount;      // 指令数减少
    private int memoryAccesses;        // 内存访问减少
    private Set<String> removedInstrs; // 删除的指令
    private Map<String, Integer> stats; // 统计数据
}
```

#### 性能对比
```bash
# 对比优化前后的性能
# Before optimization: 1000ms
# After constant folding: 850ms (提升 15%)
# After dead code elimination: 780ms (提升 22%)
# After SSA optimization: 650ms (提升 35%)
```

---

## 📊 当前状态

### 实现完整性
- [✅] 前端: 词法/语法/语义分析
- [✅] 中端: MIR/LIR + CFG 构建
- [✅] 数据流分析框架
- [✅] SSA 形式转换
- [✅] 基础优化传递
- [🔄] 高级优化 (进行中)
- [⏸️] 后端代码生成增强 (待实现)

### 重构任务状态 (基于TDD重构计划)
**当前阶段**: Phase3 优化层重构 (进行中)

**已完成任务**:
- ✅ **Phase1 基础设施重构** (2025-12-23)
  - TASK-1.1 测试框架升级 (JUnit5配置, JaCoCo覆盖率检查)
  - TASK-1.2 构建系统优化 (POM清理, 依赖统一)

- ✅ **Phase3.1 数据流分析框架重构** (2025-12-22)
  - TASK-3.1.2 重构统一数据流接口 (`DataFlowAnalysis<T, I>`)
  - TASK-3.1.3 实现迭代求解器 (`AbstractDataFlowAnalysis`)
  - 示范分析器: `LiveVariableAnalysis`, `ReachingDefinitionAnalysis`

**进行中任务**:
- 🔄 **Phase3.2 SSA形式转换重构** (预计 2026-01-03)
  - TASK-3.2.2 重构支配树算法
  - TASK-3.2.3 改进Φ函数插入
  - TASK-3.2.4 实现变量重命名

- 🔄 **Phase3.3 控制流优化重构** (研究生进阶)
- 🔄 **Phase3.4 高级数据流分析扩展** (研究生进阶)

**待开始任务**:
- ⏸️ **Phase2 中间表示层重构** (依赖Phase1.5性能基准框架)
- ⏸️ **Phase4 后端层重构** (依赖Phase2和Phase3)

### 测试覆盖
| 模块 | 覆盖率 | 状态 |
|------|--------|------|
| 前端 | 94.1% | ✅ |
| 中端 - IR | 92.8% | ✅ |
| 中端 - 优化 | 89.3% | 🔄 |
| 后端 | 85.6% | ✅ |
| **整体** | **90.2%** | ✅ |

---

**维护**: EP21 工作专用，包含最新编译器架构
**关键要求**: 所有优化必须有基准测试验证效果
**代码标准**: 严格遵循 EP21 规范文档
**工作记忆加载位置**: `docs/ep-memory/EP21.md` (本文件)
**最后更新**: 2025-12-22
