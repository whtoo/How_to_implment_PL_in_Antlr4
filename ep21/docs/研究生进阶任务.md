# EP21 研究生进阶任务

**版本**: v1.0 | **日期**: 2026-01-07 | **状态**: 文档创建
**目的**: 为研究生提供高级编译器优化实现任务和学习路径
**相关文档**: [TDD执行计划_精简版](TDD执行计划_精简版.md) | [详细任务分解](详细任务分解.md) | [测试模板](测试模板.md)

---

## 1. 研究生进阶任务概述

### 1.1 任务定位

EP21研究生进阶任务面向**硕士/博士研究生**，提供工业级编译器优化技术的实现机会。这些任务需要较深的编译器理论知识和较强的工程能力，适合作为**毕业论文研究课题**或**深度学习项目**。

### 1.2 学习目标

1. **理论深度**: 掌握现代编译器优化理论
2. **工程能力**: 实现工业级优化算法
3. **研究思维**: 培养创新性算法设计能力
4. **论文写作**: 结合实践产出学术成果

### 1.3 适用人群

| 学习阶段 | 推荐任务 | 难度 | 预计周期 |
|---------|----------|------|----------|
| **硕士一年级** | 到达定义分析、线性扫描寄存器分配 | ⭐⭐ | 1学期 |
| **硕士二年级** | 图着色寄存器分配、指令选择算法 | ⭐⭐⭐⭐ | 1-2学期 |
| **硕士三年级/博士** | 自动并行化、高级垃圾回收算法 | ⭐⭐⭐⭐⭐ | 2-3学期 |

---

## 2. 进阶任务分类

### 2.1 按难度分级

#### ⭐⭐ 初级进阶（适合硕士一年级）
- 到达定义分析
- 线性扫描寄存器分配
- 常量传播分析
- 死代码消除

#### ⭐⭐⭐⭐ 中级进阶（适合硕士二年级）
- 图着色寄存器分配
- 指令选择算法
- 循环优化（循环不变量提取、循环展开）
- 类型系统扩展（结构体）

#### ⭐⭐⭐⭐⭐ 高级进阶（适合硕士三年级/博士）
- 自动并行化
- 高级垃圾回收算法（增量GC、并行GC）
- 自定义优化算法设计
- JIT编译器优化

### 2.2 按研究领域分类

#### 数据流分析领域
- 到达定义分析
- 常量传播分析
- 可用表达式分析
- 条件常量传播

#### 寄存器分配领域
- 线性扫描寄存器分配
- 图着色寄存器分配
- 溢出代码生成
- 寄存器压力评估

#### 指令选择领域
- 树匹配算法
- 动态规划指令选择
- 线性扫描指令选择
- 指令代价模型

#### 优化Pass领域
- 循环优化
- 死代码消除
- 公共子表达式消除
- 常量折叠

#### 运行时系统领域
- 垃圾回收
- 异常处理
- 栈展开机制
- 堆内存管理

#### 类型系统领域
- 结构体/联合体
- 泛型/模板机制
- 类型推导
- 类型约束求解

---

## 3. 任务详解

### 3.1 初级进阶任务

#### TASK-R1: 到达定义分析

**难度**: ⭐⭐ | **预计工作量**: 30-45小时 | **适合阶段**: 硕士一年级

**任务描述**:
实现到达定义分析（Reaching Definitions Analysis），这是一种经典的前向数据流分析，用于确定程序中每个点的变量定义可能来自哪些赋值语句。

**理论背景**:
到达定义分析是数据流分析的基础，其核心思想是：
- **gen集合**: 生成定义的集合（如赋值语句）
- **kill集合**: 杀死定义的集合（如同名变量的新赋值）
- **数据流方程**: `in[B] = ∪ (out[P] for P in pred[B])`
- **转移函数**: `out[B] = gen[B] ∪ (in[B] - kill[B])`

**实现步骤**:
1. 定义数据流信息结构（定义集合表示）
2. 实现gen和kill集合计算
3. 实现数据流方程迭代求解器
4. 实现控制流遍历
5. 验证分析结果正确性

**验收标准**:
- **正确性**:
  - [ ] 正确计算每个基本块的gen和kill集合
  - [ ] 正确求解数据流方程直至收敛
  - [ ] 通过10+个测试用例验证
- **性能**:
  - [ ] 分析时间线性于程序大小
  - [ ] 内存使用合理
- **文档**:
  - [ ] 完整的设计文档
  - [ ] 算法复杂度分析
  - [ ] 测试用例说明

**学习资源**:
- 《编译原理》第9章 - 数据流分析
- "A Unified Approach to Global Program Optimization" (Kildall, 1973)
- LLVM实现参考: `llvm/lib/Transforms/Utils/SSA.cpp`

**扩展方向**:
- 条件常量传播
- 部分冗余消除
- 指针别名分析

---

#### TASK-R2: 线性扫描寄存器分配

**难度**: ⭐⭐ | **预计工作量**: 45-65小时 | **适合阶段**: 硕士一年级

**任务描述**:
实现线性扫描寄存器分配算法（Linear Scan Register Allocation），这是一种快速的寄存器分配算法，适用于即时编译（JIT）和现代编译器。

**理论背景**:
线性扫描算法的核心思想：
- 将寄存器分配建模为**区间着色问题**
- 活跃变量形成不重叠的区间
- 使用贪心策略分配寄存器
- 溢出活跃区间最长的变量

**算法步骤**:
1. **区间计算**: 为每个变量计算活跃区间
2. **区间排序**: 按起始位置排序
3. **贪心分配**:
   - 尝试分配可用寄存器
   - 处理区间冲突（溢出到内存）
4. **代码生成**: 插入load/store指令

**实现步骤**:
1. 扩展活跃变量分析以计算活跃区间
2. 实现线性扫描算法
3. 实现溢出代码生成
4. 集成到代码生成流程
5. 性能测试和优化

**验收标准**:
- **正确性**:
  - [ ] 正确计算活跃区间
  - [ ] 正确处理寄存器冲突
  - [ ] 溢出代码正确生成
  - [ ] 通过20+个测试用例验证
- **性能**:
  - [ ] 分配时间线性于变量数量
  - [ ] 寄存器利用率≥70%
  - [ ] 溢出指令占比≤15%
- **对比**:
  - [ ] vs 栈分配: 性能提升≥20%
  - [ ] vs 图着色: 分配速度≥5x

**学习资源**:
- "Linear Scan Register Allocation" (Poletto & Sarkar, 1999)
- LLVM实现参考: `llvm/lib/CodeGen/LinearScanRegisterAllocator.cpp`
- V8 TurboFan寄存器分配实现

**扩展方向**:
- 寄存器分配优化（寄存器重命名）
- 特殊寄存器处理
- 多寄存器类支持

---

#### TASK-R3: 常量传播分析

**难度**: ⭐⭐ | **预计工作量**: 40-60小时 | **适合阶段**: 硕士一年级

**任务描述**:
实现条件常量传播分析（Constant Propagation），这是一种基于格理论的优化，用于在编译时计算常量表达式的值。

**理论背景**:
常量传播使用三值格（3-value lattice）:
- **⊥** (Bottom): 未知值
- **c** (Constant): 具体常量值
- **⊤** (Top): 非常量值

**数据流方程**:
- **Meet操作**: 取交集（最保守估计）
- **转移函数**: 根据语句类型更新状态
- **收敛条件**: 格状态不再变化

**实现步骤**:
1. 定义数据流格（三值格）
2. 实现转移函数（赋值、二元运算、分支）
3. 实现工作列表算法
4. 集成到优化流水线
5. 性能验证

**验收标准**:
- **正确性**:
  - [ ] 正确识别常量表达式
  - [ ] 正确传播常量值
  - [ ] 正确处理分支条件
  - [ ] 通过15+个测试用例验证
- **性能**:
  - [ ] 分析时间线性于程序大小
  - [ ] 常量替换率≥30%
  - [ ] 编译时间增加<5%
- **优化效果**:
  - [ ] 删除恒真/恒假条件分支
  - [ ] 消除无用计算
  - [ ] 代码大小减少≥10%

**学习资源**:
- "Constant Propagation with Conditional Branches" (Wegman & Zadeck, 1991)
- 《编译原理》第9.4节
- GCC实现参考: `gcc/tree-ssa-dom.c`

**扩展方向**:
- 条件常量传播
- 稀条件常量传播
- 抽象解释

---

#### TASK-R4: 死代码消除

**难度**: ⭐⭐ | **预计工作量**: 25-40小时 | **适合阶段**: 硕士一年级

**任务描述**:
实现死代码消除（Dead Code Elimination, DCE），基于数据流分析结果删除不可达代码和无用赋值。

**理论背景**:
死代码消除分为两种类型：
1. **不可达代码消除**: 控制流无法到达的代码块
2. **死存储消除**: 定义后从未被使用的变量赋值

**算法步骤**:
1. **不可达代码**:
   - 使用深度优先搜索识别可达基本块
   - 删除不可达块

2. **死存储消除**:
   - 使用活跃变量分析识别未使用变量
   - 删除对应的赋值语句

3. **迭代消除**: 重复执行直至收敛

**实现步骤**:
1. 实现基本块可达性分析
2. 实现死存储检测
3. 实现代码删除逻辑
4. 集成到优化流水线
5. 性能测试

**验收标准**:
- **正确性**:
  - [ ] 正确识别不可达代码
  - [ ] 正确检测死存储
  - [ ] 删除后语义保持不变
  - [ ] 通过15+个测试用例验证
- **性能**:
  - [ ] 分析时间线性于程序大小
  - [ ] 代码删除率≥20%
  - [ ] 编译时间增加<3%
- **优化效果**:
  - [ ] 代码大小显著减少
  - [ ] 执行时间无回归
  - [ ] 测试覆盖率≥90%

**学习资源**:
- 《编译原理》第10.5节
- LLVM实现参考: `llvm/lib/Transforms/Scalar/DeadCodeElimination.cpp`
- 数据流分析基础

**扩展方向**:
- 死代码消除与常量传播结合
- 未定义行为检测
- 异常路径优化

---

### 3.2 中级进阶任务

#### TASK-R5: 图着色寄存器分配

**难度**: ⭐⭐⭐⭐ | **预计工作量**: 80-120小时 | **适合阶段**: 硕士二年级

**任务描述**:
实现基于图着色的寄存器分配算法（Graph Coloring Register Allocation），这是工业级编译器常用的寄存器分配技术。

**理论背景**:
图着色寄存器分配将问题建模为：
- **变量** = 图的节点
- **变量干涉** = 图的边
- **寄存器** = 图的颜色
- **目标**: 用最少颜色为图着色（NP完全问题）

**算法步骤**:
1. **干涉图构建**: 基于活跃变量分析构建干涉图
2. **简化阶段**: 优先删除度数<k的节点（k=可用寄存器数）
3. **溢出选择**: 当无法继续简化时，选择代价最小的节点溢出
4. **分配阶段**: 按逆序为节点分配寄存器
5. **溢出代码生成**: 插入load/store指令

**实现步骤**:
1. 实现干涉图数据结构
2. 实现图简化算法
3. 实现溢出代价计算
4. 实现寄存器分配算法
5. 实现溢出代码生成
6. 性能调优和测试

**验收标准**:
- **正确性**:
  - [ ] 正确构建干涉图
  - [ ] 正确处理寄存器溢出
  - [ ] 溢出代码正确生成
  - [ ] 通过30+个测试用例验证
- **性能**:
  - [ ] 寄存器利用率≥80%
  - [ ] 溢出指令占比≤10%
  - [ ] 分配时间线性于变量数量
- **对比**:
  - [ ] vs 线性扫描: 性能提升≥30%
  - [ ] vs GCC: 溢出数相当
- **算法质量**:
  - [ ] 支持寄存器类
  - [ ] 支持特殊寄存器
  - [ ] 溢出代价模型准确

**学习资源**:
- "Register Allocation via Coloring of Chordal Graphs" (Hack et al., 2006)
- "Register Allocation for Programs in SSA Form" (Briggs et al., 1998)
- LLVM实现参考: `llvm/lib/CodeGen/RegAllocGreedy.cpp`
- GCC实现参考: `gcc/regalloc.c`

**扩展方向**:
- 迭代共着色
- 带寄存器类的分配
- 溢出代码优化

---

#### TASK-R6: 指令选择算法

**难度**: ⭐⭐⭐⭐ | **预计工作量**: 60-90小时 | **适合阶段**: 硕士二年级

**任务描述**:
实现基于树匹配和动态规划的指令选择算法（Instruction Selection），这是代码生成器的核心组件。

**理论背景**:
指令选择问题：
- **输入**: 抽象语法树（AST）或IR树
- **目标**: 选择最优的机器指令序列
- **挑战**: 指令覆盖模式（Tiling）是NP完全问题

**算法类型**:
1. **最大Munch**: 贪心算法，简单但非最优
2. **动态规划**: 保证最优，但开销较大
3. **树匹配**: 平衡性能和代码质量

**实现步骤**:
1. 定义指令模式（模式匹配规则）
2. 实现模式匹配器
3. 实现动态规划算法
4. 实现代码生成器
5. 性能测试和调优

**验收标准**:
- **正确性**:
  - [ ] 正确匹配指令模式
  - [ ] 动态规划找到最优匹配
  - [ ] 生成的代码正确执行
  - [ ] 通过25+个测试用例验证
- **性能**:
  - [ ] 指令选择时间线性于IR大小
  - [ ] 生成指令数接近手工优化
  - [ ] 编译时间增加<10%
- **代码质量**:
  - [ ] 指令数减少≥15%
  - [ ] 关键路径延迟优化
  - [ ] 指令集覆盖率≥90%

**学习资源**:
- "Engineering a Simple, Efficient Code-Generator Generator" (Fraser et al., 1993)
- "Linear Scan Instruction Selection" (Aho et al., 2007)
- LLVM实现参考: `llvm/lib/CodeGen/SelectionDAG`
- GCC实现参考: `gcc/insn-emit.c`

**扩展方向**:
- 指令调度
- 谓词执行支持
- VLIW指令选择

---

#### TASK-R7: 循环优化

**难度**: ⭐⭐⭐ | **预计工作量**: 50-80小时 | **适合阶段**: 硕士二年级

**任务描述**:
实现循环不变量提取（Loop Invariant Code Motion）和循环展开（Loop Unrolling）等经典循环优化技术。

**理论背景**:
循环不变量提取:
- **目标**: 将循环内不变的计算移到循环外
- **条件**: 计算不依赖于循环变量
- **收益**: 减少循环体执行次数

**算法步骤**:
1. **循环识别**: 识别自然循环
2. **不变量分析**: 识别循环不变量
3. **外提移动**: 将不变量移到前置基本块
4. **循环展开**: 复制循环体减少分支开销
5. **验证**: 确保优化不改变语义

**实现步骤**:
1. 实现循环识别算法（支配树分析）
2. 实现不变量分析
3. 实现代码外提
4. 实现循环展开
5. 性能测试

**验收标准**:
- **正确性**:
  - [ ] 正确识别循环结构
  - [ ] 正确识别循环不变量
  - [ ] 优化后语义保持不变
  - [ ] 通过20+个测试用例验证
- **性能**:
  - [ ] 不变量提取率≥40%
  - [ ] 循环展开后性能提升≥15%
  - [ ] 代码膨胀≤2x
- **算法质量**:
  - [ ] 支持嵌套循环
  - [ ] 支持break/continue
  - [ ] 处理循环副作用

**学习资源**:
- 《编译原理》第10.3节
- LLVM实现参考: `llvm/lib/Transforms/Scalar/LICM.cpp`
- GCC实现参考: `gcc/tree-ssa-loop-manip.c`

**扩展方向**:
- 循环向量化
- 循环交换
- 循环融合

---

#### TASK-R8: 类型系统扩展

**难度**: ⭐⭐⭐ | **预计工作量**: 70-100小时 | **适合阶段**: 硕士二年级

**任务描述**:
实现结构体（Struct）类型支持，包括类型表示、成员访问代码生成、内存布局计算等。

**理论背景**:
结构体类型系统:
- **类型表示**: 字段名到类型的映射
- **内存布局**: 考虑对齐要求的字段排列
- **成员访问**: 通过偏移量访问字段

**实现步骤**:
1. 实现StructType类型表示
2. 实现内存布局计算（对齐、填充）
3. 实现成员访问代码生成
4. 扩展类型检查
5. 优化内存布局

**验收标准**:
- **正确性**:
  - [ ] 结构体类型正确表示
  - [ ] 成员访问代码正确
  - [ ] 类型检查准确
  - [ ] 通过25+个测试用例验证
- **性能**:
  - [ ] 内存访问开销合理
  - [ ] 内存布局高效
  - [ ] 编译时间增加<5%
- **功能**:
  - [ ] 支持嵌套结构体
  - [ ] 支持结构体数组
  - [ ] 支持结构体函数参数

**学习资源**:
- 《程序设计语言》第7章
- LLVM IR手册 - StructType
- Go语言实现参考

**扩展方向**:
- 联合体（Union）支持
- 位域（Bit Field）支持
- 泛型/模板机制

---

### 3.3 高级进阶任务

#### TASK-R9: 自动并行化

**难度**: ⭐⭐⭐⭐⭐ | **预计工作量**: 150-200小时 | **适合阶段**: 硕士三年级/博士

**任务描述**:
实现循环自动并行化（Automatic Loop Parallelization），将串行循环转换为并行执行的多线程代码。

**理论背景**:
循环并行化的核心挑战:
1. **依赖分析**: 识别循环携带依赖
2. **安全并行化**: 确保数据依赖不破坏语义
3. **负载均衡**: 合理划分工作单元
4. **同步开销**: 最小化线程同步成本

**算法步骤**:
1. **依赖分析**: 使用数组数据流分析
2. **并行化判定**: 检查是否可以并行执行
3. **代码生成**: 生成并行循环（OpenMP、Pthreads）
4. **运行时支持**: 实现线程池、任务调度
5. **性能调优**

**实现步骤**:
1. 实现数组数据流分析
2. 实现循环依赖检测
3. 实现并行代码生成
4. 实现运行时支持
5. 性能测试和论文撰写

**验收标准**:
- **正确性**:
  - [ ] 正确识别可并行循环
  - [ ] 并行代码执行结果正确
  - [ ] 无数据竞争
  - [ ] 通过20+个测试用例验证
- **性能**:
  - [ ] 4核CPU上加速比≥2.5x
  - [ ] 8核CPU上加速比≥5x
  - [ ] 可扩展性接近线性
- **创新性**:
  - [ ] 提出新的优化技术
  - [ ] 发表会议或期刊论文

**学习资源**:
- "The Omega Test" (Pugh, 1992)
- "Automatic Parallelization: An Example of a Language/Compiler Combination" (Allen & Kennedy)
- OpenMP规范
- LLVM实现参考: `llvm/lib/Transforms/Scalar/LoopVectorize.cpp`

**扩展方向**:
- GPU并行化（CUDA、OpenCL）
- 分布式并行化
- 异步任务并行

---

#### TASK-R10: 高级垃圾回收算法

**难度**: ⭐⭐⭐⭐⭐ | **预计工作量**: 120-180小时 | **适合阶段**: 硕士三年级/博士

**任务描述**:
实现增量垃圾回收器（Incremental GC）和并行垃圾回收器（Parallel GC），优化GC暂停时间和吞吐量。

**理论背景**:
垃圾回收器分类:
1. **标记-清除**: 简单但可能碎片化
2. **复制收集**: 无碎片但空间效率低
3. **标记-整理**: 兼顾碎片化和空间效率

**增量GC**:
- 分摊GC工作到用户代码执行期间
- 减少单次GC暂停时间

**并行GC**:
- 使用多线程并行执行GC工作
- 提高GC吞吐量

**实现步骤**:
1. 实现增量标记算法（写屏障）
2. 实现并行标记算法
3. 实现增量清除
4. 性能测试和调优
5. 论文撰写

**验收标准**:
- **正确性**:
  - [ ] 正确回收所有不可达对象
  - [ ] 无内存泄漏
  - [ ] 无悬垂指针
  - [ ] 通过15+个测试用例验证
- **性能**:
  - [ ] GC暂停时间≤10ms
  - [ ] 吞吐量提升≥2x
  - [ ] CPU利用率≥80%
- **创新性**:
  - [ ] 提出新的优化技术
  - [ ] 发表会议或期刊论文

**学习资源**:
- "The Garbage Collection Handbook" (Jones & Lins)
- "A Generational Mostly-Concurrent Garbage Collector" (Detlefs et al., 2004)
- JVM GC实现（G1、ZGC、Shenandoah）

**扩展方向**:
- 区域化GC
- 实时GC
- 无锁GC

---

## 4. 学术资源与工具链

### 4.1 经典论文参考

#### 数据流分析
- "A Unified Approach to Global Program Optimization" (Kildall, 1973)
- "Constant Propagation with Conditional Branches" (Wegman & Zadeck, 1991)
- "Efficiently Computing Static Single Assignment Form" (Cytron et al., 1991)

#### 寄存器分配
- "Register Allocation via Coloring of Chordal Graphs" (Hack et al., 2006)
- "Linear Scan Register Allocation" (Poletto & Sarkar, 1999)
- "Register Allocation for Programs in SSA Form" (Briggs et al., 1998)

#### 指令选择
- "Engineering a Simple, Efficient Code-Generator Generator" (Fraser et al., 1993)
- "Linear Scan Instruction Selection" (Aho et al., 2007)

#### 垃圾回收
- "A Generational Mostly-Concurrent Garbage Collector" (Detlefs et al., 2004)
- "The Garbage Collection Handbook" (Jones & Lins, 2011)

### 4.2 开源实现参考

- **LLVM**：工业级编译器，包含完整的优化流水线
  - 关键代码：`lib/Transforms/Scalar/`目录下的各种优化Pass
  - 寄存器分配：`lib/CodeGen/RegAllocGreedy.cpp`
- **GCC**：经典编译器框架
  - 数据流分析：`gcc/tree-ssa-dom.c`（常量传播）
  - 寄存器分配：`gcc/regalloc.c`
- **V8 JavaScript引擎**：现代优化编译器
  - TurboFan优化流水线：`src/compiler/`目录

### 4.3 调试与可视化工具

- **Graphviz**：用于可视化CFG和干涉图
  ```bash
  # 在BasicBlock中添加toDot()方法生成dot格式
  dot -Tpng cfg.dot -o cfg.png
  ```

- **LLVM可视化工具**：
  ```bash
  opt -dot-cfg input.ll    # 生成CFG
  opt -dot-dom input.ll    # 生成支配树
  ```

- **性能分析**：
  ```bash
  # Linux perf工具
  perf stat ./compiled_program
  perf record -g ./compiled_program
  perf report
  ```

### 4.4 推荐学习路径

1. **第1-2周**：精读SSA相关论文，理解现有SSA实现
2. **第3-4周**：实现常量传播分析（作为热身）
3. **第5-8周**：挑战寄存器分配或指令选择
4. **第9-10周**：性能调优和论文撰写
5. **持续**：每周阅读1-2篇相关论文，做文献综述

### 4.5 代码质量标准

- **Java编码规范**：遵循Google Java Style Guide
- **测试覆盖率**：核心代码行覆盖率不低于80%
- **文档要求**：所有public类和方法必须有Javadoc注释
- **Git提交规范**：使用清晰的分支策略（feature/xxx）

---

## 5. 验证和测试标准

### 5.1 正确性验证

- 通过所有现有单元测试，确保优化不破坏程序语义
- 对10个以上的测试程序（包含递归、循环、多重嵌套）进行验证
- 与未优化的寄存器分配（栈分配）结果进行比对，验证执行结果一致

### 5.2 性能验证

- 在标准测试集（如Stanford Benchmark）上测量执行时间
- 与栈分配版本相比，整体性能提升至少15%
- 内存访问指令数量减少至少20%

### 5.3 代码质量指标

- 生成的汇编代码中spill指令占比不超过15%
- 寄存器利用率（指令中使用寄存器的平均数）提升30%
- 测试覆盖率：核心代码行覆盖率不低于80%

### 5.4 测试用例设计示例

```c
// 测试1：简单变量使用
int a = 1;
int b = 2;
int c = a + b;

// 测试2：复杂表达式
int result = (a * b + c) / (d - e);

// 测试3：循环中的寄存器分配
for (int i = 0; i < 100; i++) {
    sum += arr[i];
}

// 测试4：函数调用
int x = foo(a, b);
int y = bar(x, c);
```

---

## 6. 快速开始指南

### 6.1 搭建开发环境

```bash
# 克隆项目
git clone https://github.com/your-repo/ep21.git
cd ep21

# 构建项目（确保Java 21已安装）
mvn clean compile

# 运行测试验证环境
mvn test -Dtest=LivenessAnalyzerTest

# 查看现有代码结构
find src/main/java/ep21 -name "*.java" | head -20
```

### 6.2 选择第一个任务

推荐从**到达定义分析**开始：
```bash
# 定位到活跃变量分析代码作为参考
cat src/main/java/ep21/analysis/LivenessAnalyzer.java

# 创建新模块文件
touch src/main/java/ep21/analysis/ReachingDefinitionAnalysis.java
```

### 6.3 实现模板

参考活跃变量分析的实现模式，创建数据流分析框架。

### 6.4 集成到现有系统

在`OptimizationManager.java`中注册新模块：
```java
// 添加以下代码
optimizationPasses.add(new ReachingDefinitionAnalysis());
```

---

## 7. 附录：任务选择指南

### 7.1 根据研究兴趣选择

| 研究兴趣 | 推荐任务 | 论文方向 |
|---------|----------|----------|
| 程序分析 | 数据流分析、指针分析 | 静态分析理论 |
| 编译器优化 | 寄存器分配、指令选择 | 优化算法设计 |
| 并行计算 | 自动并行化 | 并行编程模型 |
| 运行时系统 | 垃圾回收、JIT编译 | 系统软件设计 |

### 7.2 根据职业规划选择

| 职业方向 | 推荐任务 | 技能提升 |
|---------|----------|----------|
| 编译器工程师 | 寄存器分配、指令选择 | 工业级编译器开发 |
| 系统架构师 | 运行时系统、垃圾回收 | 系统设计和优化 |
| 研究员 | 数据流分析、自动并行化 | 理论研究和创新 |

---

**最后更新**: 2026-01-07
**维护者**: Claude Code
**状态**: 📝 研究生进阶任务文档创建完成
