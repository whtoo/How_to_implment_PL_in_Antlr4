# EP18R ABI设计文档（仿照RISC-V）

**文档版本**: v1.0
**创建日期**: 2025-12-17
**最后更新**: 2025-12-17
**制定者**: Claude Code
**基于**: RISC-V Calling Convention, EP18R核心设计文档

---

## 1. 概述

本文档定义EP18R寄存器虚拟机的应用程序二进制接口（Application Binary Interface, ABI），仿照RISC-V风格制定完整的调用约定和运行时环境规范。ABI是编译器生成的代码与虚拟机运行时系统之间的契约，确保不同模块间的二进制兼容性。

### 1.1 设计目标
- **兼容性**: 与现有EP18R代码保持向后兼容
- **清晰性**: 明确每个寄存器的用途和保存责任
- **可调试性**: 提供标准化的栈帧布局，便于调试工具分析
- **可扩展性**: 支持未来功能扩展（如浮点运算、向量指令）

### 1.2 适用范围
- 函数调用和返回机制
- 参数传递和返回值约定
- 栈帧布局和栈指针管理
- 寄存器保存和恢复责任
- 异常处理和系统调用

---

## 2. 寄存器约定

EP18R提供16个32位通用寄存器（r0-r15），每个寄存器都有特定的ABI名称和用途。

### 2.1 寄存器ABI名称和用途

| 寄存器 | ABI名称 | 保存者 | 描述 |
|--------|---------|--------|------|
| r0 | zero | - | 硬连线为零，写入无效 |
| r1 | ra | 调用者 | 返回地址（兼容性用途）/临时值 |
| r2 | a0 | 调用者 | 函数参数1/返回值 |
| r3 | a1 | 调用者 | 函数参数2/临时值 |
| r4 | a2 | 调用者 | 函数参数3/临时值 |
| r5 | a3 | 调用者 | 函数参数4/临时值 |
| r6 | a4 | 调用者 | 函数参数5/临时值 |
| r7 | a5 | 调用者 | 函数参数6/临时值 |
| r8 | s0 | 被调用者 | 保存寄存器1 |
| r9 | s1 | 被调用者 | 保存寄存器2 |
| r10 | s2 | 被调用者 | 保存寄存器3 |
| r11 | s3 | 被调用者 | 保存寄存器4 |
| r12 | s4 | 被调用者 | 保存寄存器5 |
| r13 | sp | 被调用者 | 栈指针（Stack Pointer） |
| r14 | fp | 被调用者 | 帧指针（Frame Pointer） |
| r15 | lr | 调用者 | 链接寄存器（Link Register） |

### 2.2 寄存器保存责任

#### 调用者保存寄存器（Caller-saved / 临时寄存器）
- **寄存器**: ra (r1), a0-a5 (r2-r7), lr (r15)
- **责任**: 调用者在调用前保存这些寄存器的值（如果需要）
- **特点**: 被调用者可以自由使用，无需保存/恢复
- **用途**: 传递参数、存储临时计算结果、存储不需要跨调用保存的值

#### 被调用者保存寄存器（Callee-saved / 保存寄存器）
- **寄存器**: s0-s4 (r8-r12), sp (r13), fp (r14)
- **责任**: 被调用者如果使用这些寄存器，必须在函数入口保存，在函数出口恢复
- **特点**: 值在函数调用间保持不变
- **用途**: 存储需要在函数调用间保持的局部变量、栈和帧指针

#### 特殊寄存器
- **zero (r0)**: 始终为0，写入操作被忽略
- **sp (r13)**: 栈指针，指向当前栈顶（低地址方向）
- **fp (r14)**: 帧指针，指向当前栈帧的基址
- **lr (r15)**: 链接寄存器，存储返回地址（与调用栈并存）

---

## 3. 函数调用约定

### 3.1 参数传递规则

#### 整数参数传递
| 参数位置 | 传递方式 | 寄存器 | 栈偏移（当寄存器不足时） |
|----------|----------|--------|--------------------------|
| 第1个参数 | 寄存器 | a0 (r2) | - |
| 第2个参数 | 寄存器 | a1 (r3) | - |
| 第3个参数 | 寄存器 | a2 (r4) | - |
| 第4个参数 | 寄存器 | a3 (r5) | - |
| 第5个参数 | 寄存器 | a4 (r6) | - |
| 第6个参数 | 寄存器 | a5 (r7) | - |
| 第7+个参数 | 栈 | - | fp + 16 + 4*(n-7) |

#### 参数传递流程
1. **调用者准备参数**:
   - 前6个整数参数放入寄存器 a0-a5 (r2-r7)
   - 剩余参数从右向左压入栈中
   - 栈传递的参数紧接在返回地址之后

2. **被调用者访问参数**:
   - 前6个参数从寄存器 a0-a5 读取
   - 额外参数从栈中读取：`[fp + 16 + 4*(param_index-7)]`

### 3.2 返回值约定

#### 整数返回值
- **单个返回值**: 通过 a0 (r2) 寄存器返回
- **多个返回值**: 不支持（可通过结构体或指针实现）

#### 返回值流程
1. **被调用者设置返回值**: 将返回值存入 a0 (r2) 寄存器
2. **调用者获取返回值**: 从 a0 (r2) 寄存器读取返回值

### 3.3 函数调用/返回指令

#### CALL指令语义
```assembly
call target_address
```
**操作**:
1. 将返回地址（PC+4）保存到:
   - 调用栈: `callStack[++framePointer] = PC+4`
   - 链接寄存器: `lr (r15) = PC+4`（兼容性）
2. 保存调用者保存寄存器到当前栈帧的`savedCallerRegisters`数组
3. 跳转到目标地址: `PC = target_address`

#### RET指令语义
```assembly
ret
```
**操作**:
1. 从调用栈弹出返回地址: `returnAddr = callStack[framePointer--]`
2. 恢复调用者保存寄存器从栈帧的`savedCallerRegisters`数组
3. 跳转回返回地址: `PC = returnAddr`

---

## 4. 栈帧布局

### 4.1 栈帧结构（向下增长）

```
高地址
+-------------------+ ← 调用者栈帧结束
|   调用者保存区域   |   （可选，由调用者管理）
+-------------------+
|   参数7+          |   fp + 16 + 4*(n-7)
|   ...             |
|   参数8           |   fp + 20
|   参数7           |   fp + 16
+-------------------+
|   返回地址         |   fp + 12  (存储在调用栈中)
+-------------------+
|   旧帧指针(fp)     |   fp + 8   (fp旧值)
+-------------------+
|   保存寄存器s4     |   fp + 4   (r12)
|   保存寄存器s3     |   fp + 0   (r11)
|   保存寄存器s2     |   fp - 4   (r10)
|   保存寄存器s1     |   fp - 8   (r9)
|   保存寄存器s0     |   fp - 12  (r8)
+-------------------+
|   局部变量n       |   fp - 16 - 4*(n-1)
|   ...             |
|   局部变量2       |   fp - 20
|   局部变量1       |   fp - 16
+-------------------+
|   临时空间         |   （用于表达式求值等）
+-------------------+
低地址               ← sp (栈指针)
```

### 4.2 栈帧大小计算

```
栈帧大小 = 保存寄存器区 + 局部变量区 + 临时空间 + 对齐填充

其中：
- 保存寄存器区: 5 * 4 = 20字节（s0-s4）
- 局部变量区: num_locals * 4字节
- 临时空间: 根据需要动态计算
- 对齐填充: 确保栈帧大小是8字节的倍数
```

### 4.3 栈指针和帧指针管理

#### 函数序言（Prologue）
```assembly
# 函数入口代码
    addi sp, sp, -frame_size    # 分配栈帧
    sw fp, 8(sp)                # 保存旧帧指针
    addi fp, sp, frame_size - 4 # 设置新帧指针
    sw s0, -12(fp)              # 保存s0
    sw s1, -8(fp)               # 保存s1
    sw s2, -4(fp)               # 保存s2
    # ... 保存其他被调用者保存寄存器
```

#### 函数尾声（Epilogue）
```assembly
# 函数出口代码
    lw s2, -4(fp)               # 恢复s2
    lw s1, -8(fp)               # 恢复s1
    lw s0, -12(fp)              # 恢复s0
    # ... 恢复其他被调用者保存寄存器
    lw fp, 8(sp)                # 恢复旧帧指针
    addi sp, sp, frame_size     # 释放栈帧
    ret                         # 返回
```

### 4.4 栈对齐要求

- **栈指针对齐**: sp 必须保持8字节对齐（最低3位为0）
- **栈帧对齐**: 每个栈帧大小必须是8字节的倍数
- **对齐目的**: 确保内存访问性能和兼容性

---

## 5. 汇编语言接口

### 5.1 函数定义语法

```assembly
.def function_name: args=N, locals=M
    # 函数序言（由汇编器自动生成）
    # 函数体
    # 函数尾声（由汇编器自动生成）
```

**参数**:
- `args=N`: 函数参数数量（包括通过寄存器和栈传递的）
- `locals=M`: 局部变量数量（不包括保存寄存器区）

### 5.2 函数调用示例

#### 调用者代码
```assembly
# 准备参数
li a0, 10          # 第一个参数
li a1, 20          # 第二个参数
li a2, 30          # 第三个参数
# 第4-6个参数类似...
# 第7+个参数通过栈传递（如果需要）

# 调用函数
call my_function

# 使用返回值（在a0中）
mov t0, a0         # t0是临时寄存器
```

#### 被调用者代码
```assembly
.def my_function: args=3, locals=2
    # 自动生成的序言
    # 访问参数
    # a0, a1, a2包含前3个参数

    # 使用局部变量（偏移量相对于fp）
    li t0, 42
    sw t0, -16(fp)  # 局部变量1
    sw t0, -20(fp)  # 局部变量2

    # 设置返回值
    li a0, 99

    # 自动生成的尾声
```

---

## 6. 异常和中断处理

### 6.1 异常处理约定

#### 异常寄存器上下文
当异常发生时，处理器自动保存以下上下文：
- **异常PC**: 发生异常的指令地址
- **异常原因**: 异常类型编码
- **寄存器快照**: 所有寄存器的值（可选）

#### 异常栈帧
异常处理使用独立的异常栈帧，与普通栈帧分离：
```
+-------------------+
|   异常信息         |   （类型、地址等）
+-------------------+
|   完整寄存器上下文 |   （所有寄存器值）
+-------------------+
|   异常返回地址     |
+-------------------+
```

### 6.2 系统调用约定

#### 系统调用接口
- **系统调用号**: 通过 a0 (r2) 寄存器传递
- **参数**: a1-a5 (r3-r7) 寄存器传递最多5个参数
- **返回值**: a0 (r2) 寄存器返回结果
- **错误码**: 负数表示错误，具体错误码在 a1 (r3) 中

#### 系统调用示例
```assembly
# 调用系统调用（假设系统调用号10是"write"）
li a0, 10          # 系统调用号: write
li a1, 1           # 文件描述符: stdout
la a2, message     # 缓冲区地址
li a3, 13          # 长度
syscall            # 触发系统调用（特殊指令）
```

---

## 7. 数据表示和对齐

### 7.1 基本数据类型

| 数据类型 | 大小（字节） | 对齐要求 | 寄存器表示 |
|----------|--------------|----------|------------|
| char     | 1            | 1        | 零扩展至32位 |
| short    | 2            | 2        | 零扩展至32位 |
| int      | 4            | 4        | 直接使用    |
| float    | 4            | 4        | IEEE 754   |
| pointer  | 4            | 4        | 直接使用    |

### 7.2 结构体和数组对齐

#### 结构体对齐规则
1. **整体对齐**: 结构体大小必须是其最大成员对齐要求的倍数
2. **成员对齐**: 每个成员必须放置在其对齐要求的倍数地址上
3. **填充字节**: 编译器在成员间插入填充字节以满足对齐要求

#### 示例
```c
struct Example {
    char c;      // 偏移0，大小1
    // 填充3字节
    int i;       // 偏移4，大小4
    short s;     // 偏移8，大小2
    // 填充2字节（使总大小为4的倍数）
};               // 总大小: 12字节
```

### 7.3 堆分配对象对齐
- **基本对齐**: 所有堆分配对象至少8字节对齐
- **缓存友好**: 大型数组建议按缓存行大小（32/64字节）对齐
- **SIMD对齐**: 向量数据建议按16字节对齐

---

## 8. 与现有实现的兼容性

### 8.1 向后兼容性保证

EP18R ABI设计保持与以下现有特性的兼容性：

#### 调用栈兼容性
- **现有特性**: 使用`callStack`数组和`framePointer`管理调用
- **ABI扩展**: 在现有基础上添加栈帧布局标准化
- **兼容性**: 现有代码继续工作，新代码获得更好的调试支持

#### 寄存器保存兼容性
- **现有特性**: CALL指令保存r2-r7到`savedCallerRegisters`
- **ABI确认**: 正式确认r2-r7为调用者保存寄存器
- **扩展**: 添加被调用者保存寄存器s0-s4的支持

#### 链接寄存器兼容性
- **现有特性**: 同时维护lr (r15)和调用栈
- **ABI规定**: lr作为调用者保存寄存器，主要用于兼容性代码

### 8.2 迁移路径

#### 阶段1：ABI文档和工具支持
1. 编写本ABI文档
2. 创建栈帧布局辅助工具
3. 更新汇编器支持自动序言/尾声生成

#### 阶段2：逐步采用
1. 新编写的函数遵循ABI规范
2. 现有函数在修改时迁移到ABI规范
3. 测试工具验证ABI一致性

#### 阶段3：全面采用
1. 所有系统库函数遵循ABI
2. 编译器默认生成ABI兼容代码
3. 调试工具依赖ABI栈帧信息

---

## 9. 实现工具和支持

### 9.1 栈帧布局工具

#### 栈帧计算器
```java
public class StackFrameCalculator {
    /**
     * 计算栈帧布局信息
     * @param numArgs 参数数量
     * @param numLocals 局部变量数量
     * @param usesSavedRegs 使用的被调用者保存寄存器掩码
     * @return 栈帧布局信息
     */
    public static StackFrameLayout calculate(
        int numArgs,
        int numLocals,
        int usesSavedRegs
    ) {
        // 实现栈帧偏移计算
    }
}
```

#### 偏移量定义
```java
public class StackOffsets {
    // 标准偏移量（相对于fp）
    public static final int FP_SAVE_OFFSET = 8;      // 旧fp保存位置
    public static final int S0_SAVE_OFFSET = -12;    // s0保存位置
    public static final int S1_SAVE_OFFSET = -8;     // s1保存位置
    public static final int S2_SAVE_OFFSET = -4;     // s2保存位置
    public static final int LOCAL_VAR0_OFFSET = -16; // 第一个局部变量

    // 计算局部变量偏移
    public static int localVarOffset(int index) {
        return LOCAL_VAR0_OFFSET - 4 * index;
    }

    // 计算参数偏移（用于第7+个参数）
    public static int argOffset(int argIndex) {
        return 16 + 4 * (argIndex - 7);
    }
}
```

### 9.2 汇编器ABI支持

#### 自动序言生成
汇编器在遇到函数定义时自动生成标准序言：
```assembly
.def my_func: args=2, locals=3
    # 自动生成的序言
    addi sp, sp, -36   # 栈帧大小计算（5保存寄存器 + 3局部变量 + 对齐）
    sw fp, 8(sp)       # 保存旧fp
    addi fp, sp, 32    # 设置新fp
    sw s0, -12(fp)     # 保存s0（如果函数使用）
    sw s1, -8(fp)      # 保存s1（如果函数使用）
    sw s2, -4(fp)      # 保存s2（如果函数使用）
    # ... 函数体
```

#### 自动尾声生成
汇编器在遇到`ret`指令时自动生成标准尾声：
```assembly
    # 自动生成的尾声（在ret之前）
    lw s2, -4(fp)      # 恢复s2
    lw s1, -8(fp)      # 恢复s1
    lw s0, -12(fp)     # 恢复s0
    lw fp, 8(sp)       # 恢复旧fp
    addi sp, sp, 36    # 释放栈帧
    ret                # 实际返回
```

### 9.3 调试信息格式

#### 栈帧调试信息
```java
public class StackFrameDebugInfo {
    private final String functionName;
    private final int frameSize;
    private final Map<String, Integer> localVarOffsets; // 变量名->fp偏移
    private final Map<String, Integer> paramOffsets;    // 参数名->fp偏移或寄存器

    // 生成人类可读的栈帧描述
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Function: ").append(functionName).append("\n");
        sb.append("Frame size: ").append(frameSize).append(" bytes\n");
        sb.append("Local variables:\n");
        for (Map.Entry<String, Integer> entry : localVarOffsets.entrySet()) {
            sb.append("  ").append(entry.getKey()).append(": fp")
              .append(entry.getValue() >= 0 ? "+" : "")
              .append(entry.getValue()).append("\n");
        }
        return sb.toString();
    }
}
```

---

## 10. 测试和验证

### 10.1 ABI一致性测试

#### 测试套件目标
1. **寄存器保存测试**: 验证调用者/被调用者保存责任
2. **栈帧布局测试**: 验证栈帧偏移计算正确性
3. **参数传递测试**: 验证寄存器/栈参数传递
4. **返回值测试**: 验证返回值约定
5. **对齐测试**: 验证栈和数据对齐要求

#### 测试示例：寄存器保存
```java
@Test
void testCalleeSavedRegisters() {
    // 测试被调用者保存寄存器s0-s4在函数调用后保持不变
    String program = """
        .def caller: args=0, locals=0
            li s0, 100
            li s1, 200
            li s2, 300
            call callee
            # 验证s0-s4保持不变
            seq a0, s0, 100
            seq a1, s1, 200
            seq a2, s2, 300
            halt

        .def callee: args=0, locals=2
            # 被调用者使用s0-s4时必须保存
            sw s0, -12(fp)  # 保存s0
            sw s1, -8(fp)   # 保存s1
            sw s2, -4(fp)   # 保存s2

            # 修改s0-s4的值
            li s0, 999
            li s1, 888
            li s2, 777

            # 恢复s0-s4
            lw s2, -4(fp)
            lw s1, -8(fp)
            lw s0, -12(fp)
            ret
        """;

    loadAndExecute(program);
    assertThat(interpreter.getRegister(2)).isEqualTo(1); // a0 = 1 (s0不变)
    assertThat(interpreter.getRegister(3)).isEqualTo(1); // a1 = 1 (s1不变)
    assertThat(interpreter.getRegister(4)).isEqualTo(1); // a2 = 1 (s2不变)
}
```

### 10.2 性能基准测试

#### 测试指标
1. **函数调用开销**: 测量标准序言/尾声的开销
2. **参数传递效率**: 比较寄存器vs栈参数传递
3. **栈帧访问速度**: 测量fp相对寻址的性能
4. **内存使用**: 测量不同栈帧布局的内存效率

#### 基准测试工具
```java
public class ABIBenchmark {
    // 测量函数调用开销
    public long measureCallOverhead(int iterations) {
        long start = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            // 调用空函数
            callEmptyFunction();
        }
        long end = System.nanoTime();
        return (end - start) / iterations;
    }

    // 测量参数传递开销
    public long measureArgPassing(int numArgs, int iterations) {
        // 测试不同数量参数的传递开销
    }
}
```

---

## 附录A：ABI版本历史

| 版本 | 日期 | 主要变更 | 兼容性 |
|------|------|----------|--------|
| v1.0 | 2025-12-17 | 初始版本，基于RISC-V风格设计 | 与EP18R现有代码兼容 |

## 附录B：参考文档

1. **RISC-V Calling Convention**: https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf
2. **EP18R核心设计文档**: EP18R_核心设计文档.md
3. **EP18R寄存器指令集规范**: RegisterBytecodeDefinition.java
4. **System V ABI**: https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf

## 附录C：快速参考表

### 寄存器使用快速参考
```
参数寄存器: a0-a5 (r2-r7)     调用者保存
保存寄存器: s0-s4 (r8-r12)    被调用者保存
特殊寄存器: sp (r13), fp (r14), lr (r15)
零寄存器: zero (r0)           只读，始终为0
```

### 栈帧偏移快速参考
```
fp+16+4n:       第(7+n)个参数（n≥0）
fp+12:          返回地址（调用栈中）
fp+8:           旧fp保存位置
fp+0:           s2保存位置
fp-4:           s2保存位置
fp-8:           s1保存位置
fp-12:          s0保存位置
fp-16:          局部变量0
fp-20:          局部变量1
...
```

### 常用指令序列
```assembly
# 函数序言模板
addi sp, sp, -framesize
sw fp, 8(sp)
addi fp, sp, framesize-4
# 保存使用的s0-s4寄存器

# 函数尾声模板
# 恢复使用的s0-s4寄存器
lw fp, 8(sp)
addi sp, sp, framesize
ret

# 调用函数
# 准备参数到a0-a5（和栈）
call function

# 返回函数
# 返回值在a0中
ret
```

---

## 附录D：当前实现与ABI规范的差异

本文档定义的是EP18R寄存虚拟机的目标ABI规范。当前实现与目标规范存在一些差异，这些差异将在未来的版本中逐步消除。

### D.1 返回值寄存器差异

| 项目 | 目标ABI规范 | 当前实现 | 说明 |
|------|-------------|----------|------|
| 返回值寄存器 | a0 (r2) | r1 | 当前实现使用r1作为返回值寄存器以保持向后兼容性 |
| 返回值寄存器ABI名称 | a0 | ra | 对应的ABI名称不同 |
| 工具类支持 | `CallingConventionUtils.getReturnValueRegister()` 应返回2 | 实际返回1 | 工具类反映当前实现 |

### D.2 栈帧布局差异

| 项目 | 目标ABI规范 | 当前实现 | 说明 |
|------|-------------|----------|------|
| 栈帧结构 | 标准栈帧布局（第4.1节） | 简化栈帧（`StackFrame`类） | 当前实现使用简化的栈帧结构，仅包含必要字段 |
| 栈帧对齐 | 8字节对齐 | 未强制对齐 | 对齐要求尚未实现 |
| 帧指针(fp) | r14作为帧指针 | 未完全实现 | 帧指针支持正在开发中 |

### D.3 寄存器保存差异

| 项目 | 目标ABI规范 | 当前实现 | 说明 |
|------|-------------|----------|------|
| 调用者保存寄存器 | ra (r1), a0-a5 (r2-r7), lr (r15) | r2-r7 | CALL指令自动保存r2-r7，r1和r15有特殊用途 |
| 被调用者保存寄存器 | s0-s4 (r8-r12), sp (r13), fp (r14) | 部分支持 | 完整的被调用者保存寄存器支持正在开发中 |

### D.4 内存访问差异

| 项目 | 目标ABI规范 | 当前实现 | 说明 |
|------|-------------|----------|------|
| 内存地址计算 | 字节寻址 | 字寻址（int数组） | 堆内存使用int数组，字节偏移需要除以4 |
| 结构体字段访问 | 字节偏移 | 字索引转换 | `LW_F`/`SW_F`指令将字节偏移转换为字索引 |

### D.5 兼容性说明

当前实现保持与现有EP18R代码的完全兼容性。新代码应尽可能遵循目标ABI规范，但需要注意上述差异。

**迁移建议**：
1. 返回值处理：使用r1作为返回值寄存器（当前实现）
2. 参数传递：使用a0-a5 (r2-r7)传递参数（与规范一致）
3. 寄存器保存：CALL指令自动保存r2-r7，调用者无需手动保存
4. 栈帧访问：使用简化的栈帧模型，通过SP (r13)访问局部变量

**未来兼容性**：
随着ABI规范的逐步实现，这些差异将逐步消除。代码应做好迁移准备，特别是：
- 避免硬编码寄存器编号，使用ABI名称
- 使用`CallingConventionUtils`工具类进行寄存器操作
- 遵循第8.2节的迁移路径

---

**文档状态**: 正式发布（目标规范）
**当前实现状态**: 与目标规范存在差异，正在逐步迁移
**下一步**:
1. 实现栈帧布局辅助工具（第9.1节）
2. 更新汇编器支持自动序言/尾声生成（第9.2节）
3. 编写ABI一致性测试套件（第10节）
4. 基于ABI修复递归函数调用测试失败问题
5. 逐步消除当前实现与ABI规范的差异