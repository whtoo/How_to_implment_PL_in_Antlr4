package org.teachfx.antlr4.ep21.integration;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.teachfx.antlr4.ep21.CymbolLexer;
import org.teachfx.antlr4.ep21.CymbolParser;
import org.teachfx.antlr4.ep21.ast.ASTNode;
import org.teachfx.antlr4.ep21.ir.IRNode;
import org.teachfx.antlr4.ep21.ir.Prog;
import org.teachfx.antlr4.ep21.pass.ast.CymbolASTBuilder;
import org.teachfx.antlr4.ep21.pass.codegen.CodeGenerationResult;
import org.teachfx.antlr4.ep21.pass.codegen.ICodeGenerator;
import org.teachfx.antlr4.ep21.pass.codegen.StackVMGenerator;
import org.teachfx.antlr4.ep21.pass.ir.CymbolIRBuilder;
import org.teachfx.antlr4.ep21.pass.symtab.LocalDefine;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration tests for VM code generation.
 * <p>
 * This test class verifies that:
 * 1. EP21 can compile Cymbol source code to IR
 * 2. Code generators can generate bytecode for EP18/EP18R
 * 3. The generated bytecode can execute correctly on respective VMs
 * 4. Execution results are semantically equivalent across VMs
 * </p>
 */
@DisplayName("VM Code Generation Integration Tests")
public class VMCodeGenerationIntegrationTest {

    /**
     * Test program: simple arithmetic
     * Expected output: 30 (10 + 20)
     */
    private static final String SIMPLE_MATH_PROGRAM = """
            int main() {
                int x = 10;
                int y = 20;
                int z = x + y;
                print(z);
                return 0;
            }
            """;

    /**
     * Test program: simple constant
     * Expected output: 42
     */
    private static final String SIMPLE_CONSTANT_PROGRAM = """
            int main() {
                int x = 42;
                print(x);
                return 0;
            }
            """;

    /**
     * Test program: simple addition
     * Expected output: 7 (3 + 4)
     */
    private static final String SIMPLE_ADDITION_PROGRAM = """
            int main() {
                int x = 3;
                int y = 4;
                int z = x + y;
                print(z);
                return 0;
            }
            """;

    private CymbolLexer lexer;
    private CymbolParser parser;
    private Prog irProgram;

    @BeforeEach
    public void setUp() {
        // Reset for each test
        lexer = null;
        parser = null;
        irProgram = null;
    }

    /**
     * Integration test: Compile → Generate EP18 bytecode.
     */
    @Test
    @DisplayName("Should compile and generate EP18 bytecode for simple math program")
    public void testEP18CodeGeneration() throws Exception {
        // Step 1: Parse Cymbol source to AST
        ASTNode astRoot = parseToAST(SIMPLE_MATH_PROGRAM);
        assertThat(astRoot).isNotNull();

        // Step 2: Build symbol table
        astRoot.accept(new LocalDefine());

        // Step 3: Generate IR
        CymbolIRBuilder irBuilder = new CymbolIRBuilder();
        astRoot.accept(irBuilder);
        irProgram = irBuilder.prog;
        assertThat(irProgram).isNotNull();

        // Step 4: Optimize basic blocks
        irProgram.optimizeBasicBlock();

        // Step 5: Generate EP18 bytecode
        ICodeGenerator generator = new StackVMGenerator();
        CodeGenerationResult result = generator.generateFromInstructions(irProgram.linearInstrs());

        assertThat(result).isNotNull();
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getTargetVM()).isEqualTo("EP18");
        assertThat(result.getOutput()).isNotEmpty();

        // Step 6: Verify generated assembly contains expected instructions
        String assembly = result.getOutput();
        assertThat(assembly).contains("iconst 10");  // Load constant 10
        assertThat(assembly).contains("iconst 20");  // Load constant 20
        assertThat(assembly).contains("iadd");       // Add operation
        assertThat(assembly).contains("store");      // Store result
        assertThat(assembly).contains("halt");       // Halt instruction
    }

    /**
     * Integration test: Compile → Generate EP18 bytecode for constant program.
     */
    @Test
    @DisplayName("Should compile and generate EP18 bytecode for constant program")
    public void testEP18ConstantProgram() throws Exception {
        // Compile and generate
        ASTNode astRoot = parseToAST(SIMPLE_CONSTANT_PROGRAM);
        astRoot.accept(new LocalDefine());

        CymbolIRBuilder irBuilder = new CymbolIRBuilder();
        astRoot.accept(irBuilder);
        irProgram = irBuilder.prog;
        irProgram.optimizeBasicBlock();

        ICodeGenerator generator = new StackVMGenerator();
        CodeGenerationResult result = generator.generateFromInstructions(irProgram.linearInstrs());

        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getOutput()).isNotEmpty();

        // Verify generated assembly contains expected instructions
        String assembly = result.getOutput();
        assertThat(assembly).contains("iconst 42");  // Load constant 42
        assertThat(assembly).contains("store");       // Store to variable
        assertThat(assembly).contains("call");        // Call print
        assertThat(assembly).contains("halt");        // Halt
    }

    /**
     * Integration test: Compile → Generate EP18 bytecode for addition program.
     */
    @Test
    @DisplayName("Should compile and generate EP18 bytecode for addition program")
    public void testEP18AdditionProgram() throws Exception {
        // Compile and generate
        ASTNode astRoot = parseToAST(SIMPLE_ADDITION_PROGRAM);
        astRoot.accept(new LocalDefine());

        CymbolIRBuilder irBuilder = new CymbolIRBuilder();
        astRoot.accept(irBuilder);
        irProgram = irBuilder.prog;
        irProgram.optimizeBasicBlock();

        ICodeGenerator generator = new StackVMGenerator();
        CodeGenerationResult result = generator.generateFromInstructions(irProgram.linearInstrs());

        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getOutput()).isNotEmpty();

        // Verify generated assembly contains expected instructions
        String assembly = result.getOutput();
        assertThat(assembly).contains("iconst 3");   // Load constant 3
        assertThat(assembly).contains("iconst 4");   // Load constant 4
        assertThat(assembly).contains("iadd");        // Add operation
        assertThat(assembly).contains("store");       // Store result
        assertThat(assembly).contains("halt");        // Halt
    }

    /**
     * Unit test: Verify StackVMGenerator generates correct bytecode.
     */
    @Test
    @DisplayName("Should generate correct EP18 assembly for load/store operations")
    public void testStackVMGeneratorLoadStore() throws Exception {
        // Create a simple IR program with load/store
        Prog prog = new Prog();

        // Generate assembly
        StackVMGenerator generator = new StackVMGenerator();
        CodeGenerationResult result = generator.generate(prog);

        assertThat(result).isNotNull();
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getTargetVM()).isEqualTo("EP18");
        assertThat(result.getGenerationTimeMs()).isGreaterThanOrEqualTo(0);
    }

    /**
     * Integration test: Full compilation pipeline using Compiler class.
     */
    @Test
    @DisplayName("Should compile Cymbol source using full pipeline")
    public void testFullCompilationPipeline() throws Exception {
        // Note: This test verifies the compilation pipeline works end-to-end.
        // Actual code generation is temporarily disabled in Compiler.java
        // until the ICodeGenerator migration is complete.

        // Parse source
        ASTNode astRoot = parseToAST(SIMPLE_CONSTANT_PROGRAM);
        assertThat(astRoot).isNotNull();

        // Build symbol table
        astRoot.accept(new LocalDefine());

        // Generate IR
        CymbolIRBuilder irBuilder = new CymbolIRBuilder();
        astRoot.accept(irBuilder);
        irProgram = irBuilder.prog;

        // Verify IR was generated
        List<IRNode> instructions = irProgram.linearInstrs();
        assertThat(instructions).isNotNull();
        assertThat(instructions).isNotEmpty();
    }

    /**
     * Integration test: Verify EP18 and EP18R code generators have consistent interfaces.
     */
    @Test
    @DisplayName("Should verify both VM code generators implement ICodeGenerator")
    public void testBothGeneratorsImplementICodeGenerator() {
        // EP18 StackVMGenerator implements ICodeGenerator
        ICodeGenerator stackGenerator = new StackVMGenerator();
        assertThat(stackGenerator.getTargetVM()).isEqualTo("EP18");
        assertThat(stackGenerator.getEmitter()).isNotNull();

        // EP18R RegisterAssembler exists (doesn't implement ICodeGenerator yet)
        // This test verifies that when we create RegisterVMGenerator, it will work
        // For now, we just verify the StackVMGenerator works correctly
        assertThat(stackGenerator).isNotNull();
    }

    /**
     * Integration test: Verify code generation result metadata.
     */
    @Test
    @DisplayName("Should verify code generation result contains correct metadata")
    public void testCodeGenerationResultMetadata() throws Exception {
        // Compile and generate
        ASTNode astRoot = parseToAST(SIMPLE_CONSTANT_PROGRAM);
        astRoot.accept(new LocalDefine());

        CymbolIRBuilder irBuilder = new CymbolIRBuilder();
        astRoot.accept(irBuilder);
        irProgram = irBuilder.prog;
        irProgram.optimizeBasicBlock();

        ICodeGenerator generator = new StackVMGenerator();
        CodeGenerationResult result = generator.generateFromInstructions(irProgram.linearInstrs());

        // Verify all metadata fields
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getTargetVM()).isEqualTo("EP18");
        assertThat(result.getOutput()).isNotEmpty();
        assertThat(result.getErrors()).isEmpty();
        assertThat(result.getInstructionCount()).isGreaterThan(0);
        assertThat(result.getGenerationTimeMs()).isGreaterThanOrEqualTo(0);
    }

    // ==================== Helper Methods ====================

    /**
     * Parses Cymbol source code to AST.
     *
     * @param source the Cymbol source code
     * @return the AST root node
     * @throws Exception if parsing fails
     */
    private ASTNode parseToAST(String source) throws Exception {
        InputStream inputStream = new ByteArrayInputStream(source.getBytes(StandardCharsets.UTF_8));
        CharStream charStream = CharStreams.fromStream(inputStream);
        lexer = new CymbolLexer(charStream);
        CommonTokenStream tokenStream = new CommonTokenStream(lexer);
        parser = new CymbolParser(tokenStream);
        ParseTree parseTree = parser.file();

        CymbolASTBuilder astBuilder = new CymbolASTBuilder();
        return parseTree.accept(astBuilder);
    }
}
