
# ep18r 寄存器虚拟机实现计划

### 项目概述
ep18r 是基于寄存器架构的虚拟机，与现有的栈式虚拟机（ep18）保持语义等价，但使用寄存器指令集和不同的内部执行模型。本计划描述ep18r的实现步骤和时间安排。

### 当前状态（2025年12月）
- ✅ 模块创建和基础结构完成
- ✅ 寄存器指令集设计完成（RegisterBytecodeDefinition）
- 🔄 寄存器虚拟机核心实现进行中（CymbolRegisterVM、RegisterVMInterpreter）
- 🔄 汇编器和反汇编器部分完成
- ⬜ 语义等价验证未开始
- ⬜ 优化和性能对比未开始

### 渐进式实现计划

#### 阶段 1：模块创建和基础结构（已完成）
1. 创建 ep18r 目录和 pom.xml（基于 ep18 的 pom.xml）
2. 复制 ep18 的代码结构作为起点
3. 修改模块配置：artifactId 为 ep18r，包路径为 org.teachfx.antlr4.ep18r
4. 更新根 pom.xml 的 modules 列表，在 ep18 后添加 ep18r
5. 构建验证：确保 mvn compile 通过

#### 阶段 2：寄存器指令集设计（已完成）
1. 分析现有 42 条栈指令，设计对应的寄存器版本
2. 定义寄存器指令编码格式（32 位指令，包含操作码和寄存器字段）
3. 创建 RegisterBytecodeDefinition.java
4. 设计寄存器文件（16 个通用寄存器）

#### 阶段 3：寄存器虚拟机核心实现（进行中）
1. 创建 CymbolRegisterVM 类，基于 CymbolStackVM 但改用寄存器架构
2. 实现寄存器文件（register file）和寄存器分配策略
3. 实现指令解码和执行循环，支持新的寄存器指令
4. 保持相同的堆内存管理、结构体支持和垃圾回收
5. 实现栈帧管理，但局部变量存储在寄存器中（可能需要寄存器溢出处理）

#### 阶段 4：汇编器和反汇编器（部分完成）
1. 扩展 VMAssembler.g4 语法，支持寄存器指令格式
2. 创建 RegisterByteCodeAssembler.java
3. 创建 RegisterDisAssembler.java
4. 确保向后兼容：仍能解析现有的栈式汇编代码（可选，或提供转换工具）

#### 阶段 5：语义等价验证（未开始）
1. 创建等价性测试框架
2. 对相同的源程序，比较栈式 VM 和寄存器 VM 的输出
3. 使用现有的 .vm 测试文件作为基准
4. 实现自动转换工具：栈式字节码 → 寄存器字节码（用于测试）

#### 阶段 6：优化和性能对比（未开始）
1. 实现寄存器分配优化（如线性扫描）
2. 添加性能统计和对比
3. 文档记录设计决策和性能特征

#### 阶段 7：集成和文档（未开始）
1. 更新项目文档，说明 ep18r 的存在和用途
2. 确保构建脚本支持 ep18r
3. 编写使用示例和教程

### 关键设计决策
1. **寄存器数量**：16 个通用寄存器（r0-r15），采用简单固定分配策略
2. **指令格式**：32位指令，R/I/J三种类型
3. **兼容性策略**：采用新的寄存器汇编格式，提供栈式字节码到寄存器字节码的转换工具

### 时间安排
- **第1-2周**：完成阶段3（寄存器虚拟机核心实现）
- **第3周**：完成阶段4（汇编器和反汇编器）
- **第4周**：完成阶段5（语义等价验证）
- **第5-6周**：完成阶段6-7（优化和文档）

### 成功标准
1. 所有现有测试通过（或适配后通过）
2. 语义等价性验证通过
3. 模块可独立构建和运行
4. 文档完整

### 风险评估
1. **复杂性**：寄存器分配和优化复杂 → 分阶段实现，先实现简单固定分配
2. **性能**：可能不如优化后的栈式 VM → 专注于语义等价，性能为次要目标
3. **测试**：确保完全等价困难 → 实现详细的对照测试框架

---

*本计划制定时间：2025年12月7日*
*预计完成时间：2026年6月*
*负责人：Claude Code*