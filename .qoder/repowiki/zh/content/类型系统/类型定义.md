# 类型定义

<cite>
**本文档中引用的文件**  
- [BuiltInTypeSymbol.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/BuiltInTypeSymbol.java)
- [TypeTable.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/TypeTable.java)
- [ArrayType.java](file://ep19/src/main/java/org/teachfx/antlr4/ep19/symtab/type/ArrayType.java)
- [StructType.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/symtab/type/StructType.java)
- [Type.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/Type.java)
</cite>

## 目录
1. [简介](#简介)
2. [内建类型与类型注册表](#内建类型与类型注册表)
3. [复合类型实现](#复合类型实现)
4. [类型符号表设计](#类型符号表设计)
5. [类型系统API使用示例](#类型系统api使用示例)
6. [类型分类与基本概念](#类型分类与基本概念)
7. [类型系统扩展机制](#类型系统扩展机制)
8. [结论](#结论)

## 简介
本文档详细阐述Cymbol语言类型系统的底层实现机制，涵盖内建类型、复合类型、类型注册表及类型唯一性保证等核心概念。通过分析关键类的设计与交互，为开发者提供从初学者到高级用户的完整理解路径。

## 内建类型与类型注册表

Cymbol语言中的内建类型由`BuiltInTypeSymbol`类表示，该类继承自`Symbol`并实现`Type`接口。所有内建类型实例均通过`TypeTable`类进行集中注册和管理。

`BuiltInTypeSymbol`类通过构造函数接收类型名称，并重写了`isPrimitive()`方法以标识其为原始类型。该设计确保了类型对象的不可变性和一致性。

`TypeTable`类作为类型注册表，以静态字段的形式预定义了所有内建类型，包括`int`、`float`、`bool`、`void`等。这些类型在类加载时即被初始化，保证了全局唯一性。此外，`TypeTable`还定义了`TRUE`和`FALSE`常量，用于布尔值的统一表示。

**Section sources**
- [BuiltInTypeSymbol.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/BuiltInTypeSymbol.java#L1-L14)
- [TypeTable.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/TypeTable.java#L1-L18)

## 复合类型实现

### 数组类型
`ArrayType`类实现了数组类型的表示，包含元素类型（`elementType`）和名称（`name`）。当构造数组类型时，会自动将其名称设置为`elementType.getName() + "[]"`。该类重写了`equals()`和`hashCode()`方法，确保相同元素类型的数组被视为同一类型。

数组类型被归类为非原始类型（`isPrimitive()`返回`false`），并通过`getElementType()`方法提供对元素类型的访问。这种设计支持多维数组的递归表示。

**Section sources**
- [ArrayType.java](file://ep19/src/main/java/org/teachfx/antlr4/ep19/symtab/type/ArrayType.java#L1-L56)

### 结构体类型
`StructType`类用于表示结构体类型，包含名称（`name`）和字段映射表（`fields`）。通过`addField()`和`getField()`方法实现结构体成员的动态管理。字段存储为`Symbol`对象，支持不同类型符号的统一处理。

`StructType`提供了`isEqual()`方法用于类型比较，仅当两个结构体具有相同名称时才视为相等。这简化了类型检查逻辑，避免了深层结构比较的开销。

**Section sources**
- [StructType.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/symtab/type/StructType.java#L1-L74)

## 类型符号表设计

类型符号表的核心设计原则是类型唯一性保证和高效查找。`TypeTable`通过静态常量的方式确保每个内建类型在整个程序中仅存在一个实例。这种设计避免了类型重复创建，减少了内存开销，并简化了类型比较操作。

类型系统通过继承`Symbol`基类实现统一的符号管理机制。所有类型均实现`Type`接口，提供标准化的类型查询方法，如`getName()`、`isPrimitive()`等。这种接口抽象使得类型系统具有良好的扩展性，支持未来新增类型种类。

类型查找机制主要依赖于编译器的符号解析过程。在解析阶段，类型名称被映射到对应的类型对象，解析结果缓存于作用域（`Scope`）中，确保后续引用的高效访问。

**Section sources**
- [TypeTable.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/TypeTable.java#L1-L18)
- [BuiltInTypeSymbol.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/BuiltInTypeSymbol.java#L1-L14)
- [Type.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/Type.java)

## 类型系统API使用示例

类型系统的使用主要涉及类型注册和类型查询两个方面。以下为典型使用场景：

1. **类型注册**：在编译器初始化阶段，`TypeTable`自动完成内建类型的注册。开发者无需手动操作。
2. **类型查询**：通过`TypeTable.INT`、`TypeTable.FLOAT`等静态字段直接获取内建类型引用。
3. **复合类型创建**：使用`new ArrayType(elementType)`创建数组类型，或`new StructType("name")`创建结构体类型。
4. **类型比较**：使用`equals()`方法进行类型等价性判断，或通过`getName()`进行名称匹配。

这些API设计简洁直观，既满足了编译器内部的需求，也为外部扩展提供了清晰的接口。

**Section sources**
- [TypeTable.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/TypeTable.java#L1-L18)
- [ArrayType.java](file://ep19/src/main/java/org/teachfx/antlr4/ep19/symtab/type/ArrayType.java#L1-L56)
- [StructType.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/symtab/type/StructType.java#L1-L74)

## 类型分类与基本概念

Cymbol语言的类型系统可分为两大类：原始类型和复合类型。

- **原始类型**：包括`int`、`float`、`bool`、`char`、`void`等，由`BuiltInTypeSymbol`表示，`isPrimitive()`返回`true`。
- **复合类型**：包括数组类型和结构体类型，由`ArrayType`和`StructType`表示，`isPrimitive()`返回`false`。

所有类型均实现`Type`接口，确保了类型操作的统一性。类型名称作为唯一标识符，用于类型声明、变量定义和类型检查等场景。

**Section sources**
- [BuiltInTypeSymbol.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/BuiltInTypeSymbol.java#L1-L14)
- [ArrayType.java](file://ep19/src/main/java/org/teachfx/antlr4/ep19/symtab/type/ArrayType.java#L1-L56)
- [StructType.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/symtab/type/StructType.java#L1-L74)

## 类型系统扩展机制

Cymbol类型系统支持通过继承`Type`接口和`Symbol`基类来实现自定义类型。扩展类型需实现`getName()`、`isPrimitive()`等核心方法，并根据需要重写`equals()`和`hashCode()`以保证类型唯一性。

对于复杂类型（如枚举、联合体），可参考`StructType`的设计模式，使用字段映射表管理内部成员。类型注册可通过在`TypeTable`中添加静态字段实现，或通过动态注册机制集成到符号解析流程中。

此扩展机制保持了类型系统的开放性，同时维护了核心设计的一致性。

**Section sources**
- [Type.java](file://ep16/src/main/java/org/teachfx/antlr4/ep16/symtab/Type.java)
- [StructType.java](file://ep20/src/main/java/org/teachfx/antlr4/ep20/symtab/type/StructType.java#L1-L74)

## 结论
Cymbol语言的类型系统通过`BuiltInTypeSymbol`、`TypeTable`、`ArrayType`和`StructType`等核心类实现了内建类型管理、复合类型表示和类型唯一性保证。该设计简洁高效，既满足了基本类型需求，又为未来扩展提供了坚实基础。通过静态注册和接口抽象，类型系统在保证性能的同时实现了良好的可维护性和可扩展性。