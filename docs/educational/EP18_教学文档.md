# EP18: æ ˆå¼è™šæ‹Ÿæœº - æ•™å­¦æ–‡æ¡£

**ç¼–è¯‘å™¨æ„é€ é˜¶æ®µ**: åç«¯æ‰§è¡Œ
**éš¾åº¦ç­‰çº§**: â­â­â­ ä¸­çº§
**é¢„è®¡å­¦æ—¶**: 8å°æ—¶
**å‰ç½®çŸ¥è¯†**: EP16ï¼ˆçº¿æ€§ä¸­é—´è¡¨ç¤ºLIRï¼‰

---

## ğŸ—ï¸ ç¬¬ä¸€å±‚ï¼šæ¶æ„å…¨æ™¯

### 1.1 EP18åœ¨ç¼–è¯‘ç®¡çº¿ä¸­çš„ä½ç½®

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®Œæ•´ç¼–è¯‘ç®¡çº¿                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  EP16: LIRç”Ÿæˆ  â”‚  EP18: æ ˆå¼VM    â”‚  EP19: ä»£ç ç”Ÿæˆ      â”‚
â”‚  (ASTâ†’å­—èŠ‚ç )    â”‚  (å­—èŠ‚ç â†’æ‰§è¡Œ)    â”‚  (å®Œæ•´ç¼–è¯‘å™¨)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     EP18çš„ä½ç½®                            â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  å­—èŠ‚ç æµ    â”‚   æ“ä½œæ•°æ ˆ + æ ˆå¸§ç®¡ç†    â”‚   æ‰§è¡Œç»“æœ       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚   (æŒ‡ä»¤åˆ†æ´¾+ABIè§„èŒƒ)    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’      â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®ç‰¹ç‚¹**:
- **å¹³å°æ— å…³**: å­—èŠ‚ç å¯åœ¨ä»»ä½•å¹³å°è¿è¡Œ
- **æ²™ç®±æ‰§è¡Œ**: é™åˆ¶å±é™©æ“ä½œï¼Œå®‰å…¨å¯æ§
- **æ ˆå¼æ¶æ„**: æ“ä½œæ•°æ ˆ + æ ˆå¸§çš„æ‰§è¡Œæ¨¡å‹
- **å¤šæ¨¡å¼èåˆ**: ç­–ç•¥ã€å·¥å‚ã€å‘½ä»¤ã€è§£é‡Šå™¨ã€çŠ¶æ€ã€é€‚é…å™¨æ¨¡å¼ååŒå·¥ä½œ

### 1.2 äº”å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 5: åº”ç”¨å±‚ (Application)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  VMInterpreter: CLIå…¥å£å’Œæ¼”ç¤º                   â”‚  â”‚
â”‚  â”‚  VMRunner: æ‰§è¡Œç¼–æ’å™¨                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 4: è¿è¡Œæ—¶æ•°æ®å±‚ (Runtime Data)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  StackFrame: å‡½æ•°è°ƒç”¨æ ˆå¸§                      â”‚  â”‚
â”‚  â”‚  FunctionSymbol: å‡½æ•°å…ƒæ•°æ®                     â”‚  â”‚
â”‚  â”‚  StructValue: ç»“æ„ä½“ç®¡ç†                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 3: æ‰§è¡Œå¼•æ“å±‚ (Execution Engine)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  CymbolStackVM: æ ¸å¿ƒæ‰§è¡Œå¼•æ“                    â”‚  â”‚
â”‚  â”‚  InstructionFactory: æŒ‡ä»¤å·¥å‚å’Œæ³¨å†Œè¡¨            â”‚  â”‚
â”‚  â”‚  VMExecutionContext: æ‰§è¡Œä¸Šä¸‹æ–‡å°è£…               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 2: å…·ä½“å®ç°å±‚ (Concrete Implementation)         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ç®—æœ¯æŒ‡ä»¤: IAddInstruction, ISubInstruction, ...  â”‚  â”‚
â”‚  â”‚  æ¯”è¾ƒæŒ‡ä»¤: ILtInstruction, IEqInstruction, ...   â”‚  â”‚
â”‚  â”‚  å†…å­˜æŒ‡ä»¤: ILoadInstruction, IStoreInstruction,..â”‚  â”‚
â”‚  â”‚  æ§åˆ¶æµæŒ‡ä»¤: CallInstruction, RetInstruction, ..â”‚  â”‚
â”‚  â”‚  GC: ReferenceCountingGC                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 1: æ¡†æ¶å±‚ (Framework)                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Instruction: æŒ‡ä»¤æ¥å£ (ç­–ç•¥æ¨¡å¼)               â”‚  â”‚
â”‚  â”‚  VMConfig: é…ç½®ç®¡ç†å™¨ (å»ºé€ æ¨¡å¼)                 â”‚  â”‚
â”‚  â”‚  ABIConvention: ABIè§„èŒƒ (æ¥å£è§„èŒƒ)              â”‚  â”‚
â”‚  â”‚  GarbageCollector: GCæ¥å£                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
```

### 1.3 æ„é€ é€»è¾‘

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              EP18çš„äº”é˜¶æ®µæ„é€ é€»è¾‘                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

é˜¶æ®µ1: æŒ‡ä»¤ç³»ç»Ÿæ¡†æ¶è®¾è®¡ (Instruction Framework)
    â†“
    å®šä¹‰ Instruction æ¥å£
    å®šä¹‰ OpCodeCategory æšä¸¾
    å®šä¹‰ VMConfig é…ç½®ç±»
    å®šä¹‰ ABIConvention æ¥å£
    â†“
é˜¶æ®µ2: å…·ä½“æŒ‡ä»¤å®ç° (Concrete Instructions)
    â†“
    å®ç° IAddInstruction, ISubInstruction, ...
    å®ç° ILoadInstruction, IStoreInstruction, ...
    å®ç° CallInstruction, RetInstruction, ...
    å®ç° ReferenceCountingGC
    â†“
é˜¶æ®µ3: æ‰§è¡Œå¼•æ“æ„å»º (Execution Engine)
    â†“
    å®ç° InstructionFactory (å·¥å‚æ³¨å†Œè¡¨)
    å®ç° VMExecutionContext (ä¸Šä¸‹æ–‡å°è£…)
    å®ç° CymbolStackVM (æ ¸å¿ƒæ‰§è¡Œå¼•æ“)
    â†“
é˜¶æ®µ4: è¿è¡Œæ—¶æ•°æ®ç»“æ„ (Runtime Data Structures)
    â†“
    å®ç° StackFrame (æ ˆå¸§ç®¡ç†)
    å®ç° FunctionSymbol (å‡½æ•°å…ƒæ•°æ®)
    å®ç° StructValue (ç»“æ„ä½“æ”¯æŒ)
    â†“
é˜¶æ®µ5: åº”ç”¨å±‚ç»„è£… (Application Orchestration)
    â†“
    å®ç° VMInterpreter (CLIå…¥å£)
    å®ç° VMRunner (æ‰§è¡Œç¼–æ’)
    æ•´åˆæ‰€æœ‰ç»„ä»¶
```

### 1.4 è®¾è®¡æ¨¡å¼ååŒå›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  EP18è®¾è®¡æ¨¡å¼ååŒ                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚   [Strategy Pattern]                                    â”‚
â”‚   Instruction æ¥å£å®šä¹‰ execute() ç­–ç•¥                    â”‚
â”‚         â†“                                                â”‚
â”‚   [Factory Pattern]                                     â”‚
â”‚   InstructionFactory åˆ›å»ºå…·ä½“æŒ‡ä»¤å®ä¾‹                     â”‚
â”‚         â†“                                                â”‚
â”‚   [Command Pattern]                                     â”‚
â”‚   Instruction å°è£…æ‰§è¡Œè¯·æ±‚                                â”‚
â”‚         â†“                                                â”‚
â”‚   [State Pattern]                                       â”‚
â”‚   VMExecutionContext ç®¡ç†VMçŠ¶æ€                            â”‚
â”‚         â†“                                                â”‚
â”‚   [Interpreter Pattern]                                 â”‚
â”‚   CymbolStackVM è§£é‡Šæ‰§è¡Œå­—èŠ‚ç                            â”‚
â”‚         â†“                                                â”‚
â”‚   [Adapter Pattern]                                     â”‚
â”‚   VMExecutionContext é€‚é…çŠ¶æ€åˆ°æŒ‡ä»¤                       â”‚
â”‚         â†“                                                â”‚
â”‚   [Builder Pattern]                                     â”‚
â”‚   VMConfig æ„å»ºå¤æ‚é…ç½®                                  â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.5 å­¦ä¹ è·¯å¾„å¯¼èˆª

```
å­¦ä¹ é¡ºåº (æŒ‰ä¾èµ–å…³ç³»):

Topic 1: æŒ‡ä»¤ç³»ç»Ÿæ¡†æ¶ (Instruction Framework)
    â†“ å®šä¹‰æ¥å£
Topic 2: æŒ‡ä»¤å·¥å‚ä¸åˆ†æ´¾ (Instruction Factory)
    â†“ åˆ›å»ºæŒ‡ä»¤
Topic 3: æ‰§è¡Œä¸Šä¸‹æ–‡ä¸æ ˆç®¡ç† (Execution Context)
    â†“ ç®¡ç†çŠ¶æ€
Topic 4: æ ˆå¸§ä¸å‡½æ•°è°ƒç”¨ (Stack Frames & ABI)
    â†“ ç®¡ç†è°ƒç”¨
Topic 5: å®Œæ•´VMé›†æˆ (Complete VM Integration)
```

---

## ğŸ“š ç†è®ºæ•™æç´¢å¼•

### å¯¹åº”ã€Šç¼–è¯‘åŸç†ã€‹ï¼ˆé¾™ä¹¦ç¬¬äºŒç‰ˆï¼‰

**å¯¹åº”ç« èŠ‚**: ç¬¬7ç« ï¼šè¿è¡Œæ—¶ç¯å¢ƒ + ç¬¬8ç« ï¼šä»£ç ç”Ÿæˆ

**å…³é”®ç†è®ºæ¦‚å¿µ**:
- **æ ˆå¼å­˜å‚¨åˆ†é…**: å‡½æ•°è°ƒç”¨å’Œè¿”å›çš„å†…å­˜ç®¡ç†æœºåˆ¶
- **æ ˆå¸§ï¼ˆStack Frameï¼‰**: ç®¡ç†å•ä¸ªå‡½æ•°è°ƒç”¨çš„æ‰§è¡ŒçŠ¶æ€çš„æ•°æ®ç»“æ„
- **æ´»åŠ¨è®°å½•ï¼ˆActivation Recordï¼‰**: å‡½æ•°è°ƒç”¨æœŸé—´æ‰€éœ€ä¿¡æ¯çš„é›†åˆ
- **å‚æ•°ä¼ é€’æœºåˆ¶**: å€¼ä¼ é€’ã€å¼•ç”¨ä¼ é€’ç­‰æ–¹å¼
- **ABIï¼ˆåº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£ï¼‰**: å‡½æ•°è°ƒç”¨çš„çº¦å®šå’Œè§„èŒƒ
- **åƒåœ¾å›æ”¶ï¼ˆGarbage Collectionï¼‰**: è‡ªåŠ¨å†…å­˜ç®¡ç†æŠ€æœ¯
- **è™šæ‹Ÿæœºæ¶æ„**: å­—èŠ‚ç è§£é‡Šæ‰§è¡Œçš„è®¾è®¡æ¨¡å¼

**ç†è®ºå®è·µå¯¹ç…§**:
| é¾™ä¹¦æ¦‚å¿µ | æœ¬EPå®ç° | å­¦ä¹ è¦ç‚¹ |
|---------|---------|---------|
| æ ˆå¼å­˜å‚¨åˆ†é… | CymbolStackVMçš„æ‰§è¡Œæ¨¡å‹ | ç†è®ºï¼šå†…å­˜å¸ƒå±€ â†’ å®è·µï¼šæ“ä½œæ•°æ ˆ + å±€éƒ¨å˜é‡æ•°ç»„ |
| æ ˆå¸§ç»“æ„ | StackFrameç±» | ç†è®ºï¼šæ´»åŠ¨è®°å½• â†’ å®è·µï¼šå‚æ•°ã€è¿”å›åœ°å€ã€å±€éƒ¨å˜é‡ |
| å‚æ•°ä¼ é€’ | CallInstructioné€šè¿‡æ ˆä¼ é€’ | ç†è®ºï¼šè°ƒç”¨çº¦å®š â†’ å®è·µï¼šå‹æ ˆé¡ºåºå’ŒABIè§„èŒƒ |
| åƒåœ¾å›æ”¶ | ReferenceCountingGC | ç†è®ºï¼šGCç®—æ³• â†’ å®è·µï¼šå¼•ç”¨è®¡æ•°å®ç° |
| æ§åˆ¶æµæŠ½è±¡ | Instructionæ¥å£ï¼ˆç­–ç•¥æ¨¡å¼ï¼‰ | ç†è®ºï¼šæŒ‡ä»¤é›†è®¾è®¡ â†’ å®è·µï¼šé¢å‘å¯¹è±¡æŒ‡ä»¤ç³»ç»Ÿ |
| è§£é‡Šå™¨æ¨¡å¼ | cpu()å–æŒ‡-æ‰§è¡Œå¾ªç¯ | ç†è®ºï¼šè§£é‡Šæ‰§è¡Œ â†’ å®è·µï¼šå­—èŠ‚ç VM |

**æ¨èå­¦ä¹ è·¯å¾„**:
1. é˜…è¯»é¾™ä¹¦ç¬¬7.1-7.3èŠ‚ï¼ˆ2å°æ—¶ï¼‰- ç†è§£è¿è¡Œæ—¶æ ˆå’Œæ ˆå¸§ç»“æ„
2. é˜…è¯»é¾™ä¹¦ç¬¬7.6èŠ‚ï¼ˆ2å°æ—¶ï¼‰- ç†è§£åƒåœ¾å›æ”¶çš„åŸºæœ¬ç®—æ³•
3. é˜…è¯»é¾™ä¹¦ç¬¬8.1-8.4èŠ‚ï¼ˆ2å°æ—¶ï¼‰- ç†è§£ä»£ç ç”Ÿæˆå’Œè™šæ‹Ÿæœºè®¾è®¡
4. å®Œæˆæœ¬EPå®è·µï¼ˆ8å°æ—¶ï¼‰- å®ç°æ ˆå¼VMå’ŒGC
5. å¯¹æ¯”æ€»ç»“ï¼ˆ1å°æ—¶ï¼‰- ç†è®ºæ¨¡å‹ vs å®é™…å·¥ç¨‹æƒè¡¡

**è¡¥å……é˜…è¯»**:
- **JVMè§„èŒƒ**: Javaè™šæ‹Ÿæœºè§„èŒƒç¬¬2ç‰ˆ - ç†è§£å·¥ä¸šçº§VMçš„è®¾è®¡
- **LuaJIT**: é«˜æ€§èƒ½VMçš„å®ç°å‚è€ƒ
- **åƒåœ¾å›æ”¶ç®—æ³•**: "Garbage Collection: Algorithms for Automatic Dynamic Memory Management" (Jones & Lins)
- **è®¾è®¡æ¨¡å¼**: ç­–ç•¥æ¨¡å¼ã€å·¥å‚æ¨¡å¼ã€å‘½ä»¤æ¨¡å¼ã€çŠ¶æ€æ¨¡å¼ï¼ˆGoFè®¾è®¡æ¨¡å¼ï¼‰

**å­¦ä¹ æç¤º**:
- é¾™ä¹¦ç¬¬7ç« é‡ç‚¹è®²è§£Cè¯­è¨€çš„è¿è¡Œæ—¶ç¯å¢ƒï¼Œæœ¬EPå®ç°çš„æ˜¯ç®€åŒ–çš„VMæ¨¡å‹
- æ ˆå¸§è®¾è®¡éœ€è¦å¹³è¡¡ç†è®ºå®Œæ•´æ€§å’Œå®è·µç®€æ´æ€§
- å¼•ç”¨è®¡æ•°GCæ˜¯æœ€ç®€å•çš„å®ç°ï¼Œä½†å­˜åœ¨å¾ªç¯å¼•ç”¨é—®é¢˜ï¼ˆæœ¬EPæœªå¤„ç†ï¼‰
- è™šæ‹Ÿæœºçš„è®¾è®¡å±•ç¤ºäº†å¦‚ä½•å°†ç†è®ºæ¨¡å‹è½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„å·¥ç¨‹ç³»ç»Ÿ
- ç­–ç•¥æ¨¡å¼åœ¨æŒ‡ä»¤ç³»ç»Ÿä¸­çš„åº”ç”¨æ˜¯æœ¬EPçš„æ ¸å¿ƒè®¾è®¡äº®ç‚¹
- ç†è§£ä¸ºä»€ä¹ˆéœ€è¦VMï¼ˆå¹³å°æ— å…³ã€å®‰å…¨ã€æ˜“å®ç°ï¼‰æ˜¯å…³é”®
- æ³¨æ„ï¼šæœ¬EPçš„æ ˆå¼VMä¸çœŸå®ç¡¬ä»¶çš„æ ˆå¸§ç±»ä¼¼ï¼Œä½†åšäº†å¤§é‡ç®€åŒ–

---

## ğŸ“š ç¬¬äºŒå±‚ï¼šä¸»é¢˜å•å…ƒ

### ä¸»é¢˜1: æŒ‡ä»¤ç³»ç»Ÿæ¡†æ¶

#### ğŸ“ åœ¨EP18ä¸­çš„ä½ç½®
```
Layer 1: Framework Layer
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Topic 1: æŒ‡ä»¤ç³»ç»Ÿæ¡†æ¶     â”‚
â”‚  â”œâ”€ Instructionæ¥å£        â”‚
â”‚  â”œâ”€ OpCodeCategoryæšä¸¾     â”‚
â”‚  â”œâ”€ VMConfigé…ç½®           â”‚
â”‚  â””â”€ ABIConventionè§„èŒƒ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ å®šä¹‰æ¡†æ¶
   Layer 2: å…·ä½“æŒ‡ä»¤å®ç°
```

#### ğŸ”— ä¾èµ–å…³ç³»
- **å‰ç½®ä¾èµ–**: EP16 (å­—èŠ‚ç å®šä¹‰)ã€è®¾è®¡æ¨¡å¼åŸºç¡€
- **åç»­åº”ç”¨**: Topic 2-5 (æ‰€æœ‰ä¸»é¢˜éƒ½ä¾èµ–æ­¤æ¡†æ¶)

#### 1.1 æ ¸å¿ƒæ¦‚å¿µ

**æ¦‚å¿µ1: ä¸ºä»€ä¹ˆéœ€è¦è™šæ‹Ÿæœºï¼Ÿ**

**ç›´æ¥ç¼–è¯‘åˆ°æœºå™¨ç çš„æŒ‘æˆ˜**:
- âŒ æ¯ä¸ªCPUæ¶æ„ï¼ˆx86, ARM, MIPSï¼‰æŒ‡ä»¤é›†ä¸åŒ
- âŒ å¯„å­˜å™¨æ•°é‡å’Œçº¦å®šå„ä¸ç›¸åŒ
- âŒ éœ€è¦å¤„ç†å¤æ‚çš„ç³»ç»Ÿè°ƒç”¨å’ŒABI

**è™šæ‹Ÿæœºçš„ä¼˜åŠ¿**:
- âœ… **å¹³å°æ— å…³**: å­—èŠ‚ç å¯åœ¨ä»»ä½•å¹³å°è¿è¡Œ
- âœ… **å®‰å…¨å¯æ§**: æ²™ç®±æ‰§è¡Œï¼Œé™åˆ¶å±é™©æ“ä½œ
- âœ… **æ˜“äºå®ç°**: æŒ‡ä»¤é›†ç®€å•ï¼Œæ— éœ€å…³å¿ƒç¡¬ä»¶ç»†èŠ‚
- âœ… **å¯ç§»æ¤**: .vm æ–‡ä»¶å¯åœ¨ä¸åŒå¹³å°é—´ä¼ è¾“

```
å¯¹æ¯”:

ä¼ ç»Ÿç¼–è¯‘å™¨:
æºä»£ç  â†’ [å‰ç«¯] â†’ AST â†’ [ä¼˜åŒ–] â†’ [ä»£ç ç”Ÿæˆ] â†’ x86æœºå™¨ç  / ARMæœºå™¨ç  / ...

åŸºäºVMçš„ç¼–è¯‘å™¨:
æºä»£ç  â†’ [å‰ç«¯] â†’ AST â†’ [ä¼˜åŒ–] â†’ [ä»£ç ç”Ÿæˆ] â†’ .vmå­—èŠ‚ç  â†’ [VMè§£é‡Šå™¨] â†’ æ‰§è¡Œç»“æœ
                                                          â†‘
                                                    å¹³å°ç›¸å…³å±‚
                                                    åªéœ€å®ç°ä¸€æ¬¡
```

**æ¦‚å¿µ2: ç­–ç•¥æ¨¡å¼åœ¨æŒ‡ä»¤ç³»ç»Ÿä¸­çš„åº”ç”¨**

ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰çš„æ ¸å¿ƒæ€æƒ³ï¼š
- å®šä¹‰ç®—æ³•æ—ï¼ˆä¸åŒæŒ‡ä»¤ï¼‰
- æ¯ä¸ªç®—æ³•å°è£…ç‹¬ç«‹ï¼ˆå®ç°Instructionæ¥å£ï¼‰
- å¯ä»¥äº’æ¢ä½¿ç”¨ï¼ˆInstructionFactoryåˆ‡æ¢ï¼‰

```
Instructionæ¥å£ (ç­–ç•¥æ¥å£):
    â”œâ”€â”€ IAddInstruction (åŠ æ³•ç­–ç•¥)
    â”œâ”€â”€ ISubInstruction (å‡æ³•ç­–ç•¥)
    â”œâ”€â”€ ILoadInstruction (åŠ è½½ç­–ç•¥)
    â””â”€â”€ CallInstruction (è°ƒç”¨ç­–ç•¥)
```

#### 1.2 å®ç°åŸç†

**é˜¶æ®µä¸€: å®šä¹‰æŒ‡ä»¤æ¥å£**

**å…³é”®ä»£ç ** (`Instruction.java`):

```java
package com.blitz.cymbol.ep18.instruction;

import com.blitz.cymbol.ep18.vm.VMExecutionContext;

/**
 * è™šæ‹ŸæœºæŒ‡ä»¤æ¥å£
 * è®¾è®¡æ¨¡å¼: Strategy Pattern (ç­–ç•¥), Command Pattern (å‘½ä»¤)
 */
public interface Instruction {
    /**
     * æ‰§è¡ŒæŒ‡ä»¤
     * @param context VMæ‰§è¡Œä¸Šä¸‹æ–‡
     * @throws VMRuntimeException è¿è¡Œæ—¶å¼‚å¸¸
     */
    void execute(VMExecutionContext context) throws VMRuntimeException;

    /**
     * è·å–æ“ä½œç 
     * @return æ“ä½œç  (0-255)
     */
    int getOpcode();

    /**
     * è·å–æ“ä½œç åŠ©è®°ç¬¦
     * @return åŠ©è®°ç¬¦å­—ç¬¦ä¸² (å¦‚ "IADD")
     */
    String getMnemonic();

    /**
     * è·å–æ“ä½œç åˆ†ç±»
     * @return æ“ä½œç åˆ†ç±»
     */
    OpCodeCategory getCategory();

    /**
     * æ˜¯å¦æœ‰æ“ä½œæ•°
     * @return trueå¦‚æœæœ‰æ“ä½œæ•°
     */
    boolean hasOperand();

    /**
     * è·å–æ“ä½œæ•°å¤§å°ï¼ˆå­—èŠ‚ï¼‰
     * @return æ“ä½œæ•°å¤§å°
     */
    int getOperandSize();
}
```

**ä»£ç è§£æ**:
- **ç¬¬17è¡Œ**: `execute()` æ–¹æ³•æ˜¯ç­–ç•¥æ¨¡å¼çš„ç®—æ³•æ¥å£
- **ç¬¬23è¡Œ**: `getOpcode()` è¿”å›æ“ä½œç ï¼ˆ0x00-0xFFï¼‰
- **ç¬¬29è¡Œ**: `getMnemonic()` è¿”å›åŠ©è®°ç¬¦ï¼ˆè°ƒè¯•ç”¨ï¼‰
- **ç¬¬42è¡Œ**: `hasOperand()` æŒ‡ç¤ºæ˜¯å¦éœ€è¦æ“ä½œæ•°

**é˜¶æ®µäºŒ: å®šä¹‰æ“ä½œç åˆ†ç±»**

**å…³é”®ä»£ç ** (`OpCodeCategory.java`):

```java
package com.blitz.cymbol.ep18.instruction;

/**
 * æ“ä½œç åˆ†ç±»æšä¸¾
 * ç”¨äºæŒ‡ä»¤åˆ†ç±»å’Œè°ƒè¯•
 */
public enum OpCodeCategory {
    // æ§åˆ¶æµæŒ‡ä»¤
    CONTROL_FLOW("æ§åˆ¶æµ", 0x30),

    // ç®—æœ¯æŒ‡ä»¤
    ARITHMETIC("ç®—æœ¯", 0x10),

    // æ¯”è¾ƒæŒ‡ä»¤
    COMPARISON("æ¯”è¾ƒ", 0x20),

    // å†…å­˜è®¿é—®æŒ‡ä»¤
    MEMORY_ACCESS("å†…å­˜è®¿é—®", 0x40),

    // æ ˆæ“ä½œæŒ‡ä»¤
    STACK_OPERATION("æ ˆæ“ä½œ", 0x50),

    // ç³»ç»ŸæŒ‡ä»¤
    SYSTEM("ç³»ç»Ÿ", 0x00);

    private final String description;
    private final int baseOpcode;

    OpCodeCategory(String description, int baseOpcode) {
        this.description = description;
        this.baseOpcode = baseOpcode;
    }

    public String getDescription() {
        return description;
    }

    public int getBaseOpcode() {
        return baseOpcode;
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬9-27è¡Œ**: å®šä¹‰æŒ‡ä»¤åˆ†ç±»ï¼ˆæ§åˆ¶æµã€ç®—æœ¯ã€æ¯”è¾ƒã€å†…å­˜ã€æ ˆã€ç³»ç»Ÿï¼‰
- **ç¬¬16è¡Œ**: åŸºç¡€æ“ä½œç ç”¨äºèŒƒå›´æ£€æŸ¥
- **è®¾è®¡æ¨¡å¼**: **æšä¸¾æ¨¡å¼**ï¼Œä¾¿äºæ‰©å±•å’Œç®¡ç†

**é˜¶æ®µä¸‰: å®šä¹‰VMé…ç½®**

**å…³é”®ä»£ç ** (`VMConfig.java`):

```java
package com.blitz.cymbol.ep18.config;

import com.blitz.cymbol.ep18.gc.GarbageCollector;
import com.blitz.cymbol.ep18.gc.ReferenceCountingGC;

/**
 * VMé…ç½®ç±»
 * è®¾è®¡æ¨¡å¼: Builder Pattern (å»ºé€ è€…)
 */
public class VMConfig {
    // å†…å­˜é…ç½®
    private final int maxStackSize;
    private final int maxHeapSize;

    // æ€§èƒ½é…ç½®
    private final boolean enableJIT;
    private final int optimizationLevel;

    // GCé…ç½®
    private final GarbageCollector gc;

    // è°ƒè¯•é…ç½®
    private final boolean traceEnabled;
    private final boolean verbose;

    // ç§æœ‰æ„é€ å‡½æ•°
    private VMConfig(Builder builder) {
        this.maxStackSize = builder.maxStackSize;
        this.maxHeapSize = builder.maxHeapSize;
        this.enableJIT = builder.enableJIT;
        this.optimizationLevel = builder.optimizationLevel;
        this.gc = builder.gc;
        this.traceEnabled = builder.traceEnabled;
        this.verbose = builder.verbose;
    }

    // Getteræ–¹æ³•
    public int getMaxStackSize() { return maxStackSize; }
    public int getMaxHeapSize() { return maxHeapSize; }
    public boolean isEnableJIT() { return enableJIT; }
    public GarbageCollector getGC() { return gc; }
    public boolean isTraceEnabled() { return traceEnabled; }

    // Builderç±»
    public static class Builder {
        private int maxStackSize = 1024;
        private int maxHeapSize = 4096;
        private boolean enableJIT = false;
        private int optimizationLevel = 0;
        private GarbageCollector gc = new ReferenceCountingGC();
        private boolean traceEnabled = false;
        private boolean verbose = false;

        public Builder maxStackSize(int size) {
            this.maxStackSize = size;
            return this;
        }

        public Builder maxHeapSize(int size) {
            this.maxHeapSize = size;
            return this;
        }

        public Builder enableJIT(boolean enable) {
            this.enableJIT = enable;
            return this;
        }

        public Builder traceEnabled(boolean enable) {
            this.traceEnabled = enable;
            return this;
        }

        public Builder gc(GarbageCollector gc) {
            this.gc = gc;
            return this;
        }

        public VMConfig build() {
            return new VMConfig(this);
        }
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬19è¡Œ**: ç§æœ‰æ„é€ å‡½æ•°ï¼Œå¼ºåˆ¶ä½¿ç”¨Builder
- **ç¬¬52-96è¡Œ**: Builderç±»æ”¯æŒé“¾å¼è°ƒç”¨
- **è®¾è®¡æ¨¡å¼**: **å»ºé€ è€…æ¨¡å¼**ï¼Œé€æ­¥æ„å»ºå¤æ‚å¯¹è±¡

`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`
**ç­–ç•¥æ¨¡å¼çš„æœ¬è´¨**:
```java
Instructionæ¥å£å®šä¹‰äº†"å¦‚ä½•æ‰§è¡Œ"çš„å¥‘çº¦
    â†“
å…·ä½“æŒ‡ä»¤å®ç°äº†ä¸åŒçš„æ‰§è¡Œç­–ç•¥
    â†“
InstructionFactoryæ ¹æ®æ“ä½œç é€‰æ‹©ç­–ç•¥
    â†“
CymbolStackVMç»Ÿä¸€è°ƒç”¨ç­–ç•¥çš„execute()
```

è¿™ä½¿å¾—æ·»åŠ æ–°æŒ‡ä»¤éå¸¸å®¹æ˜“ï¼šåªéœ€å®ç°Instructionæ¥å£å¹¶æ³¨å†Œåˆ°å·¥å‚ï¼Œæ— éœ€ä¿®æ”¹VMæ ¸å¿ƒä»£ç ã€‚
`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`

#### 1.3 å®è·µç»ƒä¹ 

**ç»ƒä¹ : è®¾è®¡æ–°çš„æŒ‡ä»¤åˆ†ç±»**

**ä»»åŠ¡**: æ‰©å±•æ“ä½œç åˆ†ç±»ï¼Œæ·»åŠ "ä½è¿ç®—"åˆ†ç±»

**æç¤º**:
```java
public enum OpCodeCategory {
    // ... ç°æœ‰åˆ†ç±»

    // æ–°å¢ä½è¿ç®—åˆ†ç±»
    BITWISE("ä½è¿ç®—", 0x60);

    // ...
}
```

**å®ç°å¯¹åº”çš„æŒ‡ä»¤**:
```java
public class IAndInstruction extends Instruction {
    public IAndInstruction() {
        super(0x61, "IAND", OpCodeCategory.BITWISE);
    }

    @Override
    public void execute(VMExecutionContext context) {
        int right = context.pop();
        int left = context.pop();
        context.push(left & right);  // æŒ‰ä½ä¸
    }
}

public class IOrInstruction extends Instruction {
    public IOrInstruction() {
        super(0x62, "IOR", OpCodeCategory.BITWISE);
    }

    @Override
    public void execute(VMExecutionContext context) {
        int right = context.pop();
        int left = context.pop();
        context.push(left | right);  // æŒ‰ä½æˆ–
    }
}
```

---

#### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ä¸‹ä¸€ä¸»é¢˜

**è¿æ¥ä»£ç **:

```java
// Topic 1 æä¾›: æŒ‡ä»¤æ¥å£
public interface Instruction {
    void execute(VMExecutionContext context);
    int getOpcode();
}

// â†’ Topic 2 ä½¿ç”¨: å®ç°å…·ä½“æŒ‡ä»¤
public class IAddInstruction extends Instruction {
    public IAddInstruction() {
        super(0x10, "IADD", OpCodeCategory.ARITHMETIC);
    }

    @Override
    public void execute(VMExecutionContext context) {
        int right = context.pop();
        int left = context.pop();
        context.push(left + right);
    }
}
```

**å…³ç³»è¯´æ˜**:
- Topic 1 çš„ `Instruction` æ¥å£å®šä¹‰äº†æŒ‡ä»¤çš„å¥‘çº¦
- Topic 2 çš„å…·ä½“æŒ‡ä»¤å®ç°äº†è¿™ä¸ªæ¥å£
- å·¥å‚æ¨¡å¼è´Ÿè´£åˆ›å»ºè¿™äº›å…·ä½“å®ç°

---

### ä¸»é¢˜2: æŒ‡ä»¤å·¥å‚ä¸åˆ†æ´¾

#### ğŸ“ åœ¨EP18ä¸­çš„ä½ç½®
```
Layer 2-3: Implementation + Execution Engine
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Topic 2: æŒ‡ä»¤å·¥å‚ä¸åˆ†æ´¾   â”‚
â”‚  â”œâ”€ InstructionFactory     â”‚
â”‚  â””â”€ å…·ä½“æŒ‡ä»¤å®ç°           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†‘ å®ç°Topic 1æ¥å£
         â†“ è¢«Topic 3ä½¿ç”¨
Topic 3: æ‰§è¡Œå¼•æ“
```

#### ğŸ”— ä¾èµ–å…³ç³»
- **å‰ç½®ä¾èµ–**: Topic 1 (Instructionæ¥å£)
- **åç»­åº”ç”¨**: Topic 3 (CymbolStackVMä½¿ç”¨å·¥å‚)

#### 2.1 æ ¸å¿ƒæ¦‚å¿µ

**æ¦‚å¿µ1: å·¥å‚æ¨¡å¼åœ¨æŒ‡ä»¤åˆ›å»ºä¸­çš„åº”ç”¨**

å·¥å‚æ¨¡å¼ï¼ˆFactory Patternï¼‰çš„æ ¸å¿ƒï¼š
- å°è£…å¯¹è±¡åˆ›å»ºé€»è¾‘
- æ ¹æ®è¾“å…¥ï¼ˆæ“ä½œç ï¼‰è¿”å›å¯¹åº”å®ä¾‹
- æ”¯æŒç¼“å­˜å’Œå•ä¾‹æ¨¡å¼

```
InstructionFactory (å·¥å‚)
    â†“ æ ¹æ®æ“ä½œç åˆ›å»º
å…·ä½“æŒ‡ä»¤å®ä¾‹
    â”œâ”€â”€ IAddInstruction (0x10)
    â”œâ”€â”€ ISubInstruction (0x11)
    â”œâ”€â”€ ILoadInstruction (0x40)
    â””â”€â”€ ...
```

**æ¦‚å¿µ2: å•ä¾‹æ¨¡å¼åœ¨æŒ‡ä»¤ç®¡ç†ä¸­çš„åº”ç”¨**

æ¯æ¡æŒ‡ä»¤åªéœ€è¦ä¸€ä¸ªå®ä¾‹ï¼š
- èŠ‚çœå†…å­˜
- æé«˜æ€§èƒ½ï¼ˆé¿å…é‡å¤åˆ›å»ºï¼‰
- ä¿è¯ä¸€è‡´æ€§

```
InstructionFactory (å•ä¾‹)
    â”œâ”€â”€ ç»´æŠ¤æŒ‡ä»¤ç¼“å­˜ Map<Opcode, Instruction>
    â”œâ”€â”€ é¦–æ¬¡è¯·æ±‚æ—¶åˆ›å»º
    â””â”€â”€ åç»­è¯·æ±‚ç›´æ¥è¿”å›ç¼“å­˜å®ä¾‹
```

#### 2.2 å®ç°åŸç†

**é˜¶æ®µä¸€: å®ç°ç®—æœ¯æŒ‡ä»¤**

**å…³é”®ä»£ç ** (`IAddInstruction.java`):

```java
package com.blitz.cymbol.ep18.instruction;

import com.blitz.cymbol.ep18.vm.VMExecutionContext;
import com.blitz.cymbol.ep18.exception.VMRuntimeException;

/**
 * æ•´æ•°åŠ æ³•æŒ‡ä»¤
 * å­—èŠ‚ç æ ¼å¼: IADD
 * æ ˆæ•ˆæœ: ..., left, right â†’ ..., result
 */
public class IAddInstruction extends Instruction {
    public IAddInstruction() {
        super(0x10, "IADD", OpCodeCategory.ARITHMETIC);
    }

    @Override
    public void execute(VMExecutionContext context) throws VMRuntimeException {
        // 1. ä»æ ˆé¡¶å¼¹å‡ºå³æ“ä½œæ•°
        int right = context.pop();

        // 2. ä»æ ˆé¡¶å¼¹å‡ºå·¦æ“ä½œæ•°
        int left = context.pop();

        // 3. æ‰§è¡ŒåŠ æ³•è¿ç®—
        int result = left + right;

        // 4. æ£€æŸ¥æº¢å‡ºï¼ˆå¯é€‰ï¼‰
        // if ((left ^ result) & (right ^ result) & 0x80000000) {
        //     throw new VMRuntimeException("Integer overflow");
        // }

        // 5. å°†ç»“æœå‹æ ˆ
        context.push(result);
    }

    @Override
    public boolean hasOperand() {
        return false;  // IADDæŒ‡ä»¤æ— æ“ä½œæ•°
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬7è¡Œ**: å®šä¹‰æ“ä½œç ï¼ˆ0x10ï¼‰å’ŒåŠ©è®°ç¬¦ï¼ˆIADDï¼‰
- **ç¬¬17-18è¡Œ**: **å¼¹å‡ºå³æ“ä½œæ•°** - æ ˆæ˜¯åè¿›å…ˆå‡ºï¼Œå…ˆå¼¹å³
- **ç¬¬21-22è¡Œ**: **å¼¹å‡ºå·¦æ“ä½œæ•°**
- **ç¬¬25è¡Œ**: **æ‰§è¡Œè¿ç®—**
- **ç¬¬34è¡Œ**: **ç»“æœå‹æ ˆ**
- **ç¬¬40è¡Œ**: **æ— æ“ä½œæ•°æ ‡è®°** - æ“ä½œæ•°éšå¼åœ¨æ ˆä¸­

**æ ˆå˜åŒ–ç¤ºæ„å›¾**:
```
æ‰§è¡Œå‰:
æ ˆé¡¶ â†’ [ right ]
       [ left  ]
       [  ...  ]

æ‰§è¡Œ: IADD

æ‰§è¡Œå:
æ ˆé¡¶ â†’ [ result ]  â† result = left + right
       [  ...   ]
```

**é˜¶æ®µäºŒ: å®ç°æŒ‡ä»¤å·¥å‚**

**å…³é”®ä»£ç ** (`InstructionFactory.java`):

```java
package com.blitz.cymbol.ep18.instruction;

import java.util.HashMap;
import java.util.Map;

/**
 * æŒ‡ä»¤å·¥å‚ç±»
 * è®¾è®¡æ¨¡å¼: Factory Pattern (å·¥å‚), Singleton Pattern (å•ä¾‹)
 */
public class InstructionFactory {
    // å•ä¾‹å®ä¾‹
    private static InstructionFactory instance;

    // æŒ‡ä»¤ç¼“å­˜ Map<æ“ä½œç , æŒ‡ä»¤å®ä¾‹>
    private final Map<Integer, Instruction> instructionCache;

    // ç§æœ‰æ„é€ å‡½æ•°
    private InstructionFactory() {
        this.instructionCache = new HashMap<>();
        initializeInstructions();
    }

    /**
     * è·å–å•ä¾‹å®ä¾‹
     */
    public static synchronized InstructionFactory getInstance() {
        if (instance == null) {
            instance = new InstructionFactory();
        }
        return instance;
    }

    /**
     * åˆå§‹åŒ–æ‰€æœ‰æŒ‡ä»¤
     */
    private void initializeInstructions() {
        // ç®—æœ¯æŒ‡ä»¤
        registerInstruction(new IAddInstruction());
        registerInstruction(new ISubInstruction());
        registerInstruction(new IMulInstruction());
        registerInstruction(new IDivInstruction());

        // æ¯”è¾ƒæŒ‡ä»¤
        registerInstruction(new ILtInstruction());
        registerInstruction(new ILeInstruction());
        registerInstruction(new IGtInstruction());
        registerInstruction(new IGeInstruction());
        registerInstruction(new IEqInstruction());
        registerInstruction(new INeqInstruction());

        // å†…å­˜è®¿é—®æŒ‡ä»¤
        registerInstruction(new ILoadInstruction());
        registerInstruction(new IStoreInstruction());

        // æ§åˆ¶æµæŒ‡ä»¤
        registerInstruction(new CallInstruction());
        registerInstruction(new RetInstruction());
        registerInstruction(new JmpInstruction());
        registerInstruction(new CmpJumpInstruction());

        // ç³»ç»ŸæŒ‡ä»¤
        registerInstruction(new HaltInstruction());
    }

    /**
     * æ³¨å†ŒæŒ‡ä»¤åˆ°ç¼“å­˜
     */
    private void registerInstruction(Instruction instruction) {
        int opcode = instruction.getOpcode();
        instructionCache.put(opcode, instruction);
    }

    /**
     * æ ¹æ®æ“ä½œç è·å–æŒ‡ä»¤
     */
    public Instruction getInstruction(int opcode) {
        Instruction instruction = instructionCache.get(opcode);
        if (instruction == null) {
            throw new VMRuntimeException("Unknown opcode: 0x" +
                Integer.toHexString(opcode).toUpperCase());
        }
        return instruction;
    }

    /**
     * æ ¹æ®åŠ©è®°ç¬¦è·å–æŒ‡ä»¤
     */
    public Instruction getInstructionByMnemonic(String mnemonic) {
        for (Instruction instruction : instructionCache.values()) {
            if (instruction.getMnemonic().equals(mnemonic)) {
                return instruction;
            }
        }
        throw new VMRuntimeException("Unknown mnemonic: " + mnemonic);
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬17è¡Œ**: å•ä¾‹æ¨¡å¼çš„çº¿ç¨‹å®‰å…¨å®ç°
- **ç¬¬23è¡Œ**: æŒ‡ä»¤ç¼“å­˜Map
- **ç¬¬44-74è¡Œ**: åˆå§‹åŒ–å¹¶æ³¨å†Œæ‰€æœ‰æŒ‡ä»¤
- **ç¬¬86-96è¡Œ**: æ ¹æ®æ“ä½œç è·å–æŒ‡ä»¤ï¼ˆå¸¦é”™è¯¯æ£€æŸ¥ï¼‰
- **è®¾è®¡æ¨¡å¼**: **å•ä¾‹æ¨¡å¼ + å·¥å‚æ¨¡å¼**

`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`
**å•ä¾‹+å·¥å‚çš„ç»„åˆä¼˜åŠ¿**:
```java
ä¼ ç»Ÿæ–¹å¼: æ¯æ¬¡åˆ›å»ºæ–°æŒ‡ä»¤
Instruction add = new IAddInstruction();  // æ¯æ¬¡éƒ½åˆ›å»º
Instruction mul = new IMulInstruction();

å·¥å‚+å•ä¾‹: å¤ç”¨æŒ‡ä»¤å®ä¾‹
Instruction add = factory.getInstruction(0x10);  // å¤ç”¨
Instruction mul = factory.getInstruction(0x12);
```

ä¼˜åŠ¿:
1. **èŠ‚çœå†…å­˜**: æ‰€æœ‰åŒç±»å‹æŒ‡ä»¤å…±äº«ä¸€ä¸ªå®ä¾‹
2. **æé«˜æ€§èƒ½**: é¿å…é‡å¤åˆ›å»ºå¯¹è±¡
3. **ä¿è¯ä¸€è‡´æ€§**: æŒ‡ä»¤å±æ€§ä¸ä¼šæ„å¤–ä¿®æ”¹
`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`

#### 2.3 å®è·µç»ƒä¹ 

**ç»ƒä¹ : å®ç°å‡æ³•æŒ‡ä»¤**

**ä»»åŠ¡**: æ·»åŠ  `ISUB` æŒ‡ä»¤

**æç¤º**:
```java
public class ISubInstruction extends Instruction {
    public ISubInstruction() {
        super(0x11, "ISUB", OpCodeCategory.ARITHMETIC);
    }

    @Override
    public void execute(VMExecutionContext context) {
        // TODO: å®ç°å‡æ³•é€»è¾‘
        // 1. å¼¹å‡ºå³æ“ä½œæ•°
        // 2. å¼¹å‡ºå·¦æ“ä½œæ•°
        // 3. è®¡ç®— left - right
        // 4. ç»“æœå‹æ ˆ
    }
}
```

**æµ‹è¯•**:
```
å­—èŠ‚ç :
ICONST_5
ICONST_3
ISUB
HALT

é¢„æœŸç»“æœ: æ ˆé¡¶ = 2
```

---

#### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ä¸‹ä¸€ä¸»é¢˜

**è¿æ¥ä»£ç **:

```java
// Topic 2 æä¾›: æŒ‡ä»¤å·¥å‚
InstructionFactory factory = InstructionFactory.getInstance();

// â†’ Topic 3 ä½¿ç”¨: VMæ‰§è¡Œå¼•æ“ä½¿ç”¨å·¥å‚è·å–æŒ‡ä»¤
public class CymbolStackVM {
    public void cpu() {
        int opcode = bytecode[pc];
        Instruction instr = InstructionFactory.getInstance().getInstruction(opcode);
        instr.execute(context);
    }
}
```

**å…³ç³»è¯´æ˜**:
- Topic 2 çš„ `InstructionFactory` æ˜¯æŒ‡ä»¤çš„åˆ›å»ºè€…
- Topic 3 çš„ `CymbolStackVM` æ˜¯æŒ‡ä»¤çš„ä½¿ç”¨è€…
- å·¥å‚æ¨¡å¼è§£è€¦äº†åˆ›å»ºå’Œä½¿ç”¨

---

### ä¸»é¢˜3: æ‰§è¡Œä¸Šä¸‹æ–‡ä¸æ ˆç®¡ç†

#### ğŸ“ åœ¨EP18ä¸­çš„ä½ç½®
```
Layer 3: Execution Engine Layer
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Topic 3: æ‰§è¡Œä¸Šä¸‹æ–‡       â”‚
â”‚  â””â”€ VMExecutionContext     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†‘ å°è£…çŠ¶æ€
         â†“ è¢«Topic 4ä½¿ç”¨
Topic 4: æ ˆå¸§ç®¡ç†
```

#### ğŸ”— ä¾èµ–å…³ç³»
- **å‰ç½®ä¾èµ–**: Topic 1 (Instructionæ¥å£)ã€Topic 2 (å…·ä½“æŒ‡ä»¤)
- **åç»­åº”ç”¨**: Topic 4 (StackFrame)ã€Topic 5 (VMæ ¸å¿ƒ)

#### 3.1 æ ¸å¿ƒæ¦‚å¿µ

**æ¦‚å¿µ1: VMæ‰§è¡Œä¸Šä¸‹æ–‡çš„èŒè´£**

`VMExecutionContext` æ˜¯VMçš„"çŠ¶æ€ç®¡ç†å™¨"ï¼š
- **æ“ä½œæ•°æ ˆç®¡ç†**: push/popæ“ä½œ
- **å±€éƒ¨å˜é‡è®¿é—®**: getLocal/setLocal
- **ç¨‹åºè®¡æ•°å™¨**: PCç®¡ç†
- **æ ˆå¸§ç®¡ç†**: pushFrame/popFrame
- **å†…å­˜ç®¡ç†**: å †åˆ†é…ã€GCè°ƒç”¨

**æ¦‚å¿µ2: çŠ¶æ€æ¨¡å¼çš„åº”ç”¨**

çŠ¶æ€æ¨¡å¼ï¼ˆState Patternï¼‰çš„æ ¸å¿ƒï¼š
- å°è£…çŠ¶æ€ç›¸å…³çš„è¡Œä¸º
- çŠ¶æ€è½¬æ¢æ—¶æ”¹å˜è¡Œä¸º
- ä¸Šä¸‹æ–‡å§”æ‰˜ç»™çŠ¶æ€å¯¹è±¡

```
VMExecutionContext (çŠ¶æ€ä¸Šä¸‹æ–‡)
    â”œâ”€â”€ ç»´æŠ¤å½“å‰çŠ¶æ€
    â”œâ”€â”€ å§”æ‰˜æ“ä½œç»™å½“å‰æ ˆå¸§
    â””â”€â”€ ç®¡ç†çŠ¶æ€è½¬æ¢
```

#### 3.2 å®ç°åŸç†

**é˜¶æ®µä¸€: å®šä¹‰æ‰§è¡Œä¸Šä¸‹æ–‡**

**å…³é”®ä»£ç ** (`VMExecutionContext.java`):

```java
package com.blitz.cymbol.ep18.vm;

import com.blitz.cymbol.ep18.exception.VMRuntimeException;
import com.blitz.cymbol.ep18.frame.StackFrame;
import com.blitz.cymbol.ep18.gc.GarbageCollector;

/**
 * VMæ‰§è¡Œä¸Šä¸‹æ–‡
 * è®¾è®¡æ¨¡å¼: State Pattern (çŠ¶æ€), Adapter Pattern (é€‚é…å™¨)
 */
public class VMExecutionContext {
    // æ“ä½œæ•°æ ˆ
    private final int[] operandStack;
    private int stackPointer;

    // ç¨‹åºè®¡æ•°å™¨
    private int pc;

    // è°ƒç”¨æ ˆ
    private StackFrame currentFrame;

    // å†…å­˜ç®¡ç†
    private final int[] heap;
    private final GarbageCollector gc;

    // é…ç½®
    private final boolean traceEnabled;

    public VMExecutionContext(VMConfig config) {
        this.operandStack = new int[config.getMaxStackSize()];
        this.stackPointer = 0;
        this.pc = 0;
        this.heap = new int[config.getMaxHeapSize()];
        this.gc = config.getGC();
        this.traceEnabled = config.isTraceEnabled();
    }

    // ========== æ“ä½œæ•°æ ˆæ“ä½œ ==========

    public void push(int value) {
        if (stackPointer >= operandStack.length) {
            throw new VMRuntimeException("Stack overflow");
        }
        operandStack[stackPointer++] = value;
    }

    public int pop() {
        if (stackPointer <= 0) {
            throw new VMRuntimeException("Stack underflow");
        }
        return operandStack[--stackPointer];
    }

    public int peek() {
        if (stackPointer <= 0) {
            throw new VMRuntimeException("Stack is empty");
        }
        return operandStack[stackPointer - 1];
    }

    // ========== ç¨‹åºè®¡æ•°å™¨æ“ä½œ ==========

    public int getPc() {
        return pc;
    }

    public void setPc(int pc) {
        if (pc < 0) {
            throw new VMRuntimeException("Invalid PC: " + pc);
        }
        this.pc = pc;
    }

    public int readOperandInt() {
        int value = heap[pc];
        pc += 4;  // intå 4å­—èŠ‚
        return value;
    }

    // ========== æ ˆå¸§æ“ä½œ ==========

    public void pushFrame(StackFrame frame) {
        frame.setCaller(this.currentFrame);
        this.currentFrame = frame;
    }

    public StackFrame popFrame() {
        if (currentFrame == null) {
            throw new VMRuntimeException("No frame to pop");
        }
        StackFrame frame = currentFrame;
        this.currentFrame = frame.getCaller();
        return frame;
    }

    public StackFrame getCurrentFrame() {
        return currentFrame;
    }

    // ========== å±€éƒ¨å˜é‡è®¿é—® ==========

    public void setLocal(int index, int value) {
        if (currentFrame == null) {
            throw new VMRuntimeException("No current frame");
        }
        currentFrame.setLocal(index, value);
    }

    public int getLocal(int index) {
        if (currentFrame == null) {
            throw new VMRuntimeException("No current frame");
        }
        return currentFrame.getLocal(index);
    }

    // ========== è°ƒè¯•æ”¯æŒ ==========

    public void dumpStack() {
        System.out.println("=== Stack Dump ===");
        System.out.println("SP: " + stackPointer);
        for (int i = 0; i < stackPointer; i++) {
            System.out.println("  [" + i + "] = " + operandStack[i]);
        }
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬13-14è¡Œ**: æ“ä½œæ•°æ ˆä½¿ç”¨æ•°ç»„å®ç°
- **ç¬¬38-46è¡Œ**: `push()` æ–¹æ³•æ£€æŸ¥æ ˆæº¢å‡º
- **ç¬¬48-56è¡Œ**: `pop()` æ–¹æ³•æ£€æŸ¥æ ˆä¸‹æº¢
- **ç¬¬81-87è¡Œ**: `readOperandInt()` ä»å†…å­˜è¯»å–æ“ä½œæ•°å¹¶æ›´æ–°PC
- **ç¬¬99-105è¡Œ**: æ ˆå¸§çš„å‹æ ˆå’Œå¼¹æ ˆ
- **è®¾è®¡æ¨¡å¼**: **çŠ¶æ€æ¨¡å¼**ï¼ˆç®¡ç†VMçŠ¶æ€ï¼‰ã€**é€‚é…å™¨æ¨¡å¼**ï¼ˆé€‚é…æ ˆå¸§æ¥å£ï¼‰

#### 3.3 å®è·µç»ƒä¹ 

**ç»ƒä¹ : æ·»åŠ æ ˆæ·±åº¦æ£€æŸ¥**

**ä»»åŠ¡**: æ‰©å±• `VMExecutionContext`ï¼Œæ”¯æŒæ ˆæ·±åº¦é™åˆ¶å’Œè­¦å‘Š

**æç¤º**:
```java
public class VMExecutionContext {
    private final int maxStackDepth;
    private final Stack<StackFrame> callStack;

    public void pushFrame(StackFrame frame) {
        if (callStack.size() >= maxStackDepth) {
            throw new VMRuntimeException(
                "Maximum stack depth reached: " + maxStackDepth
            );
        }

        // è­¦å‘Šæ£€æŸ¥
        if (callStack.size() >= maxStackDepth * 0.9) {
            System.err.println(
                "Warning: Stack depth approaching limit: " +
                callStack.size() + "/" + maxStackDepth
            );
        }

        callStack.push(frame);
        this.currentFrame = frame;
    }
}
```

---

#### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ä¸‹ä¸€ä¸»é¢˜

**è¿æ¥ä»£ç **:

```java
// Topic 3 æä¾›: æ‰§è¡Œä¸Šä¸‹æ–‡
VMExecutionContext context = new VMExecutionContext(config);

// â†’ Topic 4 ä½¿ç”¨: æ ˆå¸§æ“ä½œä¸Šä¸‹æ–‡
StackFrame frame = new StackFrame("main", callContext);
context.pushFrame(frame);

// æŒ‡ä»¤é€šè¿‡ä¸Šä¸‹æ–‡æ“ä½œæ ˆå¸§
context.setLocal(0, 42);  // è®¾ç½®å±€éƒ¨å˜é‡
int value = context.getLocal(0);  // è·å–å±€éƒ¨å˜é‡
```

**å…³ç³»è¯´æ˜**:
- Topic 3 çš„ `VMExecutionContext` æ˜¯çŠ¶æ€çš„ä¸­å¤®ç®¡ç†è€…
- Topic 4 çš„ `StackFrame` æ˜¯å‡½æ•°è°ƒç”¨çš„æ•°æ®ç»“æ„
- ä¸Šä¸‹æ–‡æŒæœ‰å½“å‰æ ˆå¸§çš„å¼•ç”¨

---

### ä¸»é¢˜4: æ ˆå¸§ä¸å‡½æ•°è°ƒç”¨

#### ğŸ“ åœ¨EP18ä¸­çš„ä½ç½®
```
Layer 4: Runtime Data Layer
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Topic 4: æ ˆå¸§ä¸å‡½æ•°è°ƒç”¨   â”‚
â”‚  â”œâ”€ StackFrame             â”‚
â”‚  â”œâ”€ FunctionSymbol         â”‚
â”‚  â””â”€ ABIConvention          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†‘ ç®¡ç†è°ƒç”¨
         â†“ ä½¿ç”¨Topic 3ä¸Šä¸‹æ–‡
```

#### ğŸ”— ä¾èµ–å…³ç³»
- **å‰ç½®ä¾èµ–**: Topic 1 (Instructionæ¥å£)ã€Topic 3 (VMExecutionContext)
- **åç»­åº”ç”¨**: Topic 5 (å®Œæ•´VM)

#### 4.1 æ ¸å¿ƒæ¦‚å¿µ

**æ¦‚å¿µ1: æ ˆå¸§çš„ç»“æ„**

æ ˆå¸§ï¼ˆStack Frameï¼‰ç®¡ç†å•ä¸ªå‡½æ•°è°ƒç”¨çš„æ‰§è¡ŒçŠ¶æ€ï¼š
- **å±€éƒ¨å˜é‡æ•°ç»„**: å­˜å‚¨å±€éƒ¨å˜é‡å’Œå‚æ•°
- **è¿”å›åœ°å€**: å‡½æ•°è¿”å›åç»§ç»­æ‰§è¡Œçš„ä½ç½®
- **è°ƒç”¨è€…æ ˆå¸§**: ç”¨äºè¿”å›æ—¶æ¢å¤

```
è°ƒç”¨æ ˆ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ ˆå¸§3: factorial(2)                        â”‚
â”‚  â”œâ”€ å±€éƒ¨å˜é‡: [n=2, result=2]               â”‚
â”‚  â”œâ”€ å‚æ•°: [arg0=2]                          â”‚
â”‚  â”œâ”€ è¿”å›åœ°å€: 0x0042                         â”‚
â”‚  â””â”€ æ“ä½œæ•°æ ˆ: []                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ ˆå¸§2: factorial(3)                        â”‚
â”‚  â”œâ”€ å±€éƒ¨å˜é‡: [n=3]                         â”‚
â”‚  â”œâ”€ å‚æ•°: [arg0=3]                          â”‚
â”‚  â”œâ”€ è¿”å›åœ°å€: 0x0028                         â”‚
â”‚  â””â”€ æ“ä½œæ•°æ ˆ: [6]                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ ˆå¸§1: main()                               â”‚
â”‚  â”œâ”€ å±€éƒ¨å˜é‡: [x=5]                         â”‚
â”‚  â”œâ”€ å‚æ•°: []                                â”‚
â”‚  â”œâ”€ è¿”å›åœ°å€: null (mainä¸è¿”å›)              â”‚
â”‚  â””â”€ æ“ä½œæ•°æ ˆ: [120]                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ¦‚å¿µ2: ABIï¼ˆåº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£ï¼‰**

ABIå®šä¹‰äº†å‡½æ•°è°ƒç”¨çš„çº¦å®šï¼š
- **å‚æ•°ä¼ é€’**: å‚æ•°å¦‚ä½•ä¼ é€’ï¼ˆæ ˆ/å¯„å­˜å™¨ï¼‰
- **è¿”å›å€¼**: è¿”å›å€¼å¦‚ä½•è¿”å›
- **æ ˆå¸§å¸ƒå±€**: æ ˆå¸§å¦‚ä½•ç»„ç»‡
- **è°ƒç”¨/è¿”å›**: CALLå’ŒRETæŒ‡ä»¤çš„è¡Œä¸º

```
ABIçº¦å®šç¤ºä¾‹:
1. å‚æ•°ä»å³åˆ°å·¦å‹æ ˆ
2. CALLæŒ‡ä»¤å‹å…¥è¿”å›åœ°å€
3. è¿”å›å€¼é€šè¿‡æ ˆé¡¶è¿”å›
4. RETæŒ‡ä»¤å¼¹å‡ºè¿”å›åœ°å€å¹¶è·³è½¬
```

#### 4.2 å®ç°åŸç†

**é˜¶æ®µä¸€: å®ç°æ ˆå¸§**

**å…³é”®ä»£ç ** (`StackFrame.java`):

```java
package com.blitz.cymbol.ep18.frame;

import com.blitz.cymbol.ep18.exception.VMRuntimeException;

/**
 * æ ˆå¸§ç±»
 * è®¾è®¡æ¨¡å¼: Builder Pattern (å»ºé€ )
 */
public class StackFrame {
    private final String functionName;
    private final int parameterCount;
    private final int localVariableCount;
    private final int[] localVariables;  // å±€éƒ¨å˜é‡æ•°ç»„
    private final int returnAddress;     // è¿”å›åœ°å€
    private final StackFrame caller;     // è°ƒç”¨è€…æ ˆå¸§

    public StackFrame(String functionName, CallContext callCtx) {
        this.functionName = functionName;
        this.parameterCount = callCtx.getParameterCount();
        this.localVariableCount = callCtx.getLocalVariableCount();
        this.returnAddress = callCtx.getReturnAddress();
        this.caller = callCtx.getCallerFrame();

        // åˆ†é…å±€éƒ¨å˜é‡æ•°ç»„
        this.localVariables = new int[localVariableCount];

        // ä»è°ƒç”¨è€…çš„æ“ä½œæ•°æ ˆå¤åˆ¶å‚æ•°åˆ°å±€éƒ¨å˜é‡
        VMExecutionContext callerCtx = callCtx.getCallerContext();
        for (int i = 0; i < parameterCount; i++) {
            // å‚æ•°ä»æ ˆé¡¶å¼¹å‡ºï¼ŒæŒ‰ç›¸åé¡ºåºå­˜å‚¨
            int paramValue = callerCtx.pop();
            this.localVariables[i] = paramValue;
        }
    }

    // è®¿é—®å±€éƒ¨å˜é‡
    public int getLocal(int index) {
        if (index < 0 || index >= localVariableCount) {
            throw new VMRuntimeException(
                "Local variable index out of bounds: " + index +
                " (function: " + functionName + ")"
            );
        }
        return localVariables[index];
    }

    // è®¾ç½®å±€éƒ¨å˜é‡
    public void setLocal(int index, int value) {
        if (index < 0 || index >= localVariableCount) {
            throw new VMRuntimeException(
                "Local variable index out of bounds: " + index
            );
        }
        localVariables[index] = value;
    }

    // è·å–è¿”å›åœ°å€
    public int getReturnAddress() {
        return returnAddress;
    }

    // è·å–è°ƒç”¨è€…æ ˆå¸§
    public StackFrame getCaller() {
        return caller;
    }

    // éªŒè¯æ ˆå¸§å®Œæ•´æ€§
    public boolean isValid() {
        return functionName != null &&
               localVariables != null &&
               localVariables.length == localVariableCount;
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬12è¡Œ**: `localVariables` æ•°ç»„å­˜å‚¨æ‰€æœ‰å±€éƒ¨å˜é‡å’Œå‚æ•°
- **ç¬¬17è¡Œ**: `returnAddress` è®°å½•è¿”å›åç»§ç»­æ‰§è¡Œçš„æŒ‡ä»¤ä½ç½®
- **ç¬¬18è¡Œ**: `caller` ä¿å­˜è°ƒç”¨è€…æ ˆå¸§å¼•ç”¨ï¼Œç”¨äºè¿”å›æ—¶æ¢å¤
- **ç¬¬32-38è¡Œ**: **å‚æ•°ä¼ é€’** - ä»è°ƒç”¨è€…æ ˆé¡¶å¼¹å‡ºå‚æ•°åˆ°å±€éƒ¨å˜é‡æ•°ç»„
- **ç¬¬52-57è¡Œ**: **è¾¹ç•Œæ£€æŸ¥** - é˜²æ­¢è®¿é—®è¶Šç•Œçš„å±€éƒ¨å˜é‡

**é˜¶æ®µäºŒ: å®ç°å‡½æ•°è°ƒç”¨æŒ‡ä»¤**

**å…³é”®ä»£ç ** (`CallInstruction.java`):

```java
public class CallInstruction extends Instruction {
    public CallInstruction() {
        super(0x30, "CALL", OpCodeCategory.CONTROL_FLOW);
    }

    @Override
    public void execute(VMExecutionContext context) {
        // 1. ä»æ“ä½œæ•°è¯»å–å‡½æ•°åœ°å€
        int functionAddr = context.readOperandInt();

        // 2. ä¿å­˜è¿”å›åœ°å€ï¼ˆå½“å‰PCçš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼‰
        int returnAddr = context.getPc();

        // 3. å‡†å¤‡è°ƒç”¨ä¸Šä¸‹æ–‡
        CallContext callCtx = new CallContext();
        callCtx.setReturnAddress(returnAddr);
        callCtx.setCallerContext(context);
        callCtx.setCallerFrame(context.getCurrentFrame());

        // 4. æŸ¥æ‰¾å‡½æ•°å®šä¹‰ï¼ˆä»å‡½æ•°è¡¨ï¼‰
        FunctionDefinition function = context.getFunctionTable().lookup(functionAddr);
        if (function == null) {
            throw new VMRuntimeException("Function not found at address: " + functionAddr);
        }

        // 5. åˆ›å»ºæ–°æ ˆå¸§
        StackFrame newFrame = new StackFrame(function.getName(), callCtx);
        context.pushFrame(newFrame);

        // 6. è·³è½¬åˆ°å‡½æ•°å…¥å£
        context.setPc(functionAddr);
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬10è¡Œ**: è¯»å–ç›®æ ‡å‡½æ•°åœ°å€
- **ç¬¬13è¡Œ**: ä¿å­˜è¿”å›åœ°å€
- **ç¬¬16-20è¡Œ**: æ„å»ºè°ƒç”¨ä¸Šä¸‹æ–‡
- **ç¬¬23-27è¡Œ**: æŸ¥æ‰¾å‡½æ•°å®šä¹‰
- **ç¬¬30è¡Œ**: åˆ›å»ºå¹¶å‹å…¥æ–°æ ˆå¸§
- **ç¬¬33è¡Œ**: è·³è½¬åˆ°å‡½æ•°å…¥å£ï¼ˆè®¾ç½®PCï¼‰

**é˜¶æ®µä¸‰: å®ç°è¿”å›æŒ‡ä»¤**

**å…³é”®ä»£ç ** (`RetInstruction.java`):

```java
public class RetInstruction extends Instruction {
    public RetInstruction() {
        super(0x31, "RET", OpCodeCategory.CONTROL_FLOW);
    }

    @Override
    public void execute(VMExecutionContext context) {
        StackFrame currentFrame = context.getCurrentFrame();

        // 1. æ£€æŸ¥æ˜¯å¦åœ¨mainå‡½æ•°ä¸­
        if (currentFrame.getCaller() == null) {
            // mainå‡½æ•°è¿”å›ï¼Œç¨‹åºç»“æŸ
            context.setPc(-1);  // è®¾ç½®PCä¸º-1è¡¨ç¤ºç»“æŸ
            return;
        }

        // 2. è·å–è¿”å›å€¼ï¼ˆä»æ ˆé¡¶ï¼‰
        int returnValue = context.pop();

        // 3. å¼¹å‡ºå½“å‰æ ˆå¸§
        context.popFrame();

        // 4. æ¢å¤è°ƒç”¨è€…æ ˆå¸§
        StackFrame callerFrame = context.getCurrentFrame();

        // 5. æ¢å¤PCåˆ°è¿”å›åœ°å€
        context.setPc(currentFrame.getReturnAddress());

        // 6. å°†è¿”å›å€¼å‹å…¥è°ƒç”¨è€…æ ˆ
        context.push(returnValue);
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬13-16è¡Œ**: ç‰¹æ®Šå¤„ç†mainå‡½æ•°çš„è¿”å›ï¼ˆç¨‹åºç»“æŸï¼‰
- **ç¬¬19è¡Œ**: ä»æ ˆé¡¶è·å–è¿”å›å€¼
- **ç¬¬22è¡Œ**: é”€æ¯å½“å‰æ ˆå¸§
- **ç¬¬25è¡Œ**: æ¢å¤åˆ°è°ƒç”¨è€…æ ˆå¸§
- **ç¬¬28è¡Œ**: è·³è½¬å›è¿”å›åœ°å€
- **ç¬¬31è¡Œ**: è¿”å›å€¼å‹å…¥è°ƒç”¨è€…æ ˆ

#### 4.3 å®è·µç»ƒä¹ 

**ç»ƒä¹ : é€’å½’å‡½æ•°**

**ä»»åŠ¡**: ç¼–å†™å­—èŠ‚ç å®ç°é˜¶ä¹˜å‡½æ•°

**æç¤º**:
```
å‡½æ•°: factorial(n)
  if (n <= 1) return 1
  return n * factorial(n - 1)

å­—èŠ‚ç ç»“æ„:
factorial:
  ILOAD 0        # åŠ è½½å‚æ•°n
  ICONST_1
  ICMP_LE        # n <= 1?
  CJMP base_case # è·³åˆ°åŸºæœ¬æƒ…å†µ

  # é€’å½’æƒ…å†µ
  ILOAD 0        # n
  ILOAD 0        # n
  ICONST_1
  ISUB           # n - 1
  CALL factorial # é€’å½’è°ƒç”¨
  IMUL           # n * factorial(n-1)
  RET

base_case:
  ICONST_1
  RET
```

---

#### ğŸ”„ ä»æœ¬ä¸»é¢˜åˆ°ä¸‹ä¸€ä¸»é¢˜

**è¿æ¥ä»£ç **:

```java
// Topic 4 æä¾›: æ ˆå¸§å’Œå‡½æ•°è°ƒç”¨æœºåˆ¶
public class CallInstruction extends Instruction {
    @Override
    public void execute(VMExecutionContext context) {
        // åˆ›å»ºæ–°æ ˆå¸§
        StackFrame newFrame = new StackFrame(function.getName(), callCtx);
        context.pushFrame(newFrame);

        // è·³è½¬åˆ°å‡½æ•°å…¥å£
        context.setPc(functionAddr);
    }
}

// â†’ Topic 5 ä½¿ç”¨: å®Œæ•´çš„VMæ‰§è¡Œå¾ªç¯
public class CymbolStackVM {
    public void cpu() {
        while (running) {
            int opcode = bytecode[pc];
            Instruction instr = factory.getInstruction(opcode);
            instr.execute(context);  // å¯èƒ½è§¦å‘å‡½æ•°è°ƒç”¨
        }
    }
}
```

**å…³ç³»è¯´æ˜**:
- Topic 4 çš„ `CallInstruction` å’Œ `RetInstruction` å®ç°å‡½æ•°è°ƒç”¨
- Topic 5 çš„ `CymbolStackVM` æä¾›æ‰§è¡Œå¾ªç¯
- æ ˆå¸§ç®¡ç†æ˜¯VMæ‰§è¡Œçš„æ ¸å¿ƒæœºåˆ¶

---

### ä¸»é¢˜5: å®Œæ•´VMé›†æˆ

#### ğŸ“ åœ¨EP18ä¸­çš„ä½ç½®
```
Layer 3-5: Execution + Data + Application
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Topic 5: å®Œæ•´VMé›†æˆ       â”‚
â”‚  â”œâ”€ CymbolStackVM          â”‚
â”‚  â”œâ”€ VMInterpreter          â”‚
â”‚  â””â”€ VMRunner              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†‘ æ•´åˆTopic 1-4
         â†“ å®Œæ•´åº”ç”¨
```

#### ğŸ”— ä¾èµ–å…³ç³»
- **å‰ç½®ä¾èµ–**: Topic 1-4 (æ‰€æœ‰ä¸»é¢˜)
- **åŠŸèƒ½**: æ•´åˆæ‰€æœ‰ç»„ä»¶ï¼Œå±•ç¤ºå®Œæ•´çš„VM

#### 5.1 æ ¸å¿ƒæ¦‚å¿µ

**æ¦‚å¿µ1: VMçš„æ‰§è¡Œå¾ªç¯**

VMçš„æ ¸å¿ƒæ˜¯**å–æŒ‡-æ‰§è¡Œå¾ªç¯**ï¼ˆFetch-Execute Cycleï¼‰ï¼š
1. **å–æŒ‡**: ä»PCä½ç½®è¯»å–æ“ä½œç 
2. **è¯‘ç **: è§£ææ“ä½œæ•°
3. **æ‰§è¡Œ**: è°ƒç”¨æŒ‡ä»¤çš„executeæ–¹æ³•
4. **æ›´æ–°**: æ›´æ–°PCåˆ°ä¸‹ä¸€æ¡æŒ‡ä»¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PCæŒ‡å‘æŒ‡ä»¤1  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¯»å–æ“ä½œç    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æŸ¥æ‰¾æŒ‡ä»¤å¯¹è±¡ â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ‰§è¡ŒæŒ‡ä»¤     â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ›´æ–°PC       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
   â”Œâ”€â”€â”€â”€â”€â”
   â”‚å¾ªç¯? â”‚
   â””â”€â”€â”¬â”€â”€â”˜
     æ˜¯â”‚ å¦
      â†“  â†“
    ä¸‹ä¸€â”‚åœæ­¢
    æŒ‡ä»¤
```

**æ¦‚å¿µ2: è§£é‡Šå™¨æ¨¡å¼çš„å®Œæ•´å®ç°**

è§£é‡Šå™¨æ¨¡å¼ï¼ˆInterpreter Patternï¼‰åœ¨EP18çš„ä½“ç°ï¼š
- **è¯­æ³•**: å­—èŠ‚ç æŒ‡ä»¤åºåˆ—
- **è§£é‡Šå™¨**: CymbolStackVM
- **æ‰§è¡Œ**: é€æ¡è§£é‡Šæ‰§è¡Œå­—èŠ‚ç 

#### 5.2 å®ç°åŸç†

**é˜¶æ®µä¸€: å®ç°æ ¸å¿ƒæ‰§è¡Œå¼•æ“**

**å…³é”®ä»£ç ** (`CymbolStackVM.java:131-210`):

```java
public void cpu() {
    while (true) {
        // 1. å–æŒ‡: ä»å½“å‰PCä½ç½®è¯»å–æŒ‡ä»¤
        int pc = context.getPc();
        if (pc < 0 || pc >= bytecode.length) {
            throw new VMRuntimeException("Program counter out of bounds: " + pc);
        }

        int opcode = bytecode[pc] & 0xFF;  // è¯»å–æ“ä½œç 
        Instruction instr = InstructionFactory.getInstance().getInstruction(opcode);

        if (instr == null) {
            throw new VMRuntimeException("Unknown opcode: " + opcode + " at PC=" + pc);
        }

        // 2. è¯‘ç : è§£ææ“ä½œæ•°
        context.setPc(pc + 1);  // PCæŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤

        // 3. æ‰§è¡Œ: è°ƒç”¨æŒ‡ä»¤çš„executeæ–¹æ³•
        try {
            instr.execute(context);

            // 4. è°ƒè¯•è¾“å‡ºï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (traceEnabled) {
                trace(instr, pc);
            }

            // æ£€æŸ¥æ˜¯å¦é‡åˆ°HALTæŒ‡ä»¤
            if (context.getPc() == -1) {
                break;  // ç¨‹åºæ­£å¸¸ç»“æŸ
            }

        } catch (VMRuntimeException e) {
            // è¿è¡Œæ—¶å¼‚å¸¸å¤„ç†
            System.err.println("Runtime error at PC=" + pc + ": " + e.getMessage());
            throw e;
        }
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬7-11è¡Œ**: **è¾¹ç•Œæ£€æŸ¥** - é˜²æ­¢PCè¶Šç•Œè®¿é—®
- **ç¬¬13è¡Œ**: **å–æŒ‡** - è¯»å–å½“å‰æ“ä½œç 
- **ç¬¬15-20è¡Œ**: **æŒ‡ä»¤æŸ¥æ‰¾** - ä»å·¥å‚è·å–æŒ‡ä»¤å¯¹è±¡
- **ç¬¬23è¡Œ**: **æ›´æ–°PC** - æŒ‡å‘ä¸‹ä¸€æŒ‡ä»¤
- **ç¬¬26è¡Œ**: **æŒ‡ä»¤æ‰§è¡Œ** - ç­–ç•¥æ¨¡å¼ï¼Œæ¯æ¡æŒ‡ä»¤è‡ªå·±å®ç°é€»è¾‘
- **ç¬¬29-32è¡Œ**: **è°ƒè¯•æ”¯æŒ** - å•æ­¥è·Ÿè¸ª
- **ç¬¬35-37è¡Œ**: **ç¨‹åºç»“æŸæ£€æŸ¥**
- **ç¬¬39-43è¡Œ**: **å¼‚å¸¸å¤„ç†**

**é˜¶æ®µäºŒ: å®ç°å®Œæ•´çš„åº”ç”¨å…¥å£**

**å…³é”®ä»£ç ** (`VMInterpreter.java`):

```java
public class VMInterpreter {
    public static void main(String[] args) {
        try {
            // 1. é…ç½®VM
            VMConfig config = new VMConfig.Builder()
                .maxStackSize(1024)
                .maxHeapSize(4096)
                .traceEnabled(true)
                .build();

            // 2. åˆ›å»ºVMå®ä¾‹
            CymbolStackVM vm = new CymbolStackVM(config);

            // 3. åŠ è½½å­—èŠ‚ç æ–‡ä»¶
            if (args.length > 0) {
                vm.loadProgram(args[0]);
            } else {
                // ä½¿ç”¨é»˜è®¤å­—èŠ‚ç 
                int[] defaultBytecode = {
                    0x10, 0x01,  // ICONST_1
                    0x10, 0x02,  // ICONST_2
                    0x10,        // IADD
                    0x00         // HALT
                };
                vm.loadBytecode(defaultBytecode);
            }

            // 4. æ‰§è¡Œç¨‹åº
            System.out.println("=== Starting VM ===");
            vm.run();

            // 5. è¾“å‡ºç»“æœ
            System.out.println("=== Program finished ===");
            System.out.println("Result: " + vm.getTopOfStack());

        } catch (Exception e) {
            System.err.println("VM Error: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

**ä»£ç è§£æ**:
- **ç¬¬9-14è¡Œ**: ä½¿ç”¨Builderæ¨¡å¼é…ç½®VM
- **ç¬¬17è¡Œ**: åˆ›å»ºVMå®ä¾‹
- **ç¬¬20-29è¡Œ**: åŠ è½½å­—èŠ‚ç æ–‡ä»¶æˆ–ä½¿ç”¨é»˜è®¤å­—èŠ‚ç 
- **ç¬¬32è¡Œ**: è¿è¡ŒVM
- **ç¬¬38è¡Œ**: è¾“å‡ºç»“æœï¼ˆæ ˆé¡¶å€¼ï¼‰

#### 5.3 å®è·µç»ƒä¹ 

**ç»¼åˆç»ƒä¹ : å®ç°å®Œæ•´VM**

**ä»»åŠ¡**: æ•´åˆæ‰€æœ‰ç»„ä»¶ï¼Œå®ç°ä¸€ä¸ªæ”¯æŒé€’å½’å‡½æ•°çš„VM

**åŠŸèƒ½è¦æ±‚**:
1. [ ] å®Œæ•´çš„æŒ‡ä»¤é›†ï¼ˆç®—æœ¯ã€æ¯”è¾ƒã€å†…å­˜ã€æ§åˆ¶æµï¼‰
2. [ ] æ ˆå¸§ç®¡ç†å’Œå‡½æ•°è°ƒç”¨
3. [ ] é€’å½’å‡½æ•°æ”¯æŒ
4. [ ] é”™è¯¯æ£€æµ‹å’Œå¤„ç†

**æµ‹è¯•ç”¨ä¾‹**:
```
// é˜¶ä¹˜å‡½æ•°
è¾“å…¥: factorial(5)
é¢„æœŸ: 120

// æ–æ³¢é‚£å¥‘æ•°åˆ—
è¾“å…¥: fib(10)
é¢„æœŸ: 55
```

**å®ç°æ¡†æ¶**:
```java
public class CompleteVM {
    public static void main(String[] args) {
        // 1. é…ç½®VM
        VMConfig config = new VMConfig.Builder()
            .maxStackSize(2048)
            .traceEnabled(true)
            .build();

        // 2. åˆ›å»ºVM
        CymbolStackVM vm = new CymbolStackVM(config);

        // 3. åŠ è½½å­—èŠ‚ç 
        vm.loadProgram("factorial.vm");

        // 4. æ‰§è¡Œ
        vm.run();

        // 5. è¾“å‡ºç»“æœ
        System.out.println("Result: " + vm.getTopOfStack());
    }
}
```

---

## ğŸ¯ ç¬¬ä¸‰å±‚ï¼šç»¼åˆå®æˆ˜é¡¹ç›®

### é¡¹ç›®: æ„å»ºæ”¯æŒé€’å½’çš„æ ˆå¼è™šæ‹Ÿæœº

**é¡¹ç›®æè¿°**: ç»¼åˆè¿ç”¨EP18çš„æ‰€æœ‰çŸ¥è¯†ï¼Œæ„å»ºä¸€ä¸ªå®Œæ•´çš„æ ˆå¼è™šæ‹Ÿæœº

**åŠŸèƒ½éœ€æ±‚**:
1. [ ] å®Œæ•´çš„æŒ‡ä»¤é›†å®ç°ï¼ˆè‡³å°‘20æ¡æŒ‡ä»¤ï¼‰
2. [ ] æ ˆå¸§ç®¡ç†å’Œå‡½æ•°è°ƒç”¨
3. [ ] ABIè§„èŒƒå®ç°
4. [ ] é€’å½’å‡½æ•°æ”¯æŒ
5. [ ] å†…å­˜ç®¡ç†å’ŒGC
6. [ ] é”™è¯¯æ£€æµ‹å’Œå¤„ç†

**æŠ€æœ¯è¦æ±‚**:
- å®ç°ç­–ç•¥æ¨¡å¼ï¼ˆæŒ‡ä»¤æ¥å£ï¼‰
- å®ç°å·¥å‚æ¨¡å¼ï¼ˆæŒ‡ä»¤åˆ›å»ºï¼‰
- å®ç°çŠ¶æ€æ¨¡å¼ï¼ˆä¸Šä¸‹æ–‡ç®¡ç†ï¼‰
- å®ç°è§£é‡Šå™¨æ¨¡å¼ï¼ˆVMæ‰§è¡Œï¼‰

**å®ç°æ­¥éª¤**:

**é˜¶æ®µ1: æ‰©å±•æŒ‡ä»¤é›†**
```java
// å®ç°æ‰€æœ‰ç®—æœ¯æŒ‡ä»¤
- IAddInstruction, ISubInstruction, IMulInstruction, IDivInstruction
- INegInstruction, IAbsInstruction

// å®ç°æ‰€æœ‰æ¯”è¾ƒæŒ‡ä»¤
- ILtInstruction, ILeInstruction, IGtInstruction, IGeInstruction
- IEqInstruction, INeqInstruction

// å®ç°æ‰€æœ‰å†…å­˜æŒ‡ä»¤
- ILoadInstruction, IStoreInstruction
- IConst_0Instruction, IConst_1Instruction, ...
```

**é˜¶æ®µ2: å®ç°æ ˆå¸§ç®¡ç†**
```java
public class AdvancedStackFrame extends StackFrame {
    private final Map<String, Integer> variableTable;

    public AdvancedStackFrame(String functionName, CallContext callCtx) {
        super(functionName, callCtx);
        this.variableTable = new HashMap<>();
    }

    public void setVariable(String name, int value) {
        variableTable.put(name, value);
    }

    public int getVariable(String name) {
        if (!variableTable.containsKey(name)) {
            throw new VMRuntimeException("Variable not found: " + name);
        }
        return variableTable.get(name);
    }
}
```

**é˜¶æ®µ3: å®ç°å‡½æ•°è¡¨**
```java
public class FunctionTable {
    private final Map<String, FunctionDefinition> functions;

    public void register(String name, int address, int paramCount) {
        FunctionDefinition func = new FunctionDefinition(name, address, paramCount);
        functions.put(name, func);
    }

    public FunctionDefinition lookup(String name) {
        return functions.get(name);
    }
}
```

**é˜¶æ®µ4: å®ç°å®Œæ•´çš„VM**
```java
public class CompleteVM {
    public static void main(String[] args) {
        // 1. é…ç½®
        VMConfig config = new VMConfig.Builder()
            .maxStackSize(4096)
            .maxHeapSize(8192)
            .traceEnabled(true)
            .build();

        // 2. åˆ›å»ºVMå’Œä¸Šä¸‹æ–‡
        CymbolStackVM vm = new CymbolStackVM(config);
        VMExecutionContext context = new VMExecutionContext(config);

        // 3. æ³¨å†Œå†…ç½®å‡½æ•°
        FunctionTable functionTable = new FunctionTable();
        functionTable.register("factorial", 0x0100, 1);
        functionTable.register("fibonacci", 0x0200, 1);
        context.setFunctionTable(functionTable);

        // 4. åŠ è½½å­—èŠ‚ç 
        vm.loadProgram("test.vm");

        // 5. æ‰§è¡Œ
        vm.run();
    }
}
```

**æµ‹è¯•ç”¨ä¾‹**:
```
// æµ‹è¯•1: é˜¶ä¹˜å‡½æ•°
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
factorial(5)
// é¢„æœŸ: 120

// æµ‹è¯•2: æ–æ³¢é‚£å¥‘æ•°åˆ—
function fib(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
fib(10)
// é¢„æœŸ: 55

// æµ‹è¯•3: åµŒå¥—è°ƒç”¨
function add(a, b) {
    return a + b;
}
function multiply(x, y) {
    return x * y;
}
multiply(add(2, 3), add(4, 5))
// é¢„æœŸ: 45
```

---

## ğŸ“– è®¾è®¡æ¨¡å¼æ€»ç»“

æœ¬EPæ¶‰åŠçš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼ï¼š

1. **Strategy Pattern**:
   - `Instruction` æ¥å£å®šä¹‰æ‰§è¡Œç­–ç•¥
   - æ¯æ¡æŒ‡ä»¤æ˜¯ä¸€ä¸ªå…·ä½“ç­–ç•¥

2. **Factory Pattern**:
   - `InstructionFactory` åˆ›å»ºæŒ‡ä»¤å®ä¾‹
   - å•ä¾‹æ¨¡å¼ç®¡ç†æŒ‡ä»¤ç¼“å­˜

3. **Builder Pattern**:
   - `VMConfig.Builder` æ„å»ºå¤æ‚é…ç½®
   - `StackFrame` ä½¿ç”¨å»ºé€ è€…åˆ›å»º

4. **Command Pattern**:
   - æŒ‡ä»¤å°è£…äº†æ“ä½œå’Œä¸Šä¸‹æ–‡
   - `execute()` æ–¹æ³•å°è£…è¯·æ±‚

5. **Interpreter Pattern**:
   - VMè§£é‡Šæ‰§è¡Œå­—èŠ‚ç 
   - å–æŒ‡-æ‰§è¡Œå¾ªç¯

6. **State Pattern**:
   - `VMExecutionContext` ç®¡ç†VMçŠ¶æ€
   - æ ˆå¸§åˆ‡æ¢æ”¹å˜çŠ¶æ€

7. **Adapter Pattern**:
   - `VMExecutionContext` é€‚é…çŠ¶æ€åˆ°æŒ‡ä»¤æ¥å£

---

## âœ… æ£€æŸ¥ç‚¹

å®Œæˆæœ¬EPåï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] è§£é‡Šè™šæ‹Ÿæœºåœ¨ç¼–è¯‘å™¨åç«¯çš„ä½œç”¨
- [ ] ç†è§£æ ˆå¼VMçš„æ‰§è¡Œæ¨¡å‹ï¼ˆæ“ä½œæ•°æ ˆã€æ ˆå¸§ï¼‰
- [ ] å®ç°åŸºæœ¬çš„ç®—æœ¯æŒ‡ä»¤
- [ ] å®ç°å‡½æ•°è°ƒç”¨å’Œè¿”å›æœºåˆ¶
- [ ] ç†è§£ABIè§„èŒƒçš„ä½œç”¨
- [ ] å®ç°æ¡ä»¶è·³è½¬å’Œå¾ªç¯
- [ ] å¤„ç†åŸºæœ¬çš„è¿è¡Œæ—¶å¼‚å¸¸
- [ ] ç†è§£äº”å±‚æ¶æ„çš„è®¾è®¡æ€æƒ³
- [ ] ç»¼åˆè¿ç”¨7ç§è®¾è®¡æ¨¡å¼

---

## ğŸ“ ä¸‹ä¸€æ­¥

- **å¯¹æ¯”å­¦ä¹ **: [EP18R_æ•™å­¦æ–‡æ¡£.md](./EP18R_æ•™å­¦æ–‡æ¡£.md) - å¯„å­˜å™¨è™šæ‹Ÿæœº
- **å®Œæ•´ç¼–è¯‘å™¨**: [EP19_æ•™å­¦æ–‡æ¡£.md](./EP19_æ•™å­¦æ–‡æ¡£.md) - ä»æºä»£ç åˆ°å­—èŠ‚ç çš„å®Œæ•´ç®¡çº¿
- **ä¼˜åŒ–æŠ€æœ¯**: [EP21_æ•™å­¦æ–‡æ¡£.md](./EP21_æ•™å­¦æ–‡æ¡£.md) - ä»£ç ç”Ÿæˆä¼˜åŒ–

---

*ç‰ˆæœ¬: v3.0-three-layer | EP18æ•™å­¦æ–‡æ¡£ | 2025-12-27*
