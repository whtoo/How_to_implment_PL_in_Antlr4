# EP20 寄存器分配设计规范

**版本**: v1.0 | **状态**: 已通过 | **最后更新**: 2026-01-09

## 1. 设计概述

### 1.1 设计目标
EP20寄存器分配模块旨在为Cymbol编译器提供高效的寄存器分配解决方案，支持多种分配算法，优化代码执行性能，并与现有编译流程无缝集成。

### 1.2 核心特性
- **多算法支持**: 支持线性扫描、图着色、启发式等多种分配算法
- **架构无关**: 支持栈式虚拟机(EP18)和寄存器虚拟机(EP18R)双目标
- **增量分配**: 支持基本块级别的增量寄存器分配
- **调试支持**: 提供分配过程可视化和性能分析工具

## 2. 技术架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                  寄存器分配架构                             │
├─────────────────────────────────────────────────────────────┤
│  算法层 (Algorithm Layer)                                  │
│  ├── 线性扫描分配器 (LinearScanAllocator)                  │
│  ├── 图着色分配器 (GraphColoringAllocator)                  │
│  └── 启发式分配器 (HeuristicAllocator)                      │
├─────────────────────────────────────────────────────────────┤
│  抽象层 (Abstraction Layer)                                │
│  ├── 寄存器分配器接口 (RegisterAllocator)                    │
│  ├── 干涉图构建器 (InterferenceGraphBuilder)                │
│  └── 活性分析器 (LivenessAnalyzer)                          │
├─────────────────────────────────────────────────────────────┤
│  数据层 (Data Layer)                                       │
│  ├── 虚拟寄存器 (VirtualRegister)                           │
│  ├── 物理寄存器 (PhysicalRegister)                          │
│  └── 寄存器组 (RegisterBank)                               │
├─────────────────────────────────────────────────────────────┤
│  集成层 (Integration Layer)                                │
│  └── 分配器管理器 (AllocatorManager)                        │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件设计

#### 2.2.1 寄存器分配器接口

```java
/**
 * 寄存器分配器通用接口
 * 定义所有分配算法必须实现的基本操作
 */
public interface RegisterAllocator {
    
    /**
     * 执行寄存器分配
     * @param cfg 控制流图，包含需要分配的代码
     * @param registerBank 可用的物理寄存器组
     * @return 分配结果映射
     */
    AllocationResult allocate(CFG<IRNode> cfg, RegisterBank registerBank);
    
    /**
     * 获取分配器名称
     */
    String getName();
    
    /**
     * 获取分配器描述
     */
    String getDescription();
    
    /**
     * 设置分配参数
     */
    void setParameters(AllocationParameters params);
    
    /**
     * 检查是否支持目标架构
     */
    boolean supportsTarget(TargetArchitecture target);
}
```

#### 2.2.2 虚拟寄存器设计

```java
/**
 * 虚拟寄存器表示
 * 在IR中使用的逻辑寄存器，需要映射到物理寄存器
 */
public class VirtualRegister {
    private final String name;           // 寄存器名称 (如: t0, t1)
    private final Type type;             // 寄存器类型 (int, float等)
    private final int size;              // 寄存器大小 (bit数)
    private final Set<Instruction> defs; // 定义点集合
    private final Set<Instruction> uses; // 使用点集合
    private LiveInterval liveInterval;   // 生命周期区间
    
    // 构建器模式构造函数
    private VirtualRegister(Builder builder) {
        this.name = builder.name;
        this.type = builder.type;
        this.size = builder.size;
        this.defs = Collections.unmodifiableSet(builder.defs);
        this.uses = Collections.unmodifiableSet(builder.uses);
        this.liveInterval = builder.liveInterval;
    }
    
    /**
     * 获取寄存器生命周期
     */
    public LiveInterval getLiveInterval() {
        return liveInterval;
    }
    
    /**
     * 检查是否与另一个寄存器生命周期重叠
     */
    public boolean overlaps(VirtualRegister other) {
        return this.liveInterval.overlaps(other.liveInterval);
    }
    
    /**
     * 获取寄存器的干涉度（与其他寄存器的重叠数量）
     */
    public int getInterferenceDegree(List<VirtualRegister> others) {
        return (int) others.stream()
                .filter(other -> !other.equals(this))
                .filter(other -> this.overlaps(other))
                .count();
    }
}
```

#### 2.2.3 物理寄存器设计

```java
/**
 * 物理寄存器表示
 * 目标架构的实际寄存器资源
 */
public class PhysicalRegister {
    private final String name;           // 寄存器名称 (如: r0, r1)
    private final int number;            // 寄存器编号
    private final Type type;             // 寄存器类型
    private final int size;              // 寄存器大小
    private final Set<String> aliases;   // 别名集合（如：r0别名a1）
    private final boolean isReserved;    // 是否为保留寄存器
    private final boolean isCalleeSaved; // 是否需要被调用者保存
    private final int priority;          // 分配优先级
    
    /**
     * 检查是否可用于分配
     */
    public boolean isAvailable() {
        return !isReserved && !isAllocated;
    }
    
    /**
     * 获取寄存器成本（用于启发式分配）
     */
    public int getAllocationCost() {
        int cost = 0;
        if (isCalleeSaved) cost += 10;  // 被调用者保存寄存器成本较高
        if (!aliases.isEmpty()) cost += 5; // 有别名的寄存器成本
        return cost;
    }
}
```

## 3. 算法实现细节

### 3.1 线性扫描算法

#### 3.1.1 算法原理

线性扫描算法按程序点顺序扫描，为每个活跃区间分配寄存器：

```java
/**
 * 线性扫描寄存器分配器实现
 */
public class LinearScanAllocator implements RegisterAllocator {
    
    @Override
    public AllocationResult allocate(CFG<IRNode> cfg, RegisterBank registerBank) {
        // 1. 计算生命周期区间
        List<LiveInterval> intervals = computeLiveIntervals(cfg);
        
        // 2. 按开始位置排序
        intervals.sort(Comparator.comparingInt(LiveInterval::getStart));
        
        // 3. 初始化活跃集合和空闲寄存器列表
        Set<LiveInterval> active = new TreeSet<>();
        Queue<PhysicalRegister> freeRegisters = new PriorityQueue<>(
            registerBank.getAvailableRegisters()
        );
        
        // 4. 线性扫描分配
        Map<VirtualRegister, PhysicalRegister> allocation = new HashMap<>();
        
        for (LiveInterval interval : intervals) {
            // 4.1 检查并移除已结束的活跃区间
            expireOldIntervals(interval, active, freeRegisters);
            
            // 4.2 如果无空闲寄存器，溢出最远的活跃区间
            if (freeRegisters.isEmpty()) {
                spillAtInterval(interval, active, freeRegisters, allocation);
            }
            
            // 4.3 分配寄存器
            PhysicalRegister reg = freeRegisters.poll();
            allocation.put(interval.getRegister(), reg);
            active.add(interval);
        }
        
        return new AllocationResult(allocation, registerBank.getTarget());
    }
    
    /**
     * 移除已结束的生命周期区间
     */
    private void expireOldIntervals(LiveInterval current, 
                                   Set<LiveInterval> active,
                                   Queue<PhysicalRegister> freeRegisters) {
        Iterator<LiveInterval> it = active.iterator();
        while (it.hasNext()) {
            LiveInterval interval = it.next();
            if (interval.getEnd() >= current.getStart()) {
                break; // 按结束位置排序，后续区间都还未结束
            }
            // 释放寄存器
            PhysicalRegister reg = allocation.get(interval.getRegister());
            freeRegisters.offer(reg);
            it.remove();
        }
    }
}
```

#### 3.1.2 生命周期计算

```java
/**
 * 生命周期区间计算
 */
public class LiveIntervalComputer {
    
    public List<LiveInterval> computeLiveIntervals(CFG<IRNode> cfg) {
        Map<VirtualRegister, LiveInterval> intervals = new HashMap<>();
        int position = 0;
        
        // 遍历所有基本块
        for (BasicBlock<IRNode> block : cfg.getBlocks()) {
            // 为每个指令计算位置
            for (IRNode instr : block.getInstructions()) {
                // 处理使用点
                for (Operand use : instr.getUses()) {
                    if (use.isVirtual()) {
                        VirtualRegister reg = use.getRegister();
                        LiveInterval interval = intervals.get(reg);
                        if (interval != null) {
                            interval.addUse(position);
                        }
                    }
                }
                
                // 处理定义点
                if (instr.hasDef()) {
                    Operand def = instr.getDef();
                    if (def.isVirtual()) {
                        VirtualRegister reg = def.getRegister();
                        LiveInterval interval = intervals.computeIfAbsent(
                            reg, k -> new LiveInterval(reg)
                        );
                        interval.addDef(position);
                    }
                }
                
                position++;
            }
        }
        
        return new ArrayList<>(intervals.values());
    }
}
```

### 3.2 图着色算法

#### 3.2.1 干涉图构建

```java
/**
 * 干涉图构建器
 */
public class InterferenceGraphBuilder {
    
    public InterferenceGraph build(CFG<IRNode> cfg) {
        InterferenceGraph graph = new InterferenceGraph();
        
        // 1. 收集所有虚拟寄存器
        Set<VirtualRegister> registers = collectVirtualRegisters(cfg);
        
        // 2. 为每个基本块构建干涉关系
        for (BasicBlock<IRNode> block : cfg.getBlocks()) {
            buildBlockInterference(block, graph);
        }
        
        // 3. 处理全局干涉关系（跨基本块）
        buildGlobalInterference(cfg, graph);
        
        return graph;
    }
    
    /**
     * 构建基本块内的干涉关系
     */
    private void buildBlockInterference(BasicBlock<IRNode> block, 
                                       InterferenceGraph graph) {
        // 获取基本块的活跃变量集合
        Set<VirtualRegister> live = new HashSet<>(block.getLiveOut());
        
        // 逆序遍历指令
        List<IRNode> instructions = block.getInstructions();
        for (int i = instructions.size() - 1; i >= 0; i--) {
            IRNode instr = instructions.get(i);
            
            // 处理定义点：定义变量与所有活跃变量干涉
            if (instr.hasDef()) {
                VirtualRegister def = instr.getDef().getRegister();
                for (VirtualRegister liveReg : live) {
                    graph.addEdge(def, liveReg);
                }
                // 定义后变量不再活跃
                live.remove(def);
            }
            
            // 处理使用点：使用变量变为活跃
            for (Operand use : instr.getUses()) {
                if (use.isVirtual()) {
                    live.add(use.getRegister());
                }
            }
        }
    }
}
```

#### 3.2.2 图着色算法

```java
/**
 * 图着色寄存器分配器
 */
public class GraphColoringAllocator implements RegisterAllocator {
    
    @Override
    public AllocationResult allocate(CFG<IRNode> cfg, RegisterBank registerBank) {
        // 1. 构建干涉图
        InterferenceGraph graph = buildInterferenceGraph(cfg);
        
        // 2. 简化干涉图（移除低度节点）
        Stack<VirtualRegister> stack = simplifyGraph(graph, registerBank.size());
        
        // 3. 选择阶段（重新插入节点并着色）
        Map<VirtualRegister, PhysicalRegister> coloring = 
            selectColors(stack, graph, registerBank);
        
        // 4. 处理溢出
        if (coloring.size() < graph.getVertices().size()) {
            handleSpilling(graph, coloring, registerBank);
        }
        
        return new AllocationResult(coloring, registerBank.getTarget());
    }
    
    /**
     * 简化干涉图
     */
    private Stack<VirtualRegister> simplifyGraph(InterferenceGraph graph, int k) {
        Stack<VirtualRegister> stack = new Stack<>();
        Set<VirtualRegister> removed = new HashSet<>();
        
        while (!graph.getVertices().isEmpty()) {
            // 找到度数小于k的节点
            VirtualRegister lowDegreeNode = findLowDegreeNode(graph, k);
            
            if (lowDegreeNode != null) {
                // 移除该节点
                graph.removeVertex(lowDegreeNode);
                removed.add(lowDegreeNode);
            } else {
                // 没有找到低度节点，需要潜在溢出
                VirtualRegister spillNode = selectSpillNode(graph);
                graph.removeVertex(spillNode);
                removed.add(spillNode);
            }
        }
        
        // 构建选择栈
        for (VirtualRegister reg : removed) {
            stack.push(reg);
        }
        
        return stack;
    }
}
```

## 4. API设计规范

### 4.1 分配器管理器

```java
/**
 * 寄存器分配器管理器
 * 统一管理所有分配算法，提供一致的分配接口
 */
public class AllocatorManager {
    private final Map<String, RegisterAllocator> allocators;
    private final RegisterBank registerBank;
    private String defaultAllocator;
    
    public AllocatorManager(RegisterBank registerBank) {
        this.registerBank = registerBank;
        this.allocators = new HashMap<>();
        initializeAllocators();
    }
    
    /**
     * 初始化可用的分配器
     */
    private void initializeAllocators() {
        // 注册线性扫描分配器
        allocators.put("linear-scan", new LinearScanAllocator());
        
        // 注册图着色分配器
        allocators.put("graph-coloring", new GraphColoringAllocator());
        
        // 注册启发式分配器
        allocators.put("heuristic", new HeuristicAllocator());
        
        // 设置默认分配器
        this.defaultAllocator = "linear-scan";
    }
    
    /**
     * 执行寄存器分配
     */
    public AllocationResult allocate(CFG<IRNode> cfg) {
        RegisterAllocator allocator = allocators.get(defaultAllocator);
        if (allocator == null) {
            throw new IllegalStateException("No allocator available: " + defaultAllocator);
        }
        
        return allocator.allocate(cfg, registerBank);
    }
    
    /**
     * 使用指定分配器进行分配
     */
    public AllocationResult allocate(CFG<IRNode> cfg, String allocatorName) {
        RegisterAllocator allocator = allocators.get(allocatorName);
        if (allocator == null) {
            throw new IllegalArgumentException("Unknown allocator: " + allocatorName);
        }
        
        return allocator.allocate(cfg, registerBank);
    }
}
```

### 4.2 分配结果表示

```java
/**
 * 寄存器分配结果
 */
public class AllocationResult {
    private final Map<VirtualRegister, PhysicalRegister> allocation;
    private final TargetArchitecture target;
    private final List<SpillSlot> spillSlots;
    private final Map<String, Object> statistics;
    
    public AllocationResult(Map<VirtualRegister, PhysicalRegister> allocation,
                           TargetArchitecture target) {
        this.allocation = Collections.unmodifiableMap(allocation);
        this.target = target;
        this.spillSlots = new ArrayList<>();
        this.statistics = new HashMap<>();
        computeStatistics();
    }
    
    /**
     * 获取虚拟寄存器到物理寄存器的映射
     */
    public PhysicalRegister getPhysicalRegister(VirtualRegister vreg) {
        return allocation.get(vreg);
    }
    
    /**
     * 检查分配是否成功
     */
    public boolean isSuccessful() {
        return !allocation.isEmpty();
    }
    
    /**
     * 获取分配统计信息
     */
    public Map<String, Object> getStatistics() {
        return Collections.unmodifiableMap(statistics);
    }
    
    /**
     * 生成分配报告
     */
    public String generateReport() {
        StringBuilder report = new StringBuilder();
        report.append("Register Allocation Report\n");
        report.append("=========================\n");
        report.append("Target: ").append(target.getName()).append("\n");
        report.append("Total Virtual Registers: ").append(allocation.size()).append("\n");
        report.append("Spill Slots: ").append(spillSlots.size()).append("\n");
        
        if (!statistics.isEmpty()) {
            report.append("\nStatistics:\n");
            for (Map.Entry<String, Object> entry : statistics.entrySet()) {
                report.append("  ").append(entry.getKey())
                      .append(": ").append(entry.getValue()).append("\n");
            }
        }
        
        return report.toString();
    }
}
```

## 5. 测试策略

### 5.1 单元测试

```java
/**
 * 线性扫描分配器单元测试
 */
public class LinearScanAllocatorTest {
    
    @Test
    public void testSimpleAllocation() {
        // 创建测试CFG
        CFG<IRNode> cfg = createSimpleCFG();
        RegisterBank registerBank = createRegisterBank(4); // 4个寄存器
        
        // 执行分配
        LinearScanAllocator allocator = new LinearScanAllocator();
        AllocationResult result = allocator.allocate(cfg, registerBank);
        
        // 验证分配结果
        assertTrue(result.isSuccessful());
        assertEquals(3, result.getAllocation().size()); // 3个虚拟寄存器
        
        // 验证没有溢出
        assertTrue(result.getSpillSlots().isEmpty());
    }
    
    @Test
    public void testSpilling() {
        // 创建需要溢出的CFG（寄存器需求超过可用数量）
        CFG<IRNode> cfg = createSpillCFG();
        RegisterBank registerBank = createRegisterBank(2); // 只有2个寄存器
        
        // 执行分配
        LinearScanAllocator allocator = new LinearScanAllocator();
        AllocationResult result = allocator.allocate(cfg, registerBank);
        
        // 验证分配成功但有溢出
        assertTrue(result.isSuccessful());
        assertFalse(result.getSpillSlots().isEmpty());
    }
}
```

### 5.2 集成测试

```java
/**
 * 寄存器分配集成测试
 */
public class RegisterAllocationIntegrationTest {
    
    @Test
    public void testFullCompilationWithAllocation() {
        // 完整的Cymbol程序
        String source = """
            int test(int a, int b) {
                int c = a + b;
                int d = c * 2;
                int e = d - 1;
                return e;
            }
            """;
        
        // 编译到IR
        Compiler compiler = new Compiler();
        IRProgram ir = compiler.compileToIR(source);
        
        // 构建CFG
        CFGBuilder cfgBuilder = new CFGBuilder();
        CFG<IRNode> cfg = cfgBuilder.build(ir);
        
        // 寄存器分配
        AllocatorManager manager = new AllocatorManager(createRegisterBank());
        AllocationResult result = manager.allocate(cfg);
        
        // 验证分配结果
        assertTrue(result.isSuccessful());
        
        // 验证生成的代码
        String assembly = generateAssembly(cfg, result);
        assertNotNull(assembly);
        assertFalse(assembly.isEmpty());
    }
}
```

## 6. 性能优化

### 6.1 分配算法选择

根据代码特征选择最优分配算法：

```java
/**
 * 智能分配器选择
 */
public class SmartAllocatorSelector {
    
    public String selectAllocator(CFG<IRNode> cfg) {
        // 分析CFG特征
        CFGCharacteristics chars = analyzeCFG(cfg);
        
        // 基于启发式规则选择算法
        if (chars.getRegisterPressure() < 0.7) {
            // 低寄存器压力：使用简单的线性扫描
            return "linear-scan";
        } else if (chars.hasComplexControlFlow()) {
            // 复杂控制流：使用图着色
            return "graph-coloring";
        } else {
            // 默认使用启发式分配器
            return "heuristic";
        }
    }
    
    private CFGCharacteristics analyzeCFG(CFG<IRNode> cfg) {
        int totalInstructions = 0;
        int virtualRegs = 0;
        int branches = 0;
        
        for (BasicBlock<IRNode> block : cfg.getBlocks()) {
            totalInstructions += block.getInstructions().size();
            
            for (IRNode instr : block.getInstructions()) {
                if (instr.hasDef() && instr.getDef().isVirtual()) {
                    virtualRegs++;
                }
                if (instr.isBranch()) {
                    branches++;
                }
            }
        }
        
        double registerPressure = (double) virtualRegs / totalInstructions;
        boolean complexControlFlow = branches > totalInstructions * 0.2;
        
        return new CFGCharacteristics(registerPressure, complexControlFlow);
    }
}
```

## 7. 调试支持

### 7.1 分配过程可视化

```java
/**
 * 分配过程调试器
 */
public class AllocationDebugger {
    
    public void debugAllocation(CFG<IRNode> cfg, RegisterAllocator allocator) {
        System.out.println("=== Register Allocation Debug ===");
        
        // 显示初始状态
        System.out.println("Initial CFG:");
        System.out.println(cfg.toString());
        
        // 显示生命周期分析
        System.out.println("\nLive Intervals:");
        List<LiveInterval> intervals = computeLiveIntervals(cfg);
        for (LiveInterval interval : intervals) {
            System.out.println("  " + interval);
        }
        
        // 执行分配并显示中间步骤
        if (allocator instanceof LinearScanAllocator) {
            debugLinearScan((LinearScanAllocator) allocator, intervals);
        } else if (allocator instanceof GraphColoringAllocator) {
            debugGraphColoring((GraphColoringAllocator) allocator, cfg);
        }
    }
    
    private void debugLinearScan(LinearScanAllocator allocator, 
                                List<LiveInterval> intervals) {
        System.out.println("\n=== Linear Scan Allocation Steps ===");
        
        // 模拟分配过程并输出每一步
        intervals.sort(Comparator.comparingInt(LiveInterval::getStart));
        
        for (LiveInterval interval : intervals) {
            System.out.println("Processing: " + interval);
            // 输出详细分配逻辑...
        }
    }
}
```

## 附录A: 版本历史

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| v1.0 | 2026-01-09 | 整合寄存器分配设计文档 | EP20开发团队 |

---

**相关文档**:
- 详见[EP20项目架构设计规范](EP20_项目架构设计规范.md)
- 详见[EP20 TDD实施标准](../02_implementation_standards/EP20_TDD实施标准.md)

**最后更新**: 2026-01-09
**维护者**: EP20开发团队