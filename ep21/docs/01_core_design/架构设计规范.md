# EP21 ç¼–è¯‘å™¨æ¶æ„è®¾è®¡è§„èŒƒ

**ç‰ˆæœ¬**: 1.1.0
**å‘å¸ƒæ—¥æœŸ**: 2025-12-21
**æœ€åæ›´æ–°**: 2025-12-28
**ç›®æ ‡è¯»è€…**: ç¼–è¯‘å™¨å­¦ä¹ è€…ã€å¼€å‘è€…ã€æ•™è‚²å·¥ä½œè€…
**è§„èŒƒçŠ¶æ€**: æ‰¹å‡† (Approved)

## ğŸ“‹ è§„èŒƒæ¦‚è§ˆ

### 1.1 è§„èŒƒç›®çš„

æœ¬è§„èŒƒæ—¨åœ¨ä¸ºEP21ç¼–è¯‘å™¨é¡¹ç›®æä¾›æ¸…æ™°ã€ç°ä»£åŒ–ã€æ•™è‚²å¯¼å‘çš„æ¶æ„è®¾è®¡æŒ‡å—ã€‚è§„èŒƒä¼˜å…ˆçº§é«˜äºå…·ä½“è®¾è®¡å’Œå®ç°ï¼Œæ‰€æœ‰å¼€å‘æ´»åŠ¨å¿…é¡»éµå¾ªæœ¬è§„èŒƒã€‚

### 1.2 æ ¸å¿ƒåŸåˆ™

1. **æ•™è‚²ä¼˜å…ˆåŸåˆ™**: æ¶æ„è®¾è®¡ä¼˜å…ˆè€ƒè™‘æ•™å­¦ä»·å€¼å’Œå¯ç†è§£æ€§
2. **ç°ä»£æ€§åŸåˆ™**: é‡‡ç”¨ç°ä»£ç¼–è¯‘å™¨è®¾è®¡æ¨¡å¼å’Œæœ€ä½³å®è·µ
3. **åˆ†å±‚æ¸…æ™°åŸåˆ™**: æ˜ç¡®åˆ†å±‚æ¶æ„ï¼ŒèŒè´£è¾¹ç•Œæ¸…æ™°
4. **æ‰©å±•æ€§åŸåˆ™**: æä¾›æ¸…æ™°çš„æ‰©å±•ç‚¹å’Œæ’ä»¶æœºåˆ¶
5. **ä¸€è‡´æ€§åŸåˆ™**: ä¿æŒæ¥å£å’Œè¡Œä¸ºçš„ä¸€è‡´æ€§

### 1.3 è§„èŒƒç»“æ„

- **ç¬¬2ç« **: æ•´ä½“æ¶æ„æ¦‚è¿°
- **ç¬¬3ç« **: å‰ç«¯å±‚è§„èŒƒ
- **ç¬¬4ç« **: ä¸­é—´è¡¨ç¤ºå±‚è§„èŒƒ
- **ç¬¬5ç« **: ä¼˜åŒ–å±‚è§„èŒƒ
- **ç¬¬6ç« **: åç«¯å±‚è§„èŒƒ
- **ç¬¬7ç« **: å·¥å…·é“¾è§„èŒƒ
- **ç¬¬8ç« **: æ‰©å±•æ€§è§„èŒƒ
- **ç¬¬9ç« **: æ•™è‚²åº”ç”¨è§„èŒƒ
- **ç¬¬10ç« **: ç¬¦åˆæ€§è¦æ±‚

---

## 2. æ•´ä½“æ¶æ„è§„èŒƒ

### 2.1 æ¶æ„åˆ†å±‚æ¨¡å‹

EP21ç¼–è¯‘å™¨é‡‡ç”¨**å››å±‚æ¶æ„æ¨¡å‹**ï¼Œæ¯å±‚æœ‰æ˜ç¡®çš„è¾“å…¥è¾“å‡ºå’ŒèŒè´£è¾¹ç•Œï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åº”ç”¨å±‚ (Application)                â”‚
â”‚  â€¢ å‘½ä»¤è¡Œæ¥å£ (CLI)                                  â”‚
â”‚  â€¢ é›†æˆå¼€å‘ç¯å¢ƒæ’ä»¶                                 â”‚
â”‚  â€¢ æµ‹è¯•æ¡†æ¶é›†æˆ                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   å‰ç«¯å±‚ (Frontend)                   â”‚
â”‚  â€¢ è¯æ³•åˆ†æ (Lexical Analysis)                      â”‚
â”‚  â€¢ è¯­æ³•åˆ†æ (Syntax Analysis)                       â”‚
â”‚  â€¢ è¯­ä¹‰åˆ†æ (Semantic Analysis)                     â”‚
â”‚  â€¢ æŠ½è±¡è¯­æ³•æ ‘ (AST) æ„å»º                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ä¸­é—´è¡¨ç¤ºä¸ä¼˜åŒ–å±‚ (Middle End)            â”‚
â”‚  â€¢ ä¸­å±‚IRç”Ÿæˆ (MIR Generation)                      â”‚
â”‚  â€¢ ä½å±‚IRè½¬æ¢ (LIR Conversion)                      â”‚
â”‚  â€¢ æ§åˆ¶æµåˆ†æ (Control Flow Analysis)               â”‚
â”‚  â€¢ æ•°æ®æµåˆ†æ (Data Flow Analysis)                  â”‚
â”‚  â€¢ SSAå½¢å¼è½¬æ¢ (SSA Form Conversion)                â”‚
â”‚  â€¢ ä¼˜åŒ–Passåº”ç”¨ (Optimization Passes)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   åç«¯å±‚ (Backend)                    â”‚
â”‚  â€¢ ä»£ç ç”Ÿæˆ (Code Generation)                       â”‚
â”‚  â€¢ å¯„å­˜å™¨åˆ†é… (Register Allocation)                 â”‚
â”‚  â€¢ æŒ‡ä»¤é€‰æ‹© (Instruction Selection)                 â”‚
â”‚  â€¢ ç›®æ ‡ä»£ç è¾“å‡º (Target Code Emission)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ•°æ®æµå¥‘çº¦

æ¯å±‚ä¹‹é—´é€šè¿‡æ˜ç¡®å®šä¹‰çš„**æ•°æ®å¥‘çº¦**è¿›è¡Œé€šä¿¡ï¼š

| è½¬æ¢é˜¶æ®µ | è¾“å…¥æ ¼å¼ | è¾“å‡ºæ ¼å¼ | è½¬æ¢è´£ä»» |
|----------|----------|----------|----------|
| è¯æ³•åˆ†æ | æºä»£ç å­—ç¬¦ä¸² | Tokenæµ | è¯†åˆ«è¯æ±‡å•å…ƒ |
| è¯­æ³•åˆ†æ | Tokenæµ | è§£ææ ‘ (Parse Tree) | éªŒè¯è¯­æ³•ç»“æ„ |
| ASTæ„å»º | è§£ææ ‘ | æŠ½è±¡è¯­æ³•æ ‘ (AST) | æ„å»ºè¯­ä¹‰ç»“æ„ |
| è¯­ä¹‰åˆ†æ | AST + ç¬¦å·è¡¨ | ç±»å‹åŒ–AST | ç±»å‹æ£€æŸ¥å’Œè¯­ä¹‰éªŒè¯ |
| MIRç”Ÿæˆ | ç±»å‹åŒ–AST | ä¸­å±‚IR (MIR) | ä¿ç•™æ§åˆ¶æµç»“æ„ |
| LIRè½¬æ¢ | MIR | ä½å±‚IR (LIR) | ä¸‰åœ°å€ç è½¬æ¢ |
| CFGæ„å»º | LIR | æ§åˆ¶æµå›¾ (CFG) | åŸºæœ¬å—åˆ’åˆ† |
| ä¼˜åŒ–Pass | CFG | ä¼˜åŒ–åCFG | åº”ç”¨ä¼˜åŒ–ç®—æ³• |
| ä»£ç ç”Ÿæˆ | ä¼˜åŒ–åCFG | ç›®æ ‡ä»£ç  | ç”Ÿæˆå¯æ‰§è¡Œä»£ç  |

### 2.3 æ¥å£è§„èŒƒ

æ‰€æœ‰å±‚é—´æ¥å£å¿…é¡»éµå¾ªä»¥ä¸‹è§„èŒƒï¼š

1. **ä¸å¯å˜æ•°æ®**: è·¨å±‚ä¼ é€’çš„æ•°æ®ç»“æ„å¿…é¡»æ˜¯ä¸å¯å˜çš„
2. **çº¯å‡½æ•°è½¬æ¢**: å±‚é—´è½¬æ¢å‡½æ•°åº”è¯¥æ˜¯çº¯å‡½æ•°ï¼Œæ— å‰¯ä½œç”¨
3. **é”™è¯¯ä¼ æ’­**: ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯ç±»å‹å’Œä¼ æ’­æœºåˆ¶
4. **ä½ç½®ä¿¡æ¯**: æ‰€æœ‰èŠ‚ç‚¹å¿…é¡»æºå¸¦æºä»£ç ä½ç½®ä¿¡æ¯
5. **å¯åºåˆ—åŒ–**: æ‰€æœ‰ä¸­é—´è¡¨ç¤ºå¿…é¡»æ”¯æŒåºåˆ—åŒ–å’Œååºåˆ—åŒ–

---

## 3. å‰ç«¯å±‚è§„èŒƒ

### 3.1 è¯æ³•åˆ†æè§„èŒƒ

#### 3.1.1 è¯æ³•å•å…ƒå®šä¹‰
```antlr4
// å¿…é¡»æ”¯æŒçš„è¯æ³•å•å…ƒç±»å‹
TOKEN_TYPES {
  // æ ‡è¯†ç¬¦å’Œå­—é¢é‡
  IDENTIFIER:      [a-zA-Z_][a-zA-Z0-9_]*
  INTEGER:         [0-9]+
  FLOAT:           [0-9]+\.[0-9]+
  STRING:          \"([^\"\\]|\\.)*\"
  CHARACTER:       \'([^\'\\]|\\.)\'
  BOOLEAN:         true|false

  // å…³é”®å­— (å¿…é¡»å®Œæ•´åˆ—è¡¨)
  TYPE_KEYWORDS:   int|float|bool|string|void|object
  CONTROL_FLOW:    if|else|while|for|return|break|continue
  DECLARATION:     var|let|const|function

  // æ“ä½œç¬¦å’Œåˆ†éš”ç¬¦
  OPERATORS:       +|-|*|/|%|==|!=|<|>|<=|>=|&&|\|\||!|=|+=|-=|*=|/=
  SEPARATORS:      ;|,|:|.|(|)|{|}|[|]

  // ç©ºç™½å’Œæ³¨é‡Š
  WHITESPACE:      [ \t\r\n]+ -> skip
  LINE_COMMENT:    //.* -> skip
  BLOCK_COMMENT:   /\*.*?\*/ -> skip
}
```

#### 3.1.2 è¯æ³•åˆ†æå™¨è¦æ±‚
1. **æ— çŠ¶æ€æ€§**: è¯æ³•åˆ†æå™¨å¿…é¡»æ˜¯çº¯å‡½æ•°ï¼Œæ— å†…éƒ¨çŠ¶æ€
2. **é”™è¯¯æ¢å¤**: å¿…é¡»å®ç°é”™è¯¯æ¢å¤æœºåˆ¶ï¼Œç»§ç»­æ‰«æåç»­å†…å®¹
3. **ä½ç½®è·Ÿè¸ª**: å¿…é¡»å‡†ç¡®è®°å½•æ¯ä¸ªTokençš„è¡Œåˆ—ä½ç½®
4. **æ€§èƒ½è¦æ±‚**: å¿…é¡»æ”¯æŒæµå¼å¤„ç†å¤§æ–‡ä»¶

### 3.2 è¯­æ³•åˆ†æè§„èŒƒ

#### 3.2.1 è¯­æ³•å®šä¹‰åŸåˆ™
1. **LL(k)å‹å¥½**: è¯­æ³•å¿…é¡»é€‚åˆLL(k)åˆ†æï¼Œkâ‰¤2
2. **æ— æ­§ä¹‰**: è¯­æ³•å¿…é¡»æ˜ç¡®æ— æ­§ä¹‰
3. **å·¦é€’å½’æ¶ˆé™¤**: å¿…é¡»æ¶ˆé™¤æ‰€æœ‰ç›´æ¥å’Œé—´æ¥å·¦é€’å½’
4. **ä¼˜å…ˆçº§æ˜ç¡®**: æ“ä½œç¬¦ä¼˜å…ˆçº§å¿…é¡»åœ¨è¯­æ³•ä¸­æ˜ç¡®ä½“ç°

#### 3.2.2 è¯­æ³•ç»“æ„è¦æ±‚
```antlr4
// å¿…é¡»åŒ…å«çš„æ ¸å¿ƒè¯­æ³•è§„åˆ™
GRAMMAR_RULES {
  // ç¨‹åºç»“æ„
  compilationUnit: (functionDecl | variableDecl)* EOF

  // å‡½æ•°å£°æ˜
  functionDecl: returnType identifier '(' parameterList? ')' blockStatement

  // å˜é‡å£°æ˜
  variableDecl: type identifier ('=' expression)? ';'

  // è¯­å¥
  statement: blockStatement
           | ifStatement
           | whileStatement
           | forStatement
           | returnStatement
           | expressionStatement
           | variableDecl

  // è¡¨è¾¾å¼ (æŒ‰ä¼˜å…ˆçº§ä»ä½åˆ°é«˜)
  expression: assignmentExpression
  assignmentExpression: logicalOrExpression ('=' assignmentExpression)?
  logicalOrExpression: logicalAndExpression ('||' logicalAndExpression)*
  logicalAndExpression: equalityExpression ('&&' equalityExpression)*
  equalityExpression: relationalExpression (('=='|'!=') relationalExpression)*
  relationalExpression: additiveExpression (('<'|'>'|'<='|'>=') additiveExpression)*
  additiveExpression: multiplicativeExpression (('+'|'-') multiplicativeExpression)*
  multiplicativeExpression: unaryExpression (('*'|'/'|'%') unaryExpression)*
  unaryExpression: ('-'|'!'|'++'|'--')? primaryExpression
  primaryExpression: literal
                   | identifier
                   | '(' expression ')'
                   | functionCall
}
```

### 3.3 æŠ½è±¡è¯­æ³•æ ‘è§„èŒƒ

#### 3.3.1 ASTèŠ‚ç‚¹è®¾è®¡åŸåˆ™
1. **å•ä¸€èŒè´£**: æ¯ä¸ªASTèŠ‚ç‚¹ç±»å‹å¯¹åº”ä¸€ç§è¯­è¨€ç»“æ„
2. **ä¸å¯å˜æ€§**: æ‰€æœ‰ASTèŠ‚ç‚¹åˆ›å»ºåä¸å¯ä¿®æ”¹
3. **è®¿é—®è€…æ¨¡å¼**: å¿…é¡»å®ç°è®¿é—®è€…æ¨¡å¼ç”¨äºéå†
4. **ä½ç½®ä¿¡æ¯**: æ¯ä¸ªèŠ‚ç‚¹å¿…é¡»åŒ…å«æºä»£ç ä½ç½®
5. **ç±»å‹ä¿¡æ¯**: è¯­ä¹‰åˆ†æåæ¯ä¸ªè¡¨è¾¾å¼èŠ‚ç‚¹å¿…é¡»æœ‰ç±»å‹

#### 3.3.2 æ ¸å¿ƒASTèŠ‚ç‚¹ç±»å‹
```java
// å¿…é¡»å®ç°çš„åŸºç¡€æ¥å£
interface ASTNode {
  Location getLocation();
  <T> T accept(ASTVisitor<T> visitor);
  String toString();  // ç”¨äºè°ƒè¯•
}

// å¿…é¡»å®ç°çš„èŠ‚ç‚¹åˆ†ç±»
NODE_CATEGORIES {
  // å£°æ˜èŠ‚ç‚¹
  CompilationUnitNode
  FunctionDeclarationNode
  VariableDeclarationNode
  ParameterDeclarationNode

  // è¯­å¥èŠ‚ç‚¹
  BlockStatementNode
  IfStatementNode
  WhileStatementNode
  ForStatementNode
  ReturnStatementNode
  ExpressionStatementNode
  BreakStatementNode
  ContinueStatementNode

  // è¡¨è¾¾å¼èŠ‚ç‚¹
  IdentifierExpressionNode
  LiteralExpressionNode (IntLiteral, FloatLiteral, StringLiteral, BooleanLiteral)
  BinaryExpressionNode
  UnaryExpressionNode
  FunctionCallExpressionNode
  AssignmentExpressionNode
}
```

#### 3.3.3 è®¿é—®è€…æ¨¡å¼å®ç°

EP21é‡‡ç”¨**åŒå±‚è®¿é—®è€…æ¨¡å¼**ï¼ŒåŒºåˆ†è§£ææ ‘æ„å»ºå’ŒASTéå†å¤„ç†ï¼š

```java
// 1. ANTLRè§£ææ ‘è®¿é—®è€… - å°†è§£ææ ‘è½¬æ¢ä¸ºAST
public class CymbolASTBuilder extends CymbolBaseVisitor<ASTNode>
        implements CymbolVisitor<ASTNode> {
    // å¤„ç†ANTLRç‰¹å®šçš„visitXxxæ–¹æ³•
    @Override
    public ASTNode visitCompilationUnit(CymbolParser.CompilationUnitContext ctx) { ... }
    @Override
    public ASTNode visitFunctionDecl(CymbolParser.FunctionDeclContext ctx) { ... }
    // ... å…¶ä»–ANTLRç‰¹å®šçš„è®¿é—®æ–¹æ³•
}

// 2. ASTéå†è®¿é—®è€… - å¯¹å·²æ„å»ºçš„ASTè¿›è¡Œåˆ†æå’Œè½¬æ¢
public class ASTBaseVisitor implements ASTVisitor<Void, Void> {
    // æä¾›Voidè¿”å›ç±»å‹çš„é»˜è®¤å®ç°
    @Override
    public Void visit(CompileUnit rootNode) { ... }
    @Override
    public Void visit(FuncDeclNode funcDeclNode) { ... }
    // ... å…¶ä»–ASTèŠ‚ç‚¹è®¿é—®æ–¹æ³•

    // å·¥å‚æ–¹æ³•
    public static ASTBaseVisitor create() {
        return new ASTBaseVisitor();
    }
}

// 3. å…·ä½“è®¿é—®è€…å®ç° - ç»§æ‰¿ASTBaseVisitorè¿›è¡Œæ‰©å±•
public class TypeChecker extends ASTBaseVisitor {
    @Override
    public Void visit(VarDeclNode varDeclNode) {
        // ç±»å‹æ£€æŸ¥é€»è¾‘
        return super.visit(varDeclNode);
    }
}
```

**è®¾è®¡åŸåˆ™**:
1. **èŒè´£åˆ†ç¦»**: `CymbolASTBuilder` è´Ÿè´£è§£ææ ‘â†’ASTè½¬æ¢ï¼Œ`ASTBaseVisitor` è´Ÿè´£ASTéå†
2. **æ¥å£åŒ¹é…**: `CymbolASTBuilder` å®ç° `CymbolVisitor` æ¥å£ï¼ˆANTLRç”Ÿæˆï¼‰
3. **ç®€åŒ–éå†**: `ASTBaseVisitor` ä½¿ç”¨ `Void` è¿”å›ç±»å‹ï¼Œç®€åŒ–çº¯éå†æ“ä½œ
4. **å¯æ‰©å±•æ€§**: å…·ä½“è®¿é—®è€…åªéœ€è¦†ç›–éœ€è¦å¤„ç†çš„æ–¹æ³•

### 3.4 è¯­ä¹‰åˆ†æè§„èŒƒ

#### 3.4.1 ç¬¦å·è¡¨è®¾è®¡
```java
// å¿…é¡»å®ç°çš„ç¬¦å·è¡¨æ¥å£
interface SymbolTable {
  // ä½œç”¨åŸŸç®¡ç†
  Scope enterScope(ScopeType type);
  void exitScope();
  Scope getCurrentScope();

  // ç¬¦å·ç®¡ç†
  void defineSymbol(Symbol symbol);
  Symbol resolveSymbol(String name);
  List<Symbol> getAllSymbols();

  // ç±»å‹ç®¡ç†
  void defineType(Type type);
  Type resolveType(String name);
}

// å¿…é¡»å®ç°çš„ç¬¦å·ç±»å‹
SYMBOL_TYPES {
  VariableSymbol: { name: string, type: Type, isConstant: boolean }
  FunctionSymbol: { name: string, returnType: Type, parameters: ParameterSymbol[] }
  TypeSymbol: { name: string, size: number, alignment: number }
}
```

#### 3.4.2 ç±»å‹ç³»ç»Ÿè¦æ±‚
1. **ç±»å‹å®‰å…¨æ€§**: å¿…é¡»å®ç°é™æ€ç±»å‹æ£€æŸ¥
2. **ç±»å‹æ¨æ–­**: æ”¯æŒå±€éƒ¨å˜é‡ç±»å‹æ¨æ–­ (var x = 10)
3. **ç±»å‹è½¬æ¢**: æ˜ç¡®å®šä¹‰éšå¼å’Œæ˜¾å¼ç±»å‹è½¬æ¢è§„åˆ™
4. **ç±»å‹å…¼å®¹æ€§**: å®šä¹‰ç±»å‹å…¼å®¹æ€§çŸ©é˜µ

---

## 4. ä¸­é—´è¡¨ç¤ºå±‚è§„èŒƒ

### 4.1 åˆ†å±‚IRè®¾è®¡åŸåˆ™

EP21é‡‡ç”¨**ä¸¤å±‚ä¸­é—´è¡¨ç¤º**è®¾è®¡ï¼Œå…¼é¡¾ä¼˜åŒ–èƒ½åŠ›å’Œç®€åŒ–ç¨‹åº¦ï¼š

#### 4.1.1 ä¸­å±‚IR (MIR) - ç”¨äºé«˜å±‚ä¼˜åŒ–
- **ä¿ç•™æ§åˆ¶æµç»“æ„**: if/while/forç­‰é«˜çº§æ§åˆ¶æµ
- **æ”¯æŒå¤æ‚è¡¨è¾¾å¼**: åµŒå¥—è¡¨è¾¾å¼ï¼Œå¤šæ“ä½œæ•°è¿ç®—
- **ç±»å‹ä¿¡æ¯å®Œæ•´**: ä¿ç•™å®Œæ•´çš„ç±»å‹ä¿¡æ¯
- **ä¾¿äºæ•°æ®æµåˆ†æ**: ç»“æ„é€‚åˆæ•°æ®æµåˆ†ææ¡†æ¶

#### 4.1.2 ä½å±‚IR (LIR) - ç”¨äºä½å±‚ä¼˜åŒ–å’Œä»£ç ç”Ÿæˆ
- **ä¸‰åœ°å€ç å½¢å¼**: æ¯æ¡æŒ‡ä»¤æœ€å¤šä¸‰ä¸ªæ“ä½œæ•°
- **ç®€åŒ–æ§åˆ¶æµ**: åªæœ‰è·³è½¬å’Œæ ‡ç­¾
- **æ¥è¿‘ç›®æ ‡ä»£ç **: ä¾¿äºå¯„å­˜å™¨åˆ†é…å’ŒæŒ‡ä»¤é€‰æ‹©
- **SSAå½¢å¼æ”¯æŒ**: æ”¯æŒé™æ€å•èµ‹å€¼å½¢å¼

### 4.2 MIRè§„èŒƒ

#### 4.2.1 MIRèŠ‚ç‚¹ä½“ç³»
```java
// MIRå¿…é¡»å®ç°çš„åŸºç¡€æ¥å£
interface MIRNode {
  Location getLocation();
  <T> T accept(MIRVisitor<T> visitor);
  Type getType();  // èŠ‚ç‚¹ç±»å‹
}

// å¿…é¡»æ”¯æŒçš„MIRèŠ‚ç‚¹ç±»å‹
MIR_NODE_TYPES {
  // ç¨‹åºç»“æ„
  MIRFunction: { name: string, parameters: MIRVariable[], body: MIRBlock }
  MIRBlock: { statements: MIRStatement[] }

  // è¯­å¥
  MIRIfStatement: { condition: MIRExpression, thenBlock: MIRBlock, elseBlock: MIRBlock? }
  MIRWhileStatement: { condition: MIRExpression, body: MIRBlock }
  MIRReturnStatement: { value: MIRExpression? }
  MIRAssignment: { target: MIRVariable, value: MIRExpression }

  // è¡¨è¾¾å¼
  MIRBinaryExpression: { operator: BinaryOperator, left: MIRExpression, right: MIRExpression }
  MIRUnaryExpression: { operator: UnaryOperator, operand: MIRExpression }
  MIRCallExpression: { function: string, arguments: MIRExpression[] }
  MIRVariableExpression: { variable: MIRVariable }
  MIRLiteralExpression: { value: any, type: Type }
}
```

### 4.3 LIRè§„èŒƒ

#### 4.3.1 LIRæŒ‡ä»¤é›†
```java
// LIRå¿…é¡»æ”¯æŒçš„æŒ‡ä»¤ç±»å‹
LIR_INSTRUCTION_TYPES {
  // ç®—æœ¯å’Œé€»è¾‘è¿ç®—
  ADD, SUB, MUL, DIV, MOD
  AND, OR, XOR, NOT
  SHL, SHR  // ç§»ä½

  // æ¯”è¾ƒå’Œè·³è½¬
  CMP: { left: Operand, right: Operand, condition: Condition }
  JMP: { target: Label }
  CJMP: { condition: Condition, thenTarget: Label, elseTarget: Label }

  // å†…å­˜æ“ä½œ
  LOAD: { dest: Register, address: Operand }
  STORE: { address: Operand, value: Operand }

  // å‡½æ•°è°ƒç”¨
  CALL: { function: string, arguments: Operand[], dest: Register? }
  RET: { value: Operand? }

  // æ•°æ®ç§»åŠ¨
  MOV: { dest: Operand, src: Operand }

  // ç‰¹æ®ŠæŒ‡ä»¤
  PHI: { dest: Register, operands: Map<Label, Operand> }  // SSA Ï†å‡½æ•°
}
```

#### 4.3.2 æ“ä½œæ•°ç±»å‹
```java
// å¿…é¡»æ”¯æŒçš„æ“ä½œæ•°ç±»å‹
OPERAND_TYPES {
  Register: { id: number, type: Type }
  Immediate: { value: any, type: Type }      // ç«‹å³æ•°
  Memory: { base: Register, offset: number } // å†…å­˜åœ°å€
  Label: { name: string }                    // ä»£ç æ ‡ç­¾
}
```

### 4.4 æ§åˆ¶æµå›¾è§„èŒƒ

#### 4.4.1 åŸºæœ¬å—å®šä¹‰
```java
// åŸºæœ¬å—å¿…é¡»æ»¡è¶³çš„æ¡ä»¶
BASIC_BLOCK_REQUIREMENTS {
  1. å•ä¸€å…¥å£ç‚¹: åªèƒ½åœ¨å—å¼€å§‹å¤„è¿›å…¥
  2. å•ä¸€å‡ºå£ç‚¹: åªèƒ½åœ¨å—ç»“æŸå¤„ç¦»å¼€
  3. è¿ç»­æŒ‡ä»¤: å—å†…æŒ‡ä»¤é¡ºåºæ‰§è¡Œ
  4. æœ€å¤§é•¿åº¦é™åˆ¶: é¿å…è¿‡é•¿çš„åŸºæœ¬å—
}

// åŸºæœ¬å—æ¥å£
interface BasicBlock {
  String getId();
  List<Instruction> getInstructions();
  List<BasicBlock> getPredecessors();
  List<BasicBlock> getSuccessors();
  void addInstruction(Instruction instr);
  void addPredecessor(BasicBlock pred);
  void addSuccessor(BasicBlock succ);
}
```

#### 4.4.2 CFGæ„å»ºè§„åˆ™
1. **å—åˆ’åˆ†è§„åˆ™**:
   - æ ‡ç­¾æŒ‡ä»¤å¼€å§‹æ–°å—
   - è·³è½¬æŒ‡ä»¤ç»“æŸå½“å‰å—
   - è·³è½¬ç›®æ ‡å¼€å§‹æ–°å—

2. **è¾¹å»ºç«‹è§„åˆ™**:
   - é¡ºåºæ‰§è¡Œ: å—Aæœ«å°¾æ— è·³è½¬ â†’ è¿æ¥å—Aå’Œå—B
   - æ— æ¡ä»¶è·³è½¬: JMPæŒ‡ä»¤ â†’ è¿æ¥å—Aå’Œè·³è½¬ç›®æ ‡å—
   - æ¡ä»¶è·³è½¬: CJMPæŒ‡ä»¤ â†’ è¿æ¥å—Aåˆ°thenå—å’Œelseå—

### 4.5 ç»Ÿä¸€æ¥å£è§„èŒƒ

#### 4.5.1 ICFGBuilder æ¥å£

æ‰€æœ‰CFGæ„å»ºå™¨å¿…é¡»å®ç° `ICFGBuilder` æ¥å£ï¼š

```java
// CFGæ„å»ºå™¨æ¥å£
public interface ICFGBuilder {
    /**
     * ä»èµ·å§‹çº¿æ€§IRå—æ„å»ºæ§åˆ¶æµå›¾
     */
    CFG<IRNode> buildFrom(LinearIRBlock startBlock);

    /**
     * è·å–æ„å»ºç»Ÿè®¡ä¿¡æ¯ï¼Œç”¨äºè°ƒè¯•å’Œç›‘æ§
     */
    Map<String, Object> getStatistics();

    /**
     * éªŒè¯æ„å»ºçš„CFGçš„ä¸€è‡´æ€§å’Œæ­£ç¡®æ€§
     */
    boolean validateCFG();

    /**
     * è·å–æ„å»ºçš„æ§åˆ¶æµå›¾
     */
    CFG<IRNode> getCFG();
}

// æ ‡å‡†å®ç°
public class CFGBuilder implements ICFGBuilder {
    public CFGBuilder(LinearIRBlock startBlock) { ... }

    @Override
    public CFG<IRNode> buildFrom(LinearIRBlock startBlock) {
        return getCFG();
    }

    // é™æ€å·¥å‚æ–¹æ³•
    public static CFG<IRNode> build(LinearIRBlock startBlock) {
        return new CFGBuilder(startBlock).getCFG();
    }
}
```

**è®¾è®¡åŸåˆ™**:
- æ„é€ å‡½æ•°è´Ÿè´£ä¸»è¦æ„å»ºé€»è¾‘ï¼Œ`buildFrom()` æä¾›æ¥å£å¥‘çº¦
- é™æ€å·¥å‚æ–¹æ³• `build()` æä¾›ä¾¿æ·çš„å‡½æ•°å¼API
- `getStatistics()` å’Œ `validateCFG()` ç¡®ä¿å¯æµ‹è¯•æ€§å’Œå¯è°ƒè¯•æ€§

#### 4.5.2 IFlowOptimizer æ¥å£

æ‰€æœ‰æ§åˆ¶æµä¼˜åŒ–å™¨å¿…é¡»å®ç° `IFlowOptimizer` æ¥å£ï¼š

```java
// ä¼˜åŒ–å™¨æ¥å£ - ç”¨äºCFGçº§åˆ«ä¼˜åŒ–
public interface IFlowOptimizer<I extends IRNode> {
    /**
     * å¯¹CFGæ‰§è¡Œä¼˜åŒ–å¤„ç†
     */
    void onHandle(CFG<I> cfg);
}

// ç¤ºä¾‹ï¼šæ´»æ€§åˆ†æå®ç°IFlowOptimizer
public class LivenessAnalysis implements IRVisitor<Void, Void>,
                                        IFlowOptimizer<IRNode> {
    @Override
    public void onHandle(CFG<IRNode> cfg) {
        analyze(cfg);  // æ‰§è¡Œæ´»æ€§åˆ†æ
    }

    public void analyze(CFG<IRNode> cfg) { ... }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šé€šè¿‡CFGæ³¨å†Œä¼˜åŒ–å™¨
CFG<IRNode> cfg = CFGBuilder.build(startBlock);
cfg.addOptimizer(new LivenessAnalysis());
cfg.applyOptimizers();  // æ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ä¼˜åŒ–å™¨
```

**è®¾è®¡åŸåˆ™**:
- `onHandle(CFG)` æ˜¯ç»Ÿä¸€çš„ä¼˜åŒ–å…¥å£æ–¹æ³•
- å®ç°ç±»å¯ä»¥åŒæ—¶å®ç° `IRVisitor` è¿›è¡ŒæŒ‡ä»¤çº§éå†
- é€šè¿‡ `CFG.addOptimizer()` æ³¨å†Œï¼Œå®ç°ä¼˜åŒ–å™¨çš„å¯ç»„åˆæ€§

---

## 5. ä¼˜åŒ–å±‚è§„èŒƒ

### 5.1 ä¼˜åŒ–æ¶æ„æ¦‚è¿°

EP21ä¼˜åŒ–å±‚é‡‡ç”¨**Passç®¡çº¿æ¶æ„**ï¼Œæ¯ä¸ªä¼˜åŒ–Passæ˜¯ç‹¬ç«‹çš„ã€å¯ç»„åˆçš„å¤„ç†å•å…ƒã€‚ä¼˜åŒ–PassæŒ‰ç…§ä»¥ä¸‹å±‚æ¬¡ç»„ç»‡ï¼š

```
æºä»£ç  â†’ å‰ç«¯Pass â†’ ä¼˜åŒ–Passç®¡é“ â†’ ä¼˜åŒ–åä»£ç 
```

æ¯ä¸ªä¼˜åŒ–Passå¿…é¡»ï¼š
1. å®ç° `IOptimizationPass` æ¥å£
2. éµå¾ªç»Ÿä¸€çš„æ‰§è¡Œåè®®
3. æä¾›ä¼˜åŒ–æŒ‡æ ‡å’Œè­¦å‘Šä¿¡æ¯
4. æ”¯æŒé…ç½®é€‰é¡¹

### 5.2 ä¼˜åŒ–Passæ¥å£

```java
public interface IOptimizationPass<I extends IRNode> {
    String getName();
    String getDescription();
    IOptimizationResult<I> optimize(IRModule module);
    
    void configure(OptimizationConfig config);
    boolean isEnabled();
    void setEnabled(boolean enabled);
}
```

### 5.3 ä¼˜åŒ–ç»“æœæ¥å£

```java
public interface IOptimizationResult<I> {
    boolean isChanged();              // æ˜¯å¦ä¿®æ”¹äº†IR
    List<OptimizationMetric> getMetrics();    // ä¼˜åŒ–æŒ‡æ ‡
    List<OptimizationWarning> getWarnings();  // è­¦å‘Šä¿¡æ¯
}
```

### 5.4 å†…å»ºä¼˜åŒ–Passåˆ†ç±»

#### 5.4.1 å±€éƒ¨ä¼˜åŒ–ï¼ˆåŸºæœ¬å—å†…ï¼‰
- **å¸¸é‡æŠ˜å ** (ConstantFoldingOptimizer)
- **å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤** (CommonSubexpressionEliminationOptimizer)
- **æ­»ä»£ç æ¶ˆé™¤** (DeadCodeEliminationOptimizer)

#### 5.4.2 å…¨å±€ä¼˜åŒ–ï¼ˆå‡½æ•°å†…ï¼‰
- **å¸¸é‡ä¼ æ’­** (ConstantPropagationOptimizer)
- **æ´»è·ƒåº¦åˆ†æ** (LivenessAnalysis)

#### 5.4.3 å¾ªç¯ä¼˜åŒ–
- **å¾ªç¯ä¸å˜ä»£ç å¤–æ** (LoopInvariantCodeMotionOptimizer)
- **å¾ªç¯å±•å¼€** (LoopUnrollingOptimizer)
- **å¼ºåº¦å‰Šå‡** (StrengthReductionOptimizer)

#### 5.4.4 æ§åˆ¶æµä¼˜åŒ–
- **å°¾é€’å½’ä¼˜åŒ–** (TailRecursionOptimizer)
- **æ§åˆ¶æµç®€åŒ–** (ControlFlowAnalysis)

### 5.5 EnhancedCFGä¸ä¼˜åŒ–å±‚é›†æˆ

#### 5.5.1 EnhancedCFGä½œä¸ºä¼˜åŒ–åˆ†æåŸºç¡€

EnhancedCFGä¸ºä¼˜åŒ–Passæä¾›ï¼š
- **å¿«é€Ÿè¾¹æŸ¥è¯¢**ï¼š`getOutgoingEdges()`, `getIncomingEdges()`
- **åå‘ååºéå†**ï¼š`getReversePostOrder()`
- **æ‹“æ‰‘æ’åº**ï¼š`getTopologicalOrder()`
- **æ‰¹é‡è¾¹æ“ä½œ**ï¼š`addEdges()`, `removeEdges()`
- **å…³é”®è¾¹æ‹†åˆ†**ï¼š`splitCriticalEdges()`
- **å¾ªç¯ä¿¡æ¯**ï¼šé€šè¿‡`getLoopInfo()` è·å–åµŒå¥—æ ‘å’Œç»Ÿè®¡
- **CFGå®Œæ•´æ€§éªŒè¯**ï¼šé€šè¿‡`CFGIntegrityChecker`

#### 5.5.2 ä¼˜åŒ–Passä½¿ç”¨ç¤ºä¾‹

```java
public class ExampleOptimizer implements IFlowOptimizer<IRNode> {
    @Override
    public void onHandle(CFG<IRNode> cfg) {
        // 1. è·å–å¾ªç¯ä¿¡æ¯
        var loopInfo = cfg.getLoopInfo();
        var nestingTree = loopInfo.getNestingTree();
        
        // 2. æ‰§è¡Œå¾ªç¯ä¸å˜ä»£ç å¤–æ
        for (NaturalLoop<I> loop : loopInfo.getLoops()) {
            if (loop.getNestingDepth() > 0) {
                // åˆ†æå¾ªç¯ä½“ä¸­çš„ä¸å˜è¡¨è¾¾å¼
                // å°†ä¸å˜è¡¨è¾¾å¼å¤–æåˆ°å¾ªç¯å¤´ä¹‹å‰
            }
        }
        
        // 3. æ‹†åˆ†æ‰€æœ‰å…³é”®è¾¹ï¼ˆä¸ºSSAå‡†å¤‡ï¼‰
        cfg.splitCriticalEdges();
        
        // 4. åº”ç”¨ä¼˜åŒ–
        // ä½¿ç”¨ä¼˜åŒ–Passç®¡é“
    }
}
```

#### 5.5.3 å¢å¼ºCFGçš„æ€§èƒ½è€ƒè™‘

ä¼˜åŒ–Passåœ¨ä½¿ç”¨EnhancedCFGæ—¶åº”è¯¥æ³¨æ„ï¼š
- ä¼˜å…ˆä½¿ç”¨ç¼“å­˜æŸ¥è¯¢æ–¹æ³•ï¼ˆ`getOutgoingEdges()` vs çº¿æ€§æœç´¢ï¼‰
- æ‰¹é‡æ“ä½œä¼˜å…ˆäºå•ç‹¬æ“ä½œ
- ç¼“å­˜å¤±æ•ˆæœºåˆ¶ä¼šå½±å“åç»­æŸ¥è¯¢æ€§èƒ½
- å¯¹äºå¤§å‹CFGï¼ˆ>1000ä¸ªèŠ‚ç‚¹ï¼‰ï¼Œæ€§èƒ½æå‡çº¦50%

#### 5.1.2 ä¼˜åŒ–Passåˆ†ç±»
```java
// å¿…é¡»å®ç°çš„ä¼˜åŒ–Passç±»å‹
OPTIMIZATION_CATEGORIES {
  // å±€éƒ¨ä¼˜åŒ– (åŸºæœ¬å—å†…)
  ConstantFoldingPass:       å¸¸é‡æŠ˜å 
  CommonSubexpressionEliminationPass: å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤
  DeadCodeEliminationPass:   æ­»ä»£ç åˆ é™¤

  // å…¨å±€ä¼˜åŒ– (å‡½æ•°å†…)
  ConstantPropagationPass:   å¸¸é‡ä¼ æ’­
  CopyPropagationPass:       å¤åˆ¶ä¼ æ’­
  DeadStoreEliminationPass:  æ­»å­˜å‚¨æ¶ˆé™¤

  // å¾ªç¯ä¼˜åŒ–
  LoopInvariantCodeMotionPass: å¾ªç¯ä¸å˜é‡å¤–æ
  LoopUnrollingPass:         å¾ªç¯å±•å¼€

  // æ§åˆ¶æµä¼˜åŒ–
  UnreachableCodeEliminationPass: ä¸å¯è¾¾ä»£ç åˆ é™¤
  BranchOptimizationPass:    åˆ†æ”¯ä¼˜åŒ–
}
```

### 5.2 æ•°æ®æµåˆ†ææ¡†æ¶

#### 5.2.1 æ•°æ®æµåˆ†ææ¥å£
```java
// ç»Ÿä¸€çš„æ•°æ®æµåˆ†ææ¥å£
interface DataFlowAnalysis<T> {
  enum Direction { FORWARD, BACKWARD }

  Direction getDirection();

  // æ•°æ®æµæ–¹ç¨‹
  T transfer(BasicBlock block, T input);
  T meet(T value1, T value2);      // äº¤æ±‡æ“ä½œ
  T getInitialValue();
  boolean lessEqual(T value1, T value2);  // ååºå…³ç³»

  // è¿­ä»£æ±‚è§£
  Map<BasicBlock, T> analyze(CFG cfg);
}

// å¿…é¡»å®ç°çš„æ•°æ®æµåˆ†æ
REQUIRED_ANALYSES {
  LiveVariableAnalysis:       æ´»è·ƒå˜é‡åˆ†æ
  ReachingDefinitionsAnalysis: åˆ°è¾¾å®šä¹‰åˆ†æ
  AvailableExpressionsAnalysis: å¯ç”¨è¡¨è¾¾å¼åˆ†æ
}
```

#### 5.2.2 SSAå½¢å¼è½¬æ¢

##### 5.2.2.1 SSAæ„å»ºæ­¥éª¤
1. **æ”¯é…æ ‘è®¡ç®—**: æ„å»ºæ”¯é…å…³ç³»æ ‘
2. **æ”¯é…è¾¹ç•Œè®¡ç®—**: ç¡®å®šÏ†å‡½æ•°æ’å…¥ä½ç½®
3. **Ï†å‡½æ•°æ’å…¥**: åœ¨æ”¯é…è¾¹ç•Œæ’å…¥Ï†å‡½æ•°
4. **å˜é‡é‡å‘½å**: å°†å˜é‡è½¬æ¢ä¸ºSSAå½¢å¼

##### 5.2.2.2 SSAç ´åæ­¥éª¤
1. **Ï†å‡½æ•°æ¶ˆé™¤**: å°†Ï†å‡½æ•°è½¬æ¢ä¸ºå¤åˆ¶æ“ä½œ
2. **å¤åˆ¶ä¼ æ’­**: ä¼ æ’­å¤åˆ¶æ“ä½œ
3. **å¯„å­˜å™¨åˆ†é…**: åˆ†é…ç‰©ç†å¯„å­˜å™¨

---

## 6. åç«¯å±‚è§„èŒƒ

### 6.1 ä»£ç ç”Ÿæˆè§„èŒƒ

#### 6.1.1 ç›®æ ‡ä»£ç ç”Ÿæˆæ¥å£
```java
// ä»£ç ç”Ÿæˆå™¨æ¥å£
interface CodeGenerator {
  // ä»£ç ç”Ÿæˆ
  TargetCode generate(IRModule module);

  // ç›®æ ‡æ¶æ„é…ç½®
  void setTargetArchitecture(TargetArchitecture arch);
  TargetArchitecture getTargetArchitecture();

  // ä¼˜åŒ–é€‰é¡¹
  void setOptimizationLevel(OptimizationLevel level);
  OptimizationLevel getOptimizationLevel();
}

// å¿…é¡»æ”¯æŒçš„ç›®æ ‡æ¶æ„
SUPPORTED_TARGETS {
  EP18_VIRTUAL_MACHINE:  EP18è™šæ‹Ÿæœºå­—èŠ‚ç 
  X86_64_ASSEMBLY:      x86-64æ±‡ç¼–
  LLVM_IR:              LLVMä¸­é—´è¡¨ç¤º
}
```

#### 6.1.2 å¯„å­˜å™¨åˆ†é…è§„èŒƒ

##### 6.1.2.1 å¯„å­˜å™¨åˆ†é…ç®—æ³•è¦æ±‚
1. **å›¾ç€è‰²ç®—æ³•**: å¿…é¡»å®ç°å›¾ç€è‰²å¯„å­˜å™¨åˆ†é…
2. **æº¢å‡ºå¤„ç†**: æ”¯æŒå¯„å­˜å™¨æº¢å‡ºåˆ°å†…å­˜
3. **è°ƒç”¨çº¦å®š**: éµå¾ªæ ‡å‡†çš„å‡½æ•°è°ƒç”¨çº¦å®š
4. **å¯„å­˜å™¨ç±»åˆ«**: åŒºåˆ†é€šç”¨å¯„å­˜å™¨ã€æµ®ç‚¹å¯„å­˜å™¨ç­‰

##### 6.1.2.2 å¯„å­˜å™¨åˆ†é…æ¥å£
```java
interface RegisterAllocator {
  // åˆ†é…æ¥å£
  AllocationResult allocate(Function function, RegisterSet registerSet);

  // ç»Ÿè®¡ä¿¡æ¯
  AllocationStatistics getStatistics();
  List<SpillInstruction> getSpillInstructions();
}

// åˆ†é…ç»“æœ
interface AllocationResult {
  Map<VirtualRegister, PhysicalRegister> getMapping();
  List<MoveInstruction> getMoveInstructions();
  boolean hasSpills();
}
```

### 6.2 æŒ‡ä»¤é€‰æ‹©è§„èŒƒ

#### 6.2.1 æŒ‡ä»¤é€‰æ‹©å™¨æ¥å£
```java
interface InstructionSelector {
  // æŒ‡ä»¤é€‰æ‹©
  List<MachineInstruction> select(List<IRInstruction> irInstructions);

  // æ¨¡å¼åŒ¹é…
  void addPattern(InstructionPattern pattern);
  List<InstructionPattern> getPatterns();

  // ä»£ä»·æ¨¡å‹
  CostModel getCostModel();
  void setCostModel(CostModel model);
}
```

#### 6.2.2 æŒ‡ä»¤è°ƒåº¦è§„èŒƒ
1. **åˆ—è¡¨è°ƒåº¦ç®—æ³•**: å¿…é¡»å®ç°åˆ—è¡¨è°ƒåº¦ç®—æ³•
2. **ä¾èµ–åˆ†æ**: å‡†ç¡®åˆ†ææŒ‡ä»¤é—´ä¾èµ–å…³ç³»
3. **èµ„æºå†²çª**: å¤„ç†åŠŸèƒ½å•å…ƒå†²çª
4. **å»¶è¿Ÿéšè—**: åˆ©ç”¨æŒ‡ä»¤çº§å¹¶è¡Œ

---

## 7. å·¥å…·é“¾è§„èŒƒ

### 7.1 ç¼–è¯‘å™¨é©±åŠ¨è§„èŒƒ

#### 7.1.1 å‘½ä»¤è¡Œæ¥å£
```bash
# å¿…é¡»æ”¯æŒçš„å‘½ä»¤è¡Œé€‰é¡¹
USAGE: ep21c [options] <input-file>

OPTIONS {
  # è¾“å…¥è¾“å‡ºæ§åˆ¶
  -o, --output <file>        æŒ‡å®šè¾“å‡ºæ–‡ä»¶
  -S, --assembly             è¾“å‡ºæ±‡ç¼–ä»£ç 
  -c, --compile-only         åªç¼–è¯‘ä¸é“¾æ¥

  # ä¼˜åŒ–æ§åˆ¶
  -O0, -O1, -O2, -O3        ä¼˜åŒ–çº§åˆ«
  --opt <pass>              å¯ç”¨ç‰¹å®šä¼˜åŒ–Pass
  --no-opt <pass>           ç¦ç”¨ç‰¹å®šä¼˜åŒ–Pass

  # è°ƒè¯•ä¿¡æ¯
  -g, --debug               ç”Ÿæˆè°ƒè¯•ä¿¡æ¯
  --dump-ast                è¾“å‡ºAST
  --dump-ir                 è¾“å‡ºIR
  --dump-cfg                è¾“å‡ºæ§åˆ¶æµå›¾

  # è¯­è¨€ç‰¹æ€§
  --std <version>           è¯­è¨€æ ‡å‡†ç‰ˆæœ¬
  --feature <feature>       å¯ç”¨è¯­è¨€ç‰¹æ€§

  # å…¶ä»–
  -v, --verbose             è¯¦ç»†è¾“å‡º
  --version                 æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯
  -h, --help                æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
}
```

### 7.2 è°ƒè¯•ä¿¡æ¯è§„èŒƒ

#### 7.2.1 è°ƒè¯•ä¿¡æ¯æ ¼å¼
```java
// å¿…é¡»ç”Ÿæˆçš„è°ƒè¯•ä¿¡æ¯
DEBUG_INFO_TYPES {
  // ä½ç½®ä¿¡æ¯
  SourceLocation: { file: string, line: number, column: number }

  // å˜é‡ä¿¡æ¯
  VariableInfo: { name: string, type: string, location: StorageLocation }

  // å‡½æ•°ä¿¡æ¯
  FunctionInfo: { name: string, returnType: string, parameters: VariableInfo[] }

  // ç±»å‹ä¿¡æ¯
  TypeInfo: { name: string, size: number, alignment: number, members: MemberInfo[] }
}
```

---

## 8. æ‰©å±•æ€§è§„èŒƒ

### 8.1 æ’ä»¶ç³»ç»Ÿè§„èŒƒ

#### 8.1.1 æ’ä»¶æ¥å£
```java
// æ’ä»¶åŸºç¡€æ¥å£
interface CompilerPlugin {
  String getName();
  String getVersion();
  String getDescription();

  // ç”Ÿå‘½å‘¨æœŸ
  void initialize(CompilerContext context);
  void shutdown();

  // æ‰©å±•ç‚¹
  List<ExtensionPoint> getExtensionPoints();
}

// æ”¯æŒçš„æ‰©å±•ç‚¹ç±»å‹
EXTENSION_POINTS {
  AST_TRANSFORM:     ASTè½¬æ¢æ’ä»¶
  IR_OPTIMIZATION:   IRä¼˜åŒ–æ’ä»¶
  CODE_GENERATOR:    ä»£ç ç”Ÿæˆæ’ä»¶
  TARGET_BACKEND:    ç›®æ ‡åç«¯æ’ä»¶
  ANALYSIS_PASS:     åˆ†æPassæ’ä»¶
}
```

### 8.2 è¯­è¨€æ‰©å±•è§„èŒƒ

#### 8.2.1 æ–°è¯­è¨€ç‰¹æ€§é›†æˆæµç¨‹
1. **è¯­æ³•æ‰©å±•**: åœ¨Cymbol.g4ä¸­æ·»åŠ æ–°è¯­æ³•è§„åˆ™
2. **ASTæ‰©å±•**: æ·»åŠ æ–°çš„ASTèŠ‚ç‚¹ç±»å‹
3. **è¯­ä¹‰åˆ†æ**: å®ç°ç±»å‹æ£€æŸ¥å’Œè¯­ä¹‰è§„åˆ™
4. **IRç”Ÿæˆ**: æ”¯æŒæ–°ç‰¹æ€§çš„IRè½¬æ¢
5. **ä»£ç ç”Ÿæˆ**: ç”Ÿæˆç›®æ ‡ä»£ç 
6. **æµ‹è¯•è¦†ç›–**: æ·»åŠ å®Œæ•´çš„æµ‹è¯•ç”¨ä¾‹

---

## 9. æ•™è‚²åº”ç”¨è§„èŒƒ

### 9.1 æ•™å­¦ç”¨ä¾‹è®¾è®¡åŸåˆ™

#### 9.1.1 æ¸è¿›å¼å¤æ‚åº¦
```markdown
# æ•™å­¦ç”¨ä¾‹å¤æ‚åº¦åˆ†çº§

## Level 1: åŸºç¡€è¯­æ³• (ç¬¬1-2å‘¨)
- å˜é‡å£°æ˜å’Œèµ‹å€¼
- åŸºæœ¬ç®—æœ¯è¿ç®—
- ç®€å•å‡½æ•°å®šä¹‰
- æ¡ä»¶è¯­å¥ (if-else)

## Level 2: æ§åˆ¶æµ (ç¬¬3-4å‘¨)
- å¾ªç¯ç»“æ„ (while, for)
- åµŒå¥—æ§åˆ¶æµ
- å‡½æ•°è°ƒç”¨å’Œè¿”å›
- é€’å½’å‡½æ•°

## Level 3: æ•°æ®ç»“æ„ (ç¬¬5-6å‘¨)
- æ•°ç»„æ“ä½œ
- ç»“æ„ä½“å®šä¹‰
- æŒ‡é’ˆå’Œå¼•ç”¨
- åŠ¨æ€å†…å­˜

## Level 4: é«˜çº§ç‰¹æ€§ (ç¬¬7-8å‘¨)
- æ¨¡å—åŒ–ç¼–ç¨‹
- é”™è¯¯å¤„ç†
- å¹¶å‘ç¼–ç¨‹
- å…ƒç¼–ç¨‹ç‰¹æ€§
```

#### 9.1.2 å¯è§†åŒ–æ•™å­¦æ”¯æŒ
1. **ASTå¯è§†åŒ–**: å›¾å½¢åŒ–æ˜¾ç¤ºæŠ½è±¡è¯­æ³•æ ‘
2. **CFGå¯è§†åŒ–**: æ˜¾ç¤ºæ§åˆ¶æµå›¾ç»“æ„
3. **æ•°æ®æµå¯è§†åŒ–**: å±•ç¤ºæ•°æ®æµåˆ†æç»“æœ
4. **ä¼˜åŒ–æ•ˆæœå¯è§†åŒ–**: å¯¹æ¯”ä¼˜åŒ–å‰åä»£ç 

### 9.2 å®éªŒè®¾è®¡è§„èŒƒ

#### 9.2.1 å®éªŒä»»åŠ¡ç±»å‹
```java
// å¿…é¡»æ”¯æŒçš„å®éªŒç±»å‹
EXPERIMENT_TYPES {
  // ç†è§£æ€§å®éªŒ
  CODE_ANALYSIS:    ä»£ç åˆ†æå®éªŒ
  VISUALIZATION:    å¯è§†åŒ–å®éªŒ
  TRACING:          æ‰§è¡Œè·Ÿè¸ªå®éªŒ

  // å®ç°æ€§å®éªŒ
  GRAMMAR_EXTENSION: è¯­æ³•æ‰©å±•å®éªŒ
  OPTIMIZATION_IMPLEMENTATION: ä¼˜åŒ–å®ç°å®éªŒ
  BACKEND_EXTENSION: åç«¯æ‰©å±•å®éªŒ

  // ç ”ç©¶æ€§å®éªŒ
  PERFORMANCE_ANALYSIS: æ€§èƒ½åˆ†æå®éªŒ
  ALGORITHM_COMPARISON: ç®—æ³•å¯¹æ¯”å®éªŒ
  NEW_FEATURE_DESIGN:   æ–°ç‰¹æ€§è®¾è®¡å®éªŒ
}
```

#### 9.2.2 å®éªŒæŠ¥å‘Šè¦æ±‚
1. **é—®é¢˜æè¿°**: æ¸…æ™°æè¿°å®éªŒç›®æ ‡
2. **å®ç°æ–¹æ¡ˆ**: è¯¦ç»†è¯´æ˜å®ç°æ–¹æ³•
3. **ç»“æœåˆ†æ**: å®šé‡å’Œå®šæ€§åˆ†æç»“æœ
4. **é—®é¢˜è®¨è®º**: è®¨è®ºé‡åˆ°çš„é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
5. **æ‰©å±•æ€è€ƒ**: æå‡ºè¿›ä¸€æ­¥æ”¹è¿›æ–¹å‘

---

## 10. ç¬¦åˆæ€§è¦æ±‚

### 10.1 è§„èŒƒç¬¦åˆæ€§çº§åˆ«

#### 10.1.1 å¿…é¡»å®ç° (MUST)
- æ‰€æœ‰æ ‡è®°ä¸º"MUST"çš„è§„èŒƒæ¡æ¬¾å¿…é¡»å®Œå…¨å®ç°
- è¿™æ˜¯ç¼–è¯‘å™¨æ­£å¸¸å·¥ä½œçš„åŸºæœ¬è¦æ±‚
- æµ‹è¯•è¦†ç›–ç‡å¿…é¡»è¾¾åˆ°100%

#### 10.1.2 åº”è¯¥å®ç° (SHOULD)
- æ ‡è®°ä¸º"SHOULD"çš„æ¡æ¬¾å»ºè®®å®ç°
- æœªå®ç°éœ€è¦æä¾›åˆç†è¯´æ˜
- å½±å“ç¼–è¯‘å™¨å®Œæ•´æ€§å’Œè´¨é‡

#### 10.1.3 å¯ä»¥å®ç° (MAY)
- æ ‡è®°ä¸º"MAY"çš„æ¡æ¬¾æ˜¯å¯é€‰çš„
- å®ç°å¯ä»¥æä¾›é¢å¤–ä»·å€¼
- ä¸å½±å“æ ¸å¿ƒåŠŸèƒ½

### 10.2 æµ‹è¯•è¦æ±‚

#### 10.2.1 æµ‹è¯•è¦†ç›–ç‡
```yaml
æµ‹è¯•è¦†ç›–ç‡è¦æ±‚:
  æ•´ä½“è¦†ç›–ç‡: â‰¥85%
  æ ¸å¿ƒæ¨¡å—: â‰¥90% (å‰ç«¯ã€ä¼˜åŒ–ã€åç«¯)
  æ–°åŠŸèƒ½: 100%
  é”™è¯¯å¤„ç†: 100%
```

#### 10.2.2 æµ‹è¯•ç±»å‹è¦æ±‚
1. **å•å…ƒæµ‹è¯•**: æ¯ä¸ªå…¬å¼€æ–¹æ³•å¿…é¡»æœ‰å•å…ƒæµ‹è¯•
2. **é›†æˆæµ‹è¯•**: æ¨¡å—é—´æ¥å£å¿…é¡»æœ‰é›†æˆæµ‹è¯•
3. **ç«¯åˆ°ç«¯æµ‹è¯•**: å®Œæ•´ç¼–è¯‘æµç¨‹å¿…é¡»æœ‰ç«¯åˆ°ç«¯æµ‹è¯•
4. **æ€§èƒ½æµ‹è¯•**: å…³é”®ç®—æ³•å¿…é¡»æœ‰æ€§èƒ½æµ‹è¯•
5. **å›å½’æµ‹è¯•**: æ‰€æœ‰ä¿®å¤çš„bugå¿…é¡»æœ‰å›å½’æµ‹è¯•

---

## é™„å½•A: æœ¯è¯­è¡¨

| æœ¯è¯­ | å®šä¹‰ | å‚è€ƒ |
|------|------|------|
| AST | æŠ½è±¡è¯­æ³•æ ‘ï¼Œæºä»£ç çš„æ ‘çŠ¶è¡¨ç¤º | ç¬¬3.3èŠ‚ |
| CFG | æ§åˆ¶æµå›¾ï¼Œç¨‹åºæ‰§è¡Œæµç¨‹çš„å›¾å½¢è¡¨ç¤º | ç¬¬4.4èŠ‚ |
| IR | ä¸­é—´è¡¨ç¤ºï¼Œä»‹äºæºä»£ç å’Œç›®æ ‡ä»£ç ä¹‹é—´çš„è¡¨ç¤ºå½¢å¼ | ç¬¬4ç«  |
| MIR | ä¸­å±‚ä¸­é—´è¡¨ç¤ºï¼Œä¿ç•™é«˜çº§æ§åˆ¶æµç»“æ„ | ç¬¬4.2èŠ‚ |
| LIR | ä½å±‚ä¸­é—´è¡¨ç¤ºï¼Œæ¥è¿‘ä¸‰åœ°å€ç å½¢å¼ | ç¬¬4.3èŠ‚ |
| SSA | é™æ€å•èµ‹å€¼å½¢å¼ï¼Œæ¯ä¸ªå˜é‡åªèµ‹å€¼ä¸€æ¬¡ | ç¬¬5.2.2èŠ‚ |
| Ï†å‡½æ•° | SSAä¸­çš„ç‰¹æ®Šå‡½æ•°ï¼Œæ ¹æ®æ§åˆ¶æµé€‰æ‹©å€¼ | ç¬¬5.2.2èŠ‚ |

## é™„å½•B: å˜æ›´è®°å½•

| ç‰ˆæœ¬ | æ—¥æœŸ | å˜æ›´æè¿° | è´Ÿè´£äºº |
|------|------|----------|--------|
| 1.1.0 | 2025-12-28 | 1. æ–°å¢4.5èŠ‚ç»Ÿä¸€æ¥å£è§„èŒƒï¼ˆICFGBuilderã€IFlowOptimizerï¼‰<br>2. æ–°å¢3.3.3èŠ‚è®¿é—®è€…æ¨¡å¼å®ç°ï¼ˆåŒå±‚è®¿é—®è€…è®¾è®¡ï¼‰ | ç¼–è¯‘å™¨å›¢é˜Ÿ |
| 1.0.0 | 2025-12-21 | åˆå§‹ç‰ˆæœ¬å‘å¸ƒ | ç¼–è¯‘å™¨å›¢é˜Ÿ |

---

**è§„èŒƒçŠ¶æ€**: æ‰¹å‡† (Approved)
**ç”Ÿæ•ˆæ—¥æœŸ**: 2025-12-21
**æœ€åæ›´æ–°**: 2025-12-28
**ä¸‹æ¬¡è¯„å®¡æ—¥æœŸ**: 2026-06-21

---

*æœ¬è§„èŒƒæ˜¯EP21ç¼–è¯‘å™¨é¡¹ç›®çš„æƒå¨å‚è€ƒæ–‡æ¡£ï¼Œæ‰€æœ‰è®¾è®¡å’Œå®ç°å¿…é¡»éµå¾ªæœ¬è§„èŒƒã€‚å¦‚æœ‰å†²çªï¼Œä»¥æœ¬è§„èŒƒä¸ºå‡†ã€‚*