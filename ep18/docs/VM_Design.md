# 虚拟机设计文档 (VM Design)

**文档版本**: v2.0
**创建日期**: 2025-12-18
**最后更新**: 2025-12-18
**更新说明**: 与EP18R ABI设计文档统一，确保VM设计与ABI规范完全一致

## 概述

本文档描述Cymbol编程语言的虚拟机（VM）设计，特别关注与EP18R寄存器虚拟机的ABI（应用程序二进制接口）规范的一致性。VM设计与ABI设计必须完全统一，以确保编译器生成的代码与虚拟机运行时系统之间的二进制兼容性。

**重要**: 本VM设计文档应与[EP18R ABI设计文档](../ep18r/docs/EP18R_ABI_设计文档.md)一起阅读，两者共同构成完整的虚拟机规范。

## 1. 寄存器约定（与ABI完全一致）

EP18R寄存器虚拟机提供16个32位通用寄存器（r0-r15），每个寄存器都有特定的ABI名称和用途。下表与ABI设计文档第2节完全一致：

| 寄存器 | ABI名称 | 保存者 | 描述 |
|--------|---------|--------|------|
| r0 | zero | - | 硬连线为零，写入无效 |
| r1 | ra | 调用者 | 返回地址（兼容性用途）/临时值 |
| r2 | a0 | 调用者 | 函数参数1/返回值 |
| r3 | a1 | 调用者 | 函数参数2/临时值 |
| r4 | a2 | 调用者 | 函数参数3/临时值 |
| r5 | a3 | 调用者 | 函数参数4/临时值 |
| r6 | a4 | 调用者 | 函数参数5/临时值 |
| r7 | a5 | 调用者 | 函数参数6/临时值 |
| r8 | s0 | 被调用者 | 保存寄存器1 |
| r9 | s1 | 被调用者 | 保存寄存器2 |
| r10 | s2 | 被调用者 | 保存寄存器3 |
| r11 | s3 | 被调用者 | 保存寄存器4 |
| r12 | s4 | 被调用者 | 保存寄存器5 |
| r13 | sp | 被调用者 | 栈指针（Stack Pointer） |
| r14 | fp | 被调用者 | 帧指针（Frame Pointer） |
| r15 | lr | 调用者 | 链接寄存器（Link Register） |

### 寄存器保存责任
- **调用者保存寄存器（Caller-saved）**: ra (r1), a0-a5 (r2-r7), lr (r15)。调用者在调用前保存这些寄存器的值（如果需要）。
- **被调用者保存寄存器（Callee-saved）**: s0-s4 (r8-r12), sp (r13), fp (r14)。被调用者如果使用这些寄存器，必须在函数入口保存，在函数出口恢复。
- **特殊寄存器**: zero (r0)始终为0；sp (r13)为栈指针；fp (r14)为帧指针；lr (r15)为链接寄存器。

## 2. 函数调用约定（与ABI完全一致）

### 参数传递规则
- **前6个整数参数**: 通过寄存器 a0-a5 (r2-r7) 传递。
- **第7个及以后参数**: 通过栈传递，偏移量为 `fp + 16 + 4*(n-7)`。

### 返回值约定
- **单个整数返回值**: 通过 a0 (r2) 寄存器返回。

### 调用栈机制
虚拟机同时维护两种返回地址保存机制，确保兼容性：
1. **调用栈（callStack）**: 主要机制，支持任意深度嵌套调用。
2. **链接寄存器（lr/r15）**: 兼容性机制，同时保存返回地址。

**call指令语义**:
1. 将返回地址（PC+4）保存到调用栈和lr寄存器。
2. 保存调用者保存寄存器到当前栈帧的`savedCallerRegisters`数组。
3. 跳转到目标地址。

**ret指令语义**:
1. 从调用栈弹出返回地址。
2. 恢复调用者保存寄存器从栈帧的`savedCallerRegisters`数组。
3. 跳转回返回地址。

## 3. 栈帧布局（与ABI完全一致）

### 栈帧结构（向下增长）
```
高地址
+-------------------+ ← 调用者栈帧结束
|   调用者保存区域   |   （可选，由调用者管理）
+-------------------+
|   参数7+          |   fp + 16 + 4*(n-7)
|   ...             |
|   参数8           |   fp + 20
|   参数7           |   fp + 16
+-------------------+
|   返回地址         |   fp + 12  (存储在调用栈中)
+-------------------+
|   旧帧指针(fp)     |   fp + 8   (fp旧值)
+-------------------+
|   保存寄存器s4     |   fp + 4   (r12)
|   保存寄存器s3     |   fp + 0   (r11)
|   保存寄存器s2     |   fp - 4   (r10)
|   保存寄存器s1     |   fp - 8   (r9)
|   保存寄存器s0     |   fp - 12  (r8)
+-------------------+
|   局部变量n       |   fp - 16 - 4*(n-1)
|   ...             |
|   局部变量2       |   fp - 20
|   局部变量1       |   fp - 16
+-------------------+
|   临时空间         |   （用于表达式求值等）
+-------------------+
低地址               ← sp (栈指针)
```

### 栈帧大小计算
```
栈帧大小 = 保存寄存器区 + 局部变量区 + 临时空间 + 对齐填充
其中：
- 保存寄存器区: 5 * 4 = 20字节（s0-s4）
- 局部变量区: num_locals * 4字节
- 临时空间: 根据需要动态计算
- 对齐填充: 确保栈帧大小是8字节的倍数
```

### 栈对齐要求
- **栈指针对齐**: sp 必须保持8字节对齐（最低3位为0）。
- **栈帧对齐**: 每个栈帧大小必须是8字节的倍数。

## 4. 指令集架构

### 指令格式
EP18R寄存器虚拟机使用32位定长指令，支持三种指令格式：

#### R类型（寄存器-寄存器操作）
```
| 31-26 | 25-21 | 20-16 | 15-11 | 10-0    |
| opcode| rd    | rs1   | rs2   | unused  |
```
示例指令：`add`, `sub`, `mul`, `div`, `slt`, `sle`, `sgt`, `sge`, `seq`, `sne`

#### I类型（立即数操作）
```
| 31-26 | 25-21 | 20-16 | 15-0      |
| opcode| rd    | rs1   | immediate |
```
示例指令：`li`, `lw`, `sw`, `jt`, `jf`

#### J类型（跳转操作）
```
| 31-26 | 25-0      |
| opcode| immediate |
```
示例指令：`call`, `j`, `ret`, `halt`

### 核心指令集
- **算术运算**: `add`, `sub`, `mul`, `div`, `neg`
- **逻辑运算**: `and`, `or`, `xor`, `not`
- **比较运算**: `slt`, `sle`, `sgt`, `sge`, `seq`, `sne`
- **内存访问**: `lw`, `sw`, `lw_f`, `sw_f`（结构体字段访问）
- **控制流**: `call`, `ret`, `j`, `jt`, `jf`, `halt`
- **立即数加载**: `li`, `la`（加载地址）

## 5. 内存模型

### 内存区域划分
虚拟机内存分为以下区域：
- **代码区**: 存储字节码指令序列，只读。
- **数据区**: 全局变量和静态数据。
- **栈区**: 函数调用栈，每个线程独立。
- **堆区**: 动态分配的内存，用于对象和数组。

### 内存访问模式
- **全局变量**: 通过绝对地址或全局基址寄存器访问。
- **局部变量**: 通过帧指针（FP）相对寻址访问（`fp - offset`）。
- **结构体字段**: 通过`lw_f`/`sw_f`指令访问，支持字节偏移到字索引的转换。

## 6. 执行引擎

### 指令执行循环
```java
while (running) {
    instruction = fetch(pc);
    opcode = decode(instruction);

    // 指令合法性检查
    if (!validate(opcode)) {
        raiseException(INVALID_OPCODE);
        break;
    }

    // 执行指令
    switch (opcode) {
        case ADD: executeAdd(); break;
        case LW: executeLoad(); break;
        case CALL: executeCall(); break;
        // ...其他指令
    }

    // 更新PC
    pc += 4; // 32位定长指令

    // 检查运行时状态
    if (statusRegister & EXCEPTION_MASK) {
        handleException();
    }
}
```

### 异常处理机制
虚拟机支持以下异常类型：
1. **硬件异常**: 内存访问违规、除零错误。
2. **运行时异常**: 类型错误、索引越界。
3. **用户异常**: 程序显式抛出的异常。

## 7. 与ABI设计的一致性保证

### 当前实现状态
当前VM实现与目标ABI规范存在一些差异，详见[ABI设计文档附录D](../ep18r/docs/EP18R_ABI_设计文档.md#附录d当前实现与abi规范的差异)。这些差异将通过[TDD重构计划](../ep18r/docs/TDD重构计划.md)逐步消除。

### 一致性检查清单
- [ ] 寄存器命名和用途与ABI一致
- [ ] 栈帧布局与ABI一致
- [ ] 参数传递规则与ABI一致
- [ ] 返回值约定与ABI一致
- [ ] 栈对齐要求与ABI一致

## 8. 参考文档

1. [EP18R ABI设计文档](../ep18r/docs/EP18R_ABI_设计文档.md) - 详细的ABI规范
2. [TDD重构计划](../ep18r/docs/TDD重构计划.md) - VM与ABI统一的实施计划
3. [单元测试案例集](../ep18r/docs/单元测试案例集.md) - 测试用例参考
4. [根目录VM虚拟机设计文档](../../docs/VM虚拟机设计.md) - 更详细的VM设计概述

## 9. 版本历史

| 版本 | 日期 | 主要变更 |
|------|------|----------|
| v1.0 | 初始版本 | 基础VM设计 |
| v2.0 | 2025-12-18 | 与ABI设计统一，更新寄存器约定、调用约定、栈帧布局 |

---

**文档状态**: 正式发布，与ABI设计同步更新
**维护要求**: 任何VM设计变更必须同步更新ABI设计文档，确保两者一致。



